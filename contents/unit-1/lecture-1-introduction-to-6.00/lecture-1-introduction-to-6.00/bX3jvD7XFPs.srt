1
00:00:00,000 --> 00:00:00,530

2
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

3
00:00:02,960 --> 00:00:04,370
Commons license.

4
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

5
00:00:07,410 --> 00:00:11,060
offer high quality educational
resources for free.

6
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

7
00:00:13,960 --> 00:00:19,790
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:19,790 --> 00:00:21,040
ocw.mit.edu.

9
00:00:21,040 --> 00:00:23,520

10
00:00:23,520 --> 00:00:24,770
PROFESSOR: Good morning.

11
00:00:24,770 --> 00:00:27,870

12
00:00:27,870 --> 00:00:29,510
This is 600.

13
00:00:29,510 --> 00:00:32,790
So I hope any of you who thought
this was a different

14
00:00:32,790 --> 00:00:36,810
course find where you
really belong.

15
00:00:36,810 --> 00:00:38,950
My name is John Guttag.

16
00:00:38,950 --> 00:00:43,650
And I'll be lecturing the
course all semester.

17
00:00:43,650 --> 00:00:45,690
OK.

18
00:00:45,690 --> 00:00:48,400
Today I want to accomplish
several things.

19
00:00:48,400 --> 00:00:51,290
Cover some of the administrative
details.

20
00:00:51,290 --> 00:00:53,550
Talk about the goals
of the course--

21
00:00:53,550 --> 00:00:55,510
what I hope you'll learn.

22
00:00:55,510 --> 00:00:58,430
And then begin talking
about the conceptual

23
00:00:58,430 --> 00:01:01,530
material in the course.

24
00:01:01,530 --> 00:01:04,000
It will seem a little bit slow,
because it will be a

25
00:01:04,000 --> 00:01:05,430
little bit slow.

26
00:01:05,430 --> 00:01:08,020
I promise starting on Thursday
we're going to pick up the

27
00:01:08,020 --> 00:01:10,120
pace considerably.

28
00:01:10,120 --> 00:01:13,305
So let's start with the
strategic goals of the course.

29
00:01:13,305 --> 00:01:17,160

30
00:01:17,160 --> 00:01:21,420
The official introduction
to course 6 is 601.

31
00:01:21,420 --> 00:01:25,550
Historically, students who
arrive at MIT with little or

32
00:01:25,550 --> 00:01:30,930
no programming experience
find 601 an ordeal.

33
00:01:30,930 --> 00:01:33,650
And the point of this is
to prepare freshman and

34
00:01:33,650 --> 00:01:37,040
sophomores for entering
course 6--

35
00:01:37,040 --> 00:01:39,170
that's the Electrical
Engineering Computer Science

36
00:01:39,170 --> 00:01:40,210
department--

37
00:01:40,210 --> 00:01:43,070
in a gentler, kinder way.

38
00:01:43,070 --> 00:01:48,550
So that 601 is not so
much of a problem.

39
00:01:48,550 --> 00:01:51,270
I want to help students
feel justifiably--

40
00:01:51,270 --> 00:01:54,300
and I want to emphasize
the word justifiably--

41
00:01:54,300 --> 00:01:56,790
confident in their ability
to write small and

42
00:01:56,790 --> 00:01:59,050
medium sized programs.

43
00:01:59,050 --> 00:02:03,200
So at the end of the term, you
should all feel comfortable

44
00:02:03,200 --> 00:02:06,180
writing programs.

45
00:02:06,180 --> 00:02:08,900
The real theme of the course,
and what I spend most of the

46
00:02:08,900 --> 00:02:13,140
time on, is how to map
problems into a

47
00:02:13,140 --> 00:02:15,760
computational framework.

48
00:02:15,760 --> 00:02:18,190
There's going to be an emphasis
on scientific

49
00:02:18,190 --> 00:02:21,440
problems, rather than, say,
commercial problems.

50
00:02:21,440 --> 00:02:24,340
But there will be some talk
about some non-scientific

51
00:02:24,340 --> 00:02:26,090
problems as well.

52
00:02:26,090 --> 00:02:30,810
How to take a problem that may
not at first blush appear to

53
00:02:30,810 --> 00:02:34,690
be attackable with the program,
and show you how to

54
00:02:34,690 --> 00:02:38,090
formulate the problem in such
a way that you can use

55
00:02:38,090 --> 00:02:41,400
computation to get insight
into the problem.

56
00:02:41,400 --> 00:02:44,142
It should not take
you very long.

57
00:02:44,142 --> 00:02:47,750
All of the problem sets involve
programming in Python

58
00:02:47,750 --> 00:02:50,700
programming language, which I'll
say a little bit about

59
00:02:50,700 --> 00:02:52,700
later today.

60
00:02:52,700 --> 00:02:56,000
The first problem set,
basically, is getting Python

61
00:02:56,000 --> 00:02:58,880
installed on your
own computer.

62
00:02:58,880 --> 00:03:02,330
Most of the people will want to
just use whatever their own

63
00:03:02,330 --> 00:03:06,070
laptop is to do the
problem sets on.

64
00:03:06,070 --> 00:03:09,210
Don't get fooled by the first
two problem sets into thinking

65
00:03:09,210 --> 00:03:11,530
this is a gut course.

66
00:03:11,530 --> 00:03:12,950
It's not.

67
00:03:12,950 --> 00:03:17,610
It starts out gently
to lure you in.

68
00:03:17,610 --> 00:03:21,880
And then life gets pretty
hard pretty quickly.

69
00:03:21,880 --> 00:03:25,020
So don't be fooled.

70
00:03:25,020 --> 00:03:26,250
The quizzes--

71
00:03:26,250 --> 00:03:29,400
and there will be two evening
quizzes and a final--

72
00:03:29,400 --> 00:03:33,530
are open book open notes.

73
00:03:33,530 --> 00:03:36,480
When you get to be my age, you
get very sensitive about how

74
00:03:36,480 --> 00:03:39,140
difficult it is to
remember things.

75
00:03:39,140 --> 00:03:43,240
And so, we won't be asking
you to memorize stuff.

76
00:03:43,240 --> 00:03:46,530
The course is about solving
problems, knowing how to solve

77
00:03:46,530 --> 00:03:51,040
problems, not how much
you can remember.

78
00:03:51,040 --> 00:03:54,830
For many of you who are majoring
in biology or course

79
00:03:54,830 --> 00:03:58,420
20, it's going to be kind of a
shock that this course isn't

80
00:03:58,420 --> 00:04:01,910
about how much you can remember,
but it's about how

81
00:04:01,910 --> 00:04:04,220
well you can solve problems.

82
00:04:04,220 --> 00:04:06,200
And that's what the quizzes
are really going

83
00:04:06,200 --> 00:04:08,140
to be focused on.

84
00:04:08,140 --> 00:04:12,900
Probably the most unusual thing
about this course is the

85
00:04:12,900 --> 00:04:20,200
collaboration policy, which
is liberal in the extreme.

86
00:04:20,200 --> 00:04:23,770
You can collaborate with anybody
you want on any of the

87
00:04:23,770 --> 00:04:25,270
problem sets.

88
00:04:25,270 --> 00:04:26,570
Not on the quizzes.

89
00:04:26,570 --> 00:04:28,450
But on any of the
problem sets.

90
00:04:28,450 --> 00:04:32,090
You can work with each other,
which is what I recommend.

91
00:04:32,090 --> 00:04:35,020
You can work with your parents,
if one of them

92
00:04:35,020 --> 00:04:37,260
happens to be a software
engineer.

93
00:04:37,260 --> 00:04:39,690
You can work with friends
in course 6.

94
00:04:39,690 --> 00:04:42,780
Whatever you want to do.

95
00:04:42,780 --> 00:04:47,380
The goal of the problem sets
is to help you learn.

96
00:04:47,380 --> 00:04:51,750
What we've seen in the past is
people who are a little, shall

97
00:04:51,750 --> 00:04:55,500
I say too collaborative, i.e.
they just copy the problem set

98
00:04:55,500 --> 00:04:59,840
from somebody else, live in a
fool's paradise which comes

99
00:04:59,840 --> 00:05:03,150
crashing down at
the first quiz.

100
00:05:03,150 --> 00:05:06,130
People who don't spend enough
time thinking about the

101
00:05:06,130 --> 00:05:11,560
problem sets themselves cannot
take the quizzes successfully.

102
00:05:11,560 --> 00:05:15,510
So it's a fine line.

103
00:05:15,510 --> 00:05:19,570
But our goal is not
to be policemen.

104
00:05:19,570 --> 00:05:24,150
I tell my TAs, their job is to
help you learn, not to prevent

105
00:05:24,150 --> 00:05:26,540
you from, quote, cheating.

106
00:05:26,540 --> 00:05:29,480
So to solve that problem, we've
eliminated the concept

107
00:05:29,480 --> 00:05:31,580
of cheating on problem sets.

108
00:05:31,580 --> 00:05:34,230
There is no way to cheat
on problem sets.

109
00:05:34,230 --> 00:05:36,740
So just go and do them.

110
00:05:36,740 --> 00:05:38,830
There's no textbook.

111
00:05:38,830 --> 00:05:42,990
We will be posting readings
on the web.

112
00:05:42,990 --> 00:05:46,480
For the most part, these will
be pointers to websites.

113
00:05:46,480 --> 00:05:47,900
Occasionally we'll
post readings

114
00:05:47,900 --> 00:05:52,030
that we wrote ourselves.

115
00:05:52,030 --> 00:05:54,530
Doesn't mean you shouldn't
buy a textbook.

116
00:05:54,530 --> 00:05:58,690
In fact, there are a number
of Python texts.

117
00:05:58,690 --> 00:06:00,490
We'll recommend a few of them.

118
00:06:00,490 --> 00:06:04,020
It might make sense to buy one
and bring it to a quiz,

119
00:06:04,020 --> 00:06:06,250
because it will have an index
that will let you look things

120
00:06:06,250 --> 00:06:08,350
up quickly, that
sort of thing.

121
00:06:08,350 --> 00:06:11,320
But again, a lot of students
never buy a

122
00:06:11,320 --> 00:06:15,550
text and do just fine.

123
00:06:15,550 --> 00:06:17,780
We will not be handing
out class notes

124
00:06:17,780 --> 00:06:19,910
on a regular basis.

125
00:06:19,910 --> 00:06:23,680
A lot of studies have indicated
that students learn

126
00:06:23,680 --> 00:06:25,780
more when they take their own
notes than when they are

127
00:06:25,780 --> 00:06:27,400
handed out.

128
00:06:27,400 --> 00:06:30,600
And so, as a matter of what I
think is good pedagogy, we

129
00:06:30,600 --> 00:06:34,220
don't hand out detailed
lecture notes.

130
00:06:34,220 --> 00:06:39,360
We will be using, after today, a
lot of handouts with code on

131
00:06:39,360 --> 00:06:41,990
them, which we'll
make available.

132
00:06:41,990 --> 00:06:45,640
But it's not intended to make
any sense outside the context

133
00:06:45,640 --> 00:06:46,930
of lectures.

134
00:06:46,930 --> 00:06:48,710
It's not self-contained.

135
00:06:48,710 --> 00:06:52,120
The main purpose of this course
is to help you become

136
00:06:52,120 --> 00:06:55,220
skillful in making the
computer do what

137
00:06:55,220 --> 00:06:57,690
you want it to do.

138
00:06:57,690 --> 00:07:02,120
Once you acquire this skill,
your first instinct, when

139
00:07:02,120 --> 00:07:06,090
confronted with many tasks, will
be to write a program to

140
00:07:06,090 --> 00:07:09,370
do that task for you.

141
00:07:09,370 --> 00:07:13,030
I always tell people I became
a computer scientist in part

142
00:07:13,030 --> 00:07:15,010
because I'm lazy.

143
00:07:15,010 --> 00:07:18,230
And there was a lot of stuff
that I found it was easier to

144
00:07:18,230 --> 00:07:19,940
write a program to make
the computer do it,

145
00:07:19,940 --> 00:07:21,990
rather than do it myself.

146
00:07:21,990 --> 00:07:23,220
So I do that a lot.

147
00:07:23,220 --> 00:07:26,210
If I need to do something, I
say, can I just write a quick

148
00:07:26,210 --> 00:07:27,940
program to do it?

149
00:07:27,940 --> 00:07:30,810
And I'd like you to be able
to acquire that skill.

150
00:07:30,810 --> 00:07:34,440

151
00:07:34,440 --> 00:07:39,020
And remember, that programming
is actually a lot of fun.

152
00:07:39,020 --> 00:07:41,810
So I should say that, in
addition to learning a lot in

153
00:07:41,810 --> 00:07:45,900
this course, I hope most of
you will find it fun.

154
00:07:45,900 --> 00:07:47,820
Kind of a strange thought.

155
00:07:47,820 --> 00:07:49,485
MIT course, fun.

156
00:07:49,485 --> 00:07:52,070

157
00:07:52,070 --> 00:07:54,950
Maybe it's an oxymoron.

158
00:07:54,950 --> 00:07:56,540
But I don't think so.

159
00:07:56,540 --> 00:07:59,450
I really do think you can have
a lot of fun writing programs

160
00:07:59,450 --> 00:08:02,380
for this course.

161
00:08:02,380 --> 00:08:05,800
There are many people
who believe that--

162
00:08:05,800 --> 00:08:08,740
how shall I say this?

163
00:08:08,740 --> 00:08:10,660
Programming is the most
fun you can have with

164
00:08:10,660 --> 00:08:11,910
your clothes on.

165
00:08:11,910 --> 00:08:15,880

166
00:08:15,880 --> 00:08:18,410
It really can be a lot of fun.

167
00:08:18,410 --> 00:08:21,200
So think of it that way.

168
00:08:21,200 --> 00:08:23,080
All right.

169
00:08:23,080 --> 00:08:26,430
So the primary knowledge you're
going to take away is

170
00:08:26,430 --> 00:08:29,720
computational problem solving.

171
00:08:29,720 --> 00:08:33,010
So to start with, we might
ask the question, what is

172
00:08:33,010 --> 00:08:35,210
computation?

173
00:08:35,210 --> 00:08:37,940
And to think about that--

174
00:08:37,940 --> 00:08:39,442
this is interesting.

175
00:08:39,442 --> 00:08:42,490
Ah, there's where
the chalk is.

176
00:08:42,490 --> 00:08:45,960
I was afraid I was going to be
confronted with a sea of black

177
00:08:45,960 --> 00:08:49,770
boards and erasers
and no chalk.

178
00:08:49,770 --> 00:08:52,840
But there is chalk.

179
00:08:52,840 --> 00:08:55,990
So if we think about it,
there are essentially

180
00:08:55,990 --> 00:08:57,240
two kinds of knowledge.

181
00:08:57,240 --> 00:09:01,540

182
00:09:01,540 --> 00:09:03,520
Declarative--

183
00:09:03,520 --> 00:09:05,190
and you're going to see, I'm
not a great speller.

184
00:09:05,190 --> 00:09:09,500

185
00:09:09,500 --> 00:09:10,750
And imperative.

186
00:09:10,750 --> 00:09:18,750

187
00:09:18,750 --> 00:09:22,450
Declarative knowledge
is composed of

188
00:09:22,450 --> 00:09:25,120
statements of fact.

189
00:09:25,120 --> 00:09:29,260
For example, a good health care
plan improves the quality

190
00:09:29,260 --> 00:09:31,250
of medical care while
saving money.

191
00:09:31,250 --> 00:09:33,750

192
00:09:33,750 --> 00:09:37,490
As we know from doings in
Washington, it's a lot easier

193
00:09:37,490 --> 00:09:41,680
to state that goal than to know
how to achieve that goal.

194
00:09:41,680 --> 00:09:44,090
So the key thing about
declarative knowledge is, it

195
00:09:44,090 --> 00:09:46,390
says something that is true.

196
00:09:46,390 --> 00:09:49,340
Otherwise it wouldn't be
knowledge, it would be

197
00:09:49,340 --> 00:09:50,900
misinformation.

198
00:09:50,900 --> 00:09:54,030
But doesn't tell you
how to do it.

199
00:09:54,030 --> 00:09:59,140
In a more mathematical sense,
say y is the square root of x

200
00:09:59,140 --> 00:10:04,600
if and only if y times
y equals x.

201
00:10:04,600 --> 00:10:05,560
All right?

202
00:10:05,560 --> 00:10:08,450
Perfectly clear statement of
what it means to be the square

203
00:10:08,450 --> 00:10:15,280
root, but it doesn't tell you
how to find the square root.

204
00:10:15,280 --> 00:10:20,230
Interestingly enough, it does
tell you how to test whether

205
00:10:20,230 --> 00:10:24,250
or not you have the answer
to the square root.

206
00:10:24,250 --> 00:10:29,670
And so if you had some way of
generating guesses, you can at

207
00:10:29,670 --> 00:10:32,780
least check whether
they're correct.

208
00:10:32,780 --> 00:10:36,710
And in fact, starting in the
next lecture, we'll talk about

209
00:10:36,710 --> 00:10:41,100
the fact that a lot of
computational techniques

210
00:10:41,100 --> 00:10:44,030
involve something called
guess and check.

211
00:10:44,030 --> 00:10:46,530
Where you have a way to generate
guesses and a way to

212
00:10:46,530 --> 00:10:47,780
check whether they're right.

213
00:10:47,780 --> 00:10:52,230

214
00:10:52,230 --> 00:10:57,580
Imperative knowledge, in
contrast, tells you how to

215
00:10:57,580 --> 00:10:58,980
solve a problem.

216
00:10:58,980 --> 00:11:01,670
How to accomplish something.

217
00:11:01,670 --> 00:11:05,290
So you could think of it as like
a recipe in a cookbook.

218
00:11:05,290 --> 00:11:08,150
So it's one thing to say a
chocolate cake is something

219
00:11:08,150 --> 00:11:11,070
that tastes delicious
and is bad for you.

220
00:11:11,070 --> 00:11:13,830
That's declarative knowledge.

221
00:11:13,830 --> 00:11:16,380
But you can open a cookbook and
get a recipe that tells

222
00:11:16,380 --> 00:11:18,740
you how to make a
chocolate cake.

223
00:11:18,740 --> 00:11:22,130
That's imperative knowledge.

224
00:11:22,130 --> 00:11:28,700
Now, below, we have a recipe for
finding not a square root

225
00:11:28,700 --> 00:11:30,390
necessarily, but an

226
00:11:30,390 --> 00:11:33,280
approximation to a square root.

227
00:11:33,280 --> 00:11:37,830
And one of the themes of this
course is that a lot of

228
00:11:37,830 --> 00:11:43,300
problems we cannot solve
precisely, but we can find

229
00:11:43,300 --> 00:11:48,110
answers that are good enough
for practical purposes.

230
00:11:48,110 --> 00:11:51,840
And those are called
approximation algorithms.

231
00:11:51,840 --> 00:11:53,440
So here's a way--

232
00:11:53,440 --> 00:11:57,870
this is a very old method for
finding the square root.

233
00:11:57,870 --> 00:12:02,600
In fact, it's believed
that Heron was

234
00:12:02,600 --> 00:12:04,270
the one who did this.

235
00:12:04,270 --> 00:12:05,520
Heron of Alexandria.

236
00:12:05,520 --> 00:12:08,680

237
00:12:08,680 --> 00:12:11,690
In the news much today,
Alexandria was the capital of

238
00:12:11,690 --> 00:12:12,940
ancient Egypt.

239
00:12:12,940 --> 00:12:15,460

240
00:12:15,460 --> 00:12:17,300
He was the first one to
write this method

241
00:12:17,300 --> 00:12:21,200
down a long time ago.

242
00:12:21,200 --> 00:12:24,320
Though it's believed that even
before Heron, the Babylonians

243
00:12:24,320 --> 00:12:25,870
know how to do it.

244
00:12:25,870 --> 00:12:29,790
So you start with a guess, g.

245
00:12:29,790 --> 00:12:32,350
Any old guess will do.

246
00:12:32,350 --> 00:12:37,240
Then you say, is g times
g close enough to x?

247
00:12:37,240 --> 00:12:38,540
If so, you stop.

248
00:12:38,540 --> 00:12:43,370
Say OK, I've got a good enough
approximation of the answer.

249
00:12:43,370 --> 00:12:50,740
If it's not, you create a new
guess by averaging g and x

250
00:12:50,740 --> 00:12:52,810
divided by g.

251
00:12:52,810 --> 00:12:58,450
So g new is going to be
g old plus x divided

252
00:12:58,450 --> 00:13:01,690
by g old, over 2.

253
00:13:01,690 --> 00:13:07,390
And then using this new guess,
you go back to step 2.

254
00:13:07,390 --> 00:13:10,790
So let's quickly run through
an example of this.

255
00:13:10,790 --> 00:13:15,910
We can start with this
pretty easily.

256
00:13:15,910 --> 00:13:16,930
We'll take a guess.

257
00:13:16,930 --> 00:13:19,435
Let's say g equals 3.

258
00:13:19,435 --> 00:13:23,090

259
00:13:23,090 --> 00:13:25,160
So we look at three times 3.

260
00:13:25,160 --> 00:13:30,220

261
00:13:30,220 --> 00:13:31,210
9.

262
00:13:31,210 --> 00:13:34,910
And we say, is that
good enough?

263
00:13:34,910 --> 00:13:37,375
Well, let's say we're looking
for the root of 25.

264
00:13:37,375 --> 00:13:41,120

265
00:13:41,120 --> 00:13:43,480
I guess I should have started
with the problem statement.

266
00:13:43,480 --> 00:13:45,580
Sorry about that.

267
00:13:45,580 --> 00:13:49,640
Well, 9 is probably not close
enough to 25 that we're happy.

268
00:13:49,640 --> 00:13:52,150
May be good enough for
government work, but not for

269
00:13:52,150 --> 00:13:54,570
most other purposes.

270
00:13:54,570 --> 00:14:09,100
So we'll reset g, and we'll
set g to 3 plus 25 over 3.

271
00:14:09,100 --> 00:14:10,350
All of that over 2.

272
00:14:10,350 --> 00:14:12,810

273
00:14:12,810 --> 00:14:20,050
Which equals 5.6666 et cetera.

274
00:14:20,050 --> 00:14:20,420
All right.

275
00:14:20,420 --> 00:14:29,990
So now we'll multiply
that by itself.

276
00:14:29,990 --> 00:14:37,000
And that gets to
be about 32.04.

277
00:14:37,000 --> 00:14:39,070
Close enough to 25?

278
00:14:39,070 --> 00:14:40,320
Probably not.

279
00:14:40,320 --> 00:14:42,730

280
00:14:42,730 --> 00:14:46,610
So we'll take another step.

281
00:14:46,610 --> 00:14:48,230
And we'll set g equal to--

282
00:14:48,230 --> 00:14:52,210

283
00:14:52,210 --> 00:14:55,510
well, when we're done with it
all, I'm not going to bore you

284
00:14:55,510 --> 00:14:57,600
with writing the
formula again.

285
00:14:57,600 --> 00:15:00,980
It'll be 5.04.

286
00:15:00,980 --> 00:15:05,300
If we square that, it's 25.4.

287
00:15:05,300 --> 00:15:09,000
We decide that's close enough
to 25, and we're done.

288
00:15:09,000 --> 00:15:13,940

289
00:15:13,940 --> 00:15:19,220
What we say at this point
is that the algorithm--

290
00:15:19,220 --> 00:15:20,470
and that's an important word.

291
00:15:20,470 --> 00:15:30,260

292
00:15:30,260 --> 00:15:33,550
An algorithm is a description
of how to perform a

293
00:15:33,550 --> 00:15:34,800
computation.

294
00:15:34,800 --> 00:15:50,980

295
00:15:50,980 --> 00:15:54,280
We say that the algorithm
has converged.

296
00:15:54,280 --> 00:15:59,630

297
00:15:59,630 --> 00:16:02,205
Which is a fancy way
to say it's halted.

298
00:16:02,205 --> 00:16:08,150

299
00:16:08,150 --> 00:16:14,150
What we've got here, if you
think about it, is a set of

300
00:16:14,150 --> 00:16:15,400
instructions.

301
00:16:15,400 --> 00:16:21,270

302
00:16:21,270 --> 00:16:27,325
Steps that can be executed
and a flow of control.

303
00:16:27,325 --> 00:16:33,120

304
00:16:33,120 --> 00:16:36,200
The order in which
we execute them.

305
00:16:36,200 --> 00:16:41,340
So if we look at this, there's a
default order of execution--

306
00:16:41,340 --> 00:16:43,490
1, 2, 3, 4.

307
00:16:43,490 --> 00:16:48,590
But then there's the go back
to step 2 and start over.

308
00:16:48,590 --> 00:16:54,030

309
00:16:54,030 --> 00:16:57,905
And there's a termination
condition.

310
00:16:57,905 --> 00:17:09,109

311
00:17:09,109 --> 00:17:12,849
It tells us when to stop.

312
00:17:12,849 --> 00:17:15,310
And of course, that's
important.

313
00:17:15,310 --> 00:17:18,240
I've always been amused, if you
look at a shampoo bottle,

314
00:17:18,240 --> 00:17:21,260
you'll see an algorithm that
says something like lather,

315
00:17:21,260 --> 00:17:23,660
rinse, repeat.

316
00:17:23,660 --> 00:17:25,829
And if you follow it
literally, you

317
00:17:25,829 --> 00:17:27,960
never get to stop.

318
00:17:27,960 --> 00:17:30,320
Which I suppose make sense if
you're selling shampoo,

319
00:17:30,320 --> 00:17:32,480
because people use
a lot of it.

320
00:17:32,480 --> 00:17:34,490
But really, there
ought to be some

321
00:17:34,490 --> 00:17:38,220
termination condition there.

322
00:17:38,220 --> 00:17:39,350
OK.

323
00:17:39,350 --> 00:17:43,130
So now, how do we capture this
idea of a recipe in a

324
00:17:43,130 --> 00:17:46,110
mechanical process?

325
00:17:46,110 --> 00:17:50,390
One way would be to design a
machine specifically to do

326
00:17:50,390 --> 00:17:53,490
square roots.

327
00:17:53,490 --> 00:17:58,460
So if I knew how to design
circuits, which I don't, I

328
00:17:58,460 --> 00:18:01,980
could sit down-- probably many
of you could sit down--

329
00:18:01,980 --> 00:18:03,340
and design a circuit that would

330
00:18:03,340 --> 00:18:04,590
implement this algorithm.

331
00:18:04,590 --> 00:18:06,990

332
00:18:06,990 --> 00:18:10,410
And in fact, that's more or
less what you'll find in a

333
00:18:10,410 --> 00:18:14,080
cheap four function calculator
that does square roots.

334
00:18:14,080 --> 00:18:17,890
Not quite this algorithm, but
a similar algorithm is just

335
00:18:17,890 --> 00:18:23,220
part of the circuitry
to go compute that.

336
00:18:23,220 --> 00:18:26,830
And in fact, this used
to be the way that

337
00:18:26,830 --> 00:18:29,820
all computers worked.

338
00:18:29,820 --> 00:18:34,730
So the initial computers
were what are called

339
00:18:34,730 --> 00:18:36,123
fixed program computers.

340
00:18:36,123 --> 00:18:44,160

341
00:18:44,160 --> 00:18:49,020
They were designed to do very
specific things, and that's

342
00:18:49,020 --> 00:18:51,220
what they did.

343
00:18:51,220 --> 00:18:54,680
So for example, one of the very
first computers, designed

344
00:18:54,680 --> 00:19:00,590
in 1941, by Atanasoff and
Berry, solved systems of

345
00:19:00,590 --> 00:19:05,750
linear equations for the purpose
of plotting artillery

346
00:19:05,750 --> 00:19:08,180
trajectories.

347
00:19:08,180 --> 00:19:10,540
And that's all it did.

348
00:19:10,540 --> 00:19:12,740
If you wanted to balance your
bank account with this

349
00:19:12,740 --> 00:19:14,440
computer, you couldn't do it.

350
00:19:14,440 --> 00:19:16,420
But you could figure
out how to drop an

351
00:19:16,420 --> 00:19:19,570
artillery shell somewhere.

352
00:19:19,570 --> 00:19:23,830
Also during World War II, Alan
Turing built a machine

353
00:19:23,830 --> 00:19:26,560
specifically designed
for breaking the

354
00:19:26,560 --> 00:19:28,810
German enigma code.

355
00:19:28,810 --> 00:19:33,680
Actually a fascinating story of
science how that was built.

356
00:19:33,680 --> 00:19:35,590
But again, that was
all it could do.

357
00:19:35,590 --> 00:19:39,020

358
00:19:39,020 --> 00:19:43,780
These computers were useful,
but only in a

359
00:19:43,780 --> 00:19:46,370
very limited way.

360
00:19:46,370 --> 00:19:49,990
The big breakthrough, the thing
it made computation

361
00:19:49,990 --> 00:19:54,440
really important to society,
was the invention of the

362
00:19:54,440 --> 00:19:55,810
stored program computer.

363
00:19:55,810 --> 00:20:09,590

364
00:20:09,590 --> 00:20:12,350
It took people quite a while
to figure this out.

365
00:20:12,350 --> 00:20:15,350
But once they did,
it seems obvious.

366
00:20:15,350 --> 00:20:20,580
The basic notion of a stored
program computer is that the

367
00:20:20,580 --> 00:20:25,600
instructions are the
same as data.

368
00:20:25,600 --> 00:20:28,770
So now, there is no distinction
between the

369
00:20:28,770 --> 00:20:33,980
program that implements the
algorithm and the data on

370
00:20:33,980 --> 00:20:37,830
which that program operates.

371
00:20:37,830 --> 00:20:46,130
So there's no difference between
the input of 25, part

372
00:20:46,130 --> 00:20:52,890
of the data, and the steps of
the algorithm used to do that.

373
00:20:52,890 --> 00:20:55,540

374
00:20:55,540 --> 00:20:58,640
Once that was possible,
the machines

375
00:20:58,640 --> 00:21:02,460
became infinitely flexible.

376
00:21:02,460 --> 00:21:06,120
You could change the program
anytime you wanted.

377
00:21:06,120 --> 00:21:11,580
And furthermore, programs
could produce programs.

378
00:21:11,580 --> 00:21:14,660
Because programs can
produce data.

379
00:21:14,660 --> 00:21:17,440
And if program and data are
the same thing, that means

380
00:21:17,440 --> 00:21:19,850
programs can produce programs.

381
00:21:19,850 --> 00:21:21,980
And we were off and running.

382
00:21:21,980 --> 00:21:25,390
And that's really what made
computers what they are today.

383
00:21:25,390 --> 00:21:28,260

384
00:21:28,260 --> 00:21:36,840
Once this became clear as the
paradigm for computers, people

385
00:21:36,840 --> 00:21:40,340
began to think of the computer
itself as a program.

386
00:21:40,340 --> 00:21:43,220

387
00:21:43,220 --> 00:21:46,140
And in particular, as a kind
of program called an

388
00:21:46,140 --> 00:21:47,390
interpreter.

389
00:21:47,390 --> 00:21:49,270

390
00:21:49,270 --> 00:21:53,560
And we'll get to more
on this later today.

391
00:21:53,560 --> 00:21:59,530
An interpreter is a program that
can execute any legal set

392
00:21:59,530 --> 00:22:02,290
of instructions.

393
00:22:02,290 --> 00:22:07,860
And consequently, can be used
to describe and accomplish

394
00:22:07,860 --> 00:22:10,890
anything you can do
with a computer.

395
00:22:10,890 --> 00:22:13,950
So roughly speaking, this is
what a stored program computer

396
00:22:13,950 --> 00:22:15,570
looks like.

397
00:22:15,570 --> 00:22:19,670
This is 6004 in 40 seconds.

398
00:22:19,670 --> 00:22:22,010
It's got memory.

399
00:22:22,010 --> 00:22:25,050
Lots of it today.

400
00:22:25,050 --> 00:22:29,680
A control unit that basically
tells it what to do.

401
00:22:29,680 --> 00:22:33,340
For example, fetch some data
from memory, put some data

402
00:22:33,340 --> 00:22:38,350
into memory, send some output
to a screen, all of those

403
00:22:38,350 --> 00:22:40,090
kinds of things.

404
00:22:40,090 --> 00:22:43,880
What for historical reasons we
call the arithmetic logic

405
00:22:43,880 --> 00:22:47,630
unit, this is, in some sense,
the brains of the computer.

406
00:22:47,630 --> 00:22:51,570
The thing that actually
does computations.

407
00:22:51,570 --> 00:22:54,390
An accumulator, which
is part of the

408
00:22:54,390 --> 00:22:56,710
ALU that stores results.

409
00:22:56,710 --> 00:22:59,820
And a bunch of input
and output devices.

410
00:22:59,820 --> 00:23:03,340
The things that we actually see
when we use a computer.

411
00:23:03,340 --> 00:23:05,380
And that's it.

412
00:23:05,380 --> 00:23:08,840
And again, the key thing to
notice is, there's only one

413
00:23:08,840 --> 00:23:10,130
kind of memory.

414
00:23:10,130 --> 00:23:13,100
There's not a memory for program
and a memory for data.

415
00:23:13,100 --> 00:23:14,840
There's just the memory.

416
00:23:14,840 --> 00:23:18,160

417
00:23:18,160 --> 00:23:23,560
The nice thing to think about
here is, given a small set of

418
00:23:23,560 --> 00:23:28,130
instructions, you can
then build any kind

419
00:23:28,130 --> 00:23:29,870
of program you want.

420
00:23:29,870 --> 00:23:35,150
So typically, the computers have
a very small number of

421
00:23:35,150 --> 00:23:37,880
built-in instructions.

422
00:23:37,880 --> 00:23:41,880
Order of dozens,
and that's it.

423
00:23:41,880 --> 00:23:44,890
And by combining those
instructions in very clever

424
00:23:44,890 --> 00:23:49,890
ways, you can do arbitrarily
complex things.

425
00:23:49,890 --> 00:23:53,630
In much the same way a good
chef can take a very small

426
00:23:53,630 --> 00:23:56,885
number of ingredients, and from
those, produce a variety

427
00:23:56,885 --> 00:24:01,240
of interesting edibles.

428
00:24:01,240 --> 00:24:04,690
Alan Turing, in the 1930s--

429
00:24:04,690 --> 00:24:07,950
very famous British
mathematician of whom you will

430
00:24:07,950 --> 00:24:09,530
hear more--

431
00:24:09,530 --> 00:24:13,330
showed that, in fact, there
were six primitive

432
00:24:13,330 --> 00:24:15,630
instructions.

433
00:24:15,630 --> 00:24:21,330
Each of which operated on
one bit of information.

434
00:24:21,330 --> 00:24:24,610
And with those six primitive
instructions, you could do

435
00:24:24,610 --> 00:24:27,600
anything that could be
done with a computer.

436
00:24:27,600 --> 00:24:29,810
Kind of amazing.

437
00:24:29,810 --> 00:24:31,000
It was six instructions.

438
00:24:31,000 --> 00:24:36,100
There were things like
read, write, plus--

439
00:24:36,100 --> 00:24:37,110
I don't know, maybe minus.

440
00:24:37,110 --> 00:24:38,600
I forget what they were.

441
00:24:38,600 --> 00:24:39,220
And that was it.

442
00:24:39,220 --> 00:24:41,750
That's all you needed.

443
00:24:41,750 --> 00:24:44,210
We will not make you write
programs using only six

444
00:24:44,210 --> 00:24:44,520
instructions.

445
00:24:44,520 --> 00:24:47,240
We will give you a
much larger set.

446
00:24:47,240 --> 00:24:52,180
But still, it's really
quite remarkable.

447
00:24:52,180 --> 00:24:57,470
It's what makes programming
such an amazing endeavor.

448
00:24:57,470 --> 00:24:59,230
OK.

449
00:24:59,230 --> 00:25:02,590
So what instructions
will you be using?

450
00:25:02,590 --> 00:25:05,840
Well, that's what a programming
language does.

451
00:25:05,840 --> 00:25:11,000
So a programming language
provides a set of primitive

452
00:25:11,000 --> 00:25:13,630
instructions.

453
00:25:13,630 --> 00:25:18,660
A set of primitive control
structures.

454
00:25:18,660 --> 00:25:23,110
So instructions and mechanisms
for controlling the order in

455
00:25:23,110 --> 00:25:25,680
which they get executed.

456
00:25:25,680 --> 00:25:28,090
And that's all.

457
00:25:28,090 --> 00:25:30,620
And then you can do whatever
you want with them.

458
00:25:30,620 --> 00:25:33,330
And what distinguishes one
programming language from

459
00:25:33,330 --> 00:25:36,440
another is what these
things are.

460
00:25:36,440 --> 00:25:38,210
What are your instructions?

461
00:25:38,210 --> 00:25:40,520
What of your flow of control?

462
00:25:40,520 --> 00:25:42,810
And how do you combine them?

463
00:25:42,810 --> 00:25:45,780
What are the combining
mechanisms?

464
00:25:45,780 --> 00:25:48,530
And in fact, it's the combining
mechanisms more than

465
00:25:48,530 --> 00:25:52,080
anything else that separate
one language from another.

466
00:25:52,080 --> 00:25:55,800

467
00:25:55,800 --> 00:26:00,000
The most amazing thing
about programming--

468
00:26:00,000 --> 00:26:03,270
and this has its good side and
its bad side, and it's

469
00:26:03,270 --> 00:26:06,900
something you need to remember
as you do the problem sets--

470
00:26:06,900 --> 00:26:11,730
is that the computer will always
do exactly what you

471
00:26:11,730 --> 00:26:14,020
tell what to do.

472
00:26:14,020 --> 00:26:15,300
It's remarkable.

473
00:26:15,300 --> 00:26:17,210
You don't have any friends
who will do whatever you

474
00:26:17,210 --> 00:26:19,920
tell them to do.

475
00:26:19,920 --> 00:26:22,110
I can tell you my children
certainly don't do whatever I

476
00:26:22,110 --> 00:26:23,980
tell them to do.

477
00:26:23,980 --> 00:26:27,610
And my wife doesn't either.

478
00:26:27,610 --> 00:26:30,090
Sometimes she probably
thinks I do whatever

479
00:26:30,090 --> 00:26:31,610
she tells me to do.

480
00:26:31,610 --> 00:26:35,540
But a computer will do what
you tell it to do.

481
00:26:35,540 --> 00:26:38,510
So that's very empowering.

482
00:26:38,510 --> 00:26:40,960
It's also very annoying.

483
00:26:40,960 --> 00:26:43,800
Because it means if your program
doesn't work, it's

484
00:26:43,800 --> 00:26:45,820
your own darn fault.

485
00:26:45,820 --> 00:26:49,040
You got nobody else to
blame but yourself.

486
00:26:49,040 --> 00:26:51,360
Because it's not the
computer's fault.

487
00:26:51,360 --> 00:26:54,060
You may want to curse the
computer, but you shouldn't.

488
00:26:54,060 --> 00:26:56,620
It's just doing what
you told it to.

489
00:26:56,620 --> 00:27:00,700
So be careful what
you wish for.

490
00:27:00,700 --> 00:27:01,250
All right.

491
00:27:01,250 --> 00:27:05,200
The programming language we're
going to use in 600 is Python.

492
00:27:05,200 --> 00:27:18,130

493
00:27:18,130 --> 00:27:20,530
It's a relatively recent
addition to

494
00:27:20,530 --> 00:27:23,710
the universe of languages.

495
00:27:23,710 --> 00:27:27,020
I want to emphasize that
this course is not

496
00:27:27,020 --> 00:27:29,150
about learning Python.

497
00:27:29,150 --> 00:27:33,150
I will spend relatively little
time in the lectures telling

498
00:27:33,150 --> 00:27:35,270
you about Python.

499
00:27:35,270 --> 00:27:39,260
It's about computational
methods, is what this course

500
00:27:39,260 --> 00:27:40,420
is really about.

501
00:27:40,420 --> 00:27:42,660
And Python is merely
a teaching tool.

502
00:27:42,660 --> 00:27:45,870

503
00:27:45,870 --> 00:27:49,910
Once you learn to program in
Python, it's easy to learn to

504
00:27:49,910 --> 00:27:51,370
program in another language.

505
00:27:51,370 --> 00:27:54,400
It's a very easily transferable
skill.

506
00:27:54,400 --> 00:27:57,220

507
00:27:57,220 --> 00:28:03,060
If we think about what defines
any programming language, it's

508
00:28:03,060 --> 00:28:17,206
got a syntax, a static
semantics, and a semantics.

509
00:28:17,206 --> 00:28:25,020

510
00:28:25,020 --> 00:28:26,445
Are any of you here linguistics
majors?

511
00:28:26,445 --> 00:28:29,110

512
00:28:29,110 --> 00:28:29,640
Not a one.

513
00:28:29,640 --> 00:28:30,230
All right.

514
00:28:30,230 --> 00:28:32,710
Then I can make up whatever I
want about these terms and

515
00:28:32,710 --> 00:28:34,580
maybe you'll believe me.

516
00:28:34,580 --> 00:28:36,140
All right.

517
00:28:36,140 --> 00:28:43,510
So the syntax tells us which
sequences of characters and

518
00:28:43,510 --> 00:28:46,710
symbols constitute a
well-formed string.

519
00:28:46,710 --> 00:28:52,220

520
00:28:52,220 --> 00:28:56,470
So it would tell us, maybe, that
we could write something

521
00:28:56,470 --> 00:29:03,875
like x equals 3 plus 4.

522
00:29:03,875 --> 00:29:06,570

523
00:29:06,570 --> 00:29:09,070
And that's syntactically
correct.

524
00:29:09,070 --> 00:29:10,850
It's well-formed.

525
00:29:10,850 --> 00:29:16,920
It might also tell us that
x equals 3 blank 4 is not

526
00:29:16,920 --> 00:29:18,700
syntactically correct.

527
00:29:18,700 --> 00:29:20,175
It's not a legal string.

528
00:29:20,175 --> 00:29:22,750

529
00:29:22,750 --> 00:29:28,340
So by analogy with English,
the syntax describes which

530
00:29:28,340 --> 00:29:31,995
strings of words constitute
well-formed sentences.

531
00:29:31,995 --> 00:29:36,230

532
00:29:36,230 --> 00:29:38,010
Well-formed.

533
00:29:38,010 --> 00:29:41,270
Not necessarily meaningful.

534
00:29:41,270 --> 00:29:48,100
So it would tell you that some
sentence like Susan is

535
00:29:48,100 --> 00:29:52,130
building is syntactically
well-formed.

536
00:29:52,130 --> 00:29:53,445
It may not be very sensible.

537
00:29:53,445 --> 00:29:57,180

538
00:29:57,180 --> 00:30:02,020
The static semantics tells
us which well-formed

539
00:30:02,020 --> 00:30:05,870
strings have a meaning.

540
00:30:05,870 --> 00:30:07,480
That are which strings
are meaningful.

541
00:30:07,480 --> 00:30:11,530

542
00:30:11,530 --> 00:30:16,430
So you can think about that
as also making sense.

543
00:30:16,430 --> 00:30:24,790
So in Python, it might tell us
that some strings which are

544
00:30:24,790 --> 00:30:28,620
syntactically fine don't
mean anything.

545
00:30:28,620 --> 00:30:34,210
So for example, it might tell
us that the string 3 divided

546
00:30:34,210 --> 00:30:40,490
by the character string abc is
syntactically well-formed

547
00:30:40,490 --> 00:30:47,120
because it's value
operator value.

548
00:30:47,120 --> 00:30:49,960
Sort of like noun verb
noun is syntactically

549
00:30:49,960 --> 00:30:51,620
well-formed in English.

550
00:30:51,620 --> 00:30:54,370
But it would tell us
that there's no

551
00:30:54,370 --> 00:30:55,450
real meaning to this.

552
00:30:55,450 --> 00:31:00,070
Dividing a number by a string
doesn't mean anything.

553
00:31:00,070 --> 00:31:03,870
And so you would get an error
message saying the syntax is

554
00:31:03,870 --> 00:31:07,105
OK, but the static semantics
is broken.

555
00:31:07,105 --> 00:31:10,710

556
00:31:10,710 --> 00:31:16,780
So for example, in English ,
the sentence I are big is

557
00:31:16,780 --> 00:31:20,520
somehow syntactically
well-formed--

558
00:31:20,520 --> 00:31:21,870
noun verb noun--

559
00:31:21,870 --> 00:31:26,880
but we might say it fails the
static semantic test.

560
00:31:26,880 --> 00:31:30,930
We don't want to assign
a meaning to it.

561
00:31:30,930 --> 00:31:35,300
The semantics of the language
looks only at the strings that

562
00:31:35,300 --> 00:31:39,350
are both syntactically correct
and static semantically

563
00:31:39,350 --> 00:31:44,880
correct, and assigns a
real meaning to them.

564
00:31:44,880 --> 00:31:50,440
In natural language, sentences
can be ambiguous.

565
00:31:50,440 --> 00:31:53,270
So one of my favorites, when I
have to write a recommendation

566
00:31:53,270 --> 00:31:56,560
letter for a student that maybe
I don't think is so

567
00:31:56,560 --> 00:31:59,710
good, I might say something
like I cannot praise this

568
00:31:59,710 --> 00:32:02,190
student too highly.

569
00:32:02,190 --> 00:32:06,390
Well, you can interpret
that however you want.

570
00:32:06,390 --> 00:32:10,990
It keeps me from getting sued,
but I can also claim, well, I

571
00:32:10,990 --> 00:32:13,270
don't like the student at all.

572
00:32:13,270 --> 00:32:15,930
And English is full
of those things.

573
00:32:15,930 --> 00:32:20,410
Programming languages, in
contrast, are designed so that

574
00:32:20,410 --> 00:32:26,170
every well-formed program
has exactly one meaning.

575
00:32:26,170 --> 00:32:27,420
There's no ambiguity.

576
00:32:27,420 --> 00:32:29,790

577
00:32:29,790 --> 00:32:33,510
So you can't typically
talk of a program as

578
00:32:33,510 --> 00:32:34,935
having a semantic error.

579
00:32:34,935 --> 00:32:37,660

580
00:32:37,660 --> 00:32:39,690
If it is well-formed, it
means something, and

581
00:32:39,690 --> 00:32:42,110
that's what it means.

582
00:32:42,110 --> 00:32:46,120
On the other hand, it's easy
to talk about a program

583
00:32:46,120 --> 00:32:49,730
meaning something other than
you wanted it to mean.

584
00:32:49,730 --> 00:32:53,220
And you will discover in the
problem sets, most of the time

585
00:32:53,220 --> 00:32:56,550
the programs don't mean what
you want them to mean.

586
00:32:56,550 --> 00:32:58,920
That is to say, when you run
them, they don't give you the

587
00:32:58,920 --> 00:33:00,580
correct answer.

588
00:33:00,580 --> 00:33:03,030
And then you will go through
this process of debugging them

589
00:33:03,030 --> 00:33:05,460
and learning how to do it.

590
00:33:05,460 --> 00:33:10,280
So what might happen when we
write a program that doesn't

591
00:33:10,280 --> 00:33:13,870
do what we want it to do?

592
00:33:13,870 --> 00:33:15,120
It might crash.

593
00:33:15,120 --> 00:33:19,600

594
00:33:19,600 --> 00:33:23,660
By that, we mean stop running
and produce some palpable

595
00:33:23,660 --> 00:33:27,030
indication that it
has done so.

596
00:33:27,030 --> 00:33:30,830
So you've all used programs
that have crashed, right?

597
00:33:30,830 --> 00:33:35,400
You sat there using your email
program or Word, or

598
00:33:35,400 --> 00:33:37,150
PowerPoint, or something.

599
00:33:37,150 --> 00:33:38,940
And suddenly, it
just goes away.

600
00:33:38,940 --> 00:33:43,650
And you get a message on your
screen and an invitation to

601
00:33:43,650 --> 00:33:49,050
send Apple or Microsoft a file
explaining what went wrong so

602
00:33:49,050 --> 00:33:50,300
they can fix it.

603
00:33:50,300 --> 00:33:53,820

604
00:33:53,820 --> 00:33:57,480
In a properly designed computing
system, when one

605
00:33:57,480 --> 00:34:00,915
program crashes, it does not
damage the overall system.

606
00:34:00,915 --> 00:34:03,430

607
00:34:03,430 --> 00:34:06,500
So you'd like it to
just be local.

608
00:34:06,500 --> 00:34:09,050
What else might it do?

609
00:34:09,050 --> 00:34:10,600
It might never stop.

610
00:34:10,600 --> 00:34:21,170

611
00:34:21,170 --> 00:34:24,449
Now, if you have no idea how
long a program is supposed to

612
00:34:24,449 --> 00:34:26,839
run, this can be hard
to diagnose.

613
00:34:26,839 --> 00:34:29,710

614
00:34:29,710 --> 00:34:31,690
But again, I'm sure you've
all run into this.

615
00:34:31,690 --> 00:34:33,260
I've certainly run into it.

616
00:34:33,260 --> 00:34:35,560
Every once in a while I'll
say, try and write a

617
00:34:35,560 --> 00:34:37,300
PowerPoint file.

618
00:34:37,300 --> 00:34:39,830
And it'll just sit there.

619
00:34:39,830 --> 00:34:42,639
Or I'll try to read a file and
it'll just sit there and never

620
00:34:42,639 --> 00:34:44,449
finish the job.

621
00:34:44,449 --> 00:34:46,940
Or I don't have enough
patience.

622
00:34:46,940 --> 00:34:50,020
But probably it would never
have finished it.

623
00:34:50,020 --> 00:34:53,409
Again, you will all write
programs that do this.

624
00:34:53,409 --> 00:34:56,889
It's a good idea to know how
long you expect your programs

625
00:34:56,889 --> 00:35:00,380
to run, so that you can
recognize this.

626
00:35:00,380 --> 00:35:03,010
Typically, we say that these
programs have in them an

627
00:35:03,010 --> 00:35:04,260
infinite loop.

628
00:35:04,260 --> 00:35:09,250

629
00:35:09,250 --> 00:35:13,090
And we'll talk about that when
we get to flow of control.

630
00:35:13,090 --> 00:35:28,530
Finally, a program might run to
completion and produce the

631
00:35:28,530 --> 00:35:29,780
wrong answer.

632
00:35:29,780 --> 00:35:38,760

633
00:35:38,760 --> 00:35:42,680
These problems are kind of in
ascending order of badness.

634
00:35:42,680 --> 00:35:46,310

635
00:35:46,310 --> 00:35:48,360
If it crashes, at least
you know that

636
00:35:48,360 --> 00:35:51,770
something has gone wrong.

637
00:35:51,770 --> 00:35:55,050
An infinite loop can be very
annoying, because you just

638
00:35:55,050 --> 00:35:56,530
wait for a long time.

639
00:35:56,530 --> 00:35:58,590
But the worst thing that happens
is when you think

640
00:35:58,590 --> 00:36:00,665
everything is good
and it's not.

641
00:36:00,665 --> 00:36:03,230

642
00:36:03,230 --> 00:36:05,840
There have been lots of
examples of this.

643
00:36:05,840 --> 00:36:08,695
This is the sort of thing
that costs lives.

644
00:36:08,695 --> 00:36:11,380

645
00:36:11,380 --> 00:36:15,780
There was a radiation therapy
machine that produced the

646
00:36:15,780 --> 00:36:21,650
wrong dosage of radiation and
actually killed quite a few

647
00:36:21,650 --> 00:36:25,270
people, because they put in
the correct input, and it

648
00:36:25,270 --> 00:36:28,220
would dose the patient
with radiation.

649
00:36:28,220 --> 00:36:32,120
And a fatal dose of radiation.

650
00:36:32,120 --> 00:36:35,000
That's a really bad mistake.

651
00:36:35,000 --> 00:36:37,710
There are buildings that
collapse because people run

652
00:36:37,710 --> 00:36:40,550
programs that do the structural
engineering, and

653
00:36:40,550 --> 00:36:43,520
the programs give the
wrong answer.

654
00:36:43,520 --> 00:36:45,770
Lots of bad things can happen.

655
00:36:45,770 --> 00:36:48,330
So one of the things we're going
to spend time on this

656
00:36:48,330 --> 00:36:53,750
term is, what you can do to
avoid writing programs that

657
00:36:53,750 --> 00:36:57,120
have this rather unpleasant
property.

658
00:36:57,120 --> 00:36:58,940
How do you test them?

659
00:36:58,940 --> 00:37:02,520
How do you write them in such
a way that this is the least

660
00:37:02,520 --> 00:37:04,420
likely event?

661
00:37:04,420 --> 00:37:06,280
That's not what you
want to happen.

662
00:37:06,280 --> 00:37:09,220

663
00:37:09,220 --> 00:37:10,000
OK.

664
00:37:10,000 --> 00:37:14,620
Some programming languages
give you a lot of help in

665
00:37:14,620 --> 00:37:17,860
avoiding these things.

666
00:37:17,860 --> 00:37:21,980
Python is kind of mediocre
in that respect.

667
00:37:21,980 --> 00:37:23,080
It's not the best.

668
00:37:23,080 --> 00:37:24,920
It's not the worst.

669
00:37:24,920 --> 00:37:28,640
It's somewhere in the middle.

670
00:37:28,640 --> 00:37:33,500
Because what you'd like is a
program with very rigorous

671
00:37:33,500 --> 00:37:39,550
static semantics, such that if
you pass those tests, it has a

672
00:37:39,550 --> 00:37:44,120
high probability of behaving
as expected.

673
00:37:44,120 --> 00:37:47,990
So for example, it's a good
thing that Python doesn't

674
00:37:47,990 --> 00:37:51,290
allow you to do this.

675
00:37:51,290 --> 00:37:54,180
Because who knows what
that's going to do?

676
00:37:54,180 --> 00:37:55,520
Something weird.

677
00:37:55,520 --> 00:37:58,650
You'd rather be told no,
you can't write that.

678
00:37:58,650 --> 00:38:00,770
And then you have to write
something that's more

679
00:38:00,770 --> 00:38:02,390
obviously meaningful.

680
00:38:02,390 --> 00:38:06,510
Rather than it just making
up an interpretation.

681
00:38:06,510 --> 00:38:11,160
As we will see going forward,
Python is not, for example, as

682
00:38:11,160 --> 00:38:16,640
good as Java is at weeding
out meaningless things.

683
00:38:16,640 --> 00:38:19,680
Or things that have surprising
meanings.

684
00:38:19,680 --> 00:38:23,350
On the other hand, it's better
than C. So kind of in the

685
00:38:23,350 --> 00:38:27,370
middle as these programming
languages go.

686
00:38:27,370 --> 00:38:31,330
Why do we use Python in this
course if it's not the best in

687
00:38:31,330 --> 00:38:33,500
that respect?

688
00:38:33,500 --> 00:38:37,730
It's got several
good features.

689
00:38:37,730 --> 00:38:42,260
One of them is, it's
easy to learn.

690
00:38:42,260 --> 00:38:45,280
It's much less complicated
than, say, Java.

691
00:38:45,280 --> 00:38:47,390
So the learning curve
is much steeper.

692
00:38:47,390 --> 00:38:48,740
That's a good thing.

693
00:38:48,740 --> 00:38:51,910
You get up to speed faster.

694
00:38:51,910 --> 00:38:57,720
It's very widely used today in
a lot of areas of science,

695
00:38:57,720 --> 00:38:59,770
particularly the
life sciences.

696
00:38:59,770 --> 00:39:03,060
It has probably become the
most popular language in

697
00:39:03,060 --> 00:39:05,850
biology and the other
life sciences.

698
00:39:05,850 --> 00:39:08,220
And therefore, for those of you
who have careers in that

699
00:39:08,220 --> 00:39:12,830
area, it's the most useful
language to know.

700
00:39:12,830 --> 00:39:16,830
It's also widely used in
other areas as well.

701
00:39:16,830 --> 00:39:21,370
It is easier to debug
than most languages.

702
00:39:21,370 --> 00:39:25,380
And the reason it's easier to
debug than most languages, or

703
00:39:25,380 --> 00:39:29,960
than many, is it's an
interpreted language.

704
00:39:29,960 --> 00:39:33,050
So you'll remember, I talked
about a computer as an

705
00:39:33,050 --> 00:39:34,820
interpreter.

706
00:39:34,820 --> 00:39:39,330
Something that you feed in a
bunch of instructions, called

707
00:39:39,330 --> 00:39:41,620
the source code.

708
00:39:41,620 --> 00:39:43,780
You do some checking.

709
00:39:43,780 --> 00:39:46,470
And then it executes the
instructions, including the

710
00:39:46,470 --> 00:39:48,650
flow of control instructions.

711
00:39:48,650 --> 00:39:51,490
Produces some output.

712
00:39:51,490 --> 00:39:55,860
The nice thing that goes on
there is if something untoward

713
00:39:55,860 --> 00:40:00,690
happens, the interpreter can
describe in the language of

714
00:40:00,690 --> 00:40:04,260
the source code what
went wrong.

715
00:40:04,260 --> 00:40:07,700
The source code is the
code that you wrote.

716
00:40:07,700 --> 00:40:13,130
On the other hand, the way a
compiler works is, you take

717
00:40:13,130 --> 00:40:18,500
the source code, you check it,
but then you translate it into

718
00:40:18,500 --> 00:40:21,830
another language called
the object code.

719
00:40:21,830 --> 00:40:26,360
This is a language closer
to the language that the

720
00:40:26,360 --> 00:40:31,040
computer, the hardware, knows
how to interpret.

721
00:40:31,040 --> 00:40:35,520
Then the hardware interpreter
interprets the compiled code,

722
00:40:35,520 --> 00:40:39,050
the object code, and
produces output.

723
00:40:39,050 --> 00:40:43,960
And the problem here is if
something goes wrong, it wants

724
00:40:43,960 --> 00:40:48,190
to give you an error message in
terms of the object code,

725
00:40:48,190 --> 00:40:51,880
which you've never seen
in your life.

726
00:40:51,880 --> 00:40:54,720
And that can make
it very obscure.

727
00:40:54,720 --> 00:40:56,340
So the advantage?

728
00:40:56,340 --> 00:40:58,390
Why do we have compilers?

729
00:40:58,390 --> 00:41:00,930
Typically, compiled languages
are more efficient.

730
00:41:00,930 --> 00:41:03,470

731
00:41:03,470 --> 00:41:07,700
Because they go through this
extra step, they take less

732
00:41:07,700 --> 00:41:11,040
time to run those programs.

733
00:41:11,040 --> 00:41:13,830
You can compile Python as well,
if you want to get an

734
00:41:13,830 --> 00:41:15,420
efficient version.

735
00:41:15,420 --> 00:41:19,420
But it's not designed under
that assumption.

736
00:41:19,420 --> 00:41:22,310
And so, it works well when
it's interpreted, which

737
00:41:22,310 --> 00:41:23,560
is why we use it.

738
00:41:23,560 --> 00:41:27,722
1
00:00:00,000 --> 00:00:00,040

2
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

3
00:00:02,460 --> 00:00:03,870
Commons license.

4
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

5
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

6
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

7
00:00:13,460 --> 00:00:19,290
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:19,290 --> 00:00:21,860
ocw.mit.edu.

9
00:00:21,860 --> 00:00:24,570
PROFESSOR: I apologize to
those of you watching on

10
00:00:24,570 --> 00:00:25,640
OpenCourseWare.

11
00:00:25,640 --> 00:00:28,240
I forgot to turn on
my microphone.

12
00:00:28,240 --> 00:00:31,690
And you missed some incredibly
brilliant things.

13
00:00:31,690 --> 00:00:33,190
But such is life.

14
00:00:33,190 --> 00:00:36,430

15
00:00:36,430 --> 00:00:39,930
Let me go back to where I was,
which was we we're looking at

16
00:00:39,930 --> 00:00:44,610
this code to find the cube
root of a perfect cube.

17
00:00:44,610 --> 00:00:47,880
We saw this last week, and
indeed, you also saw it in

18
00:00:47,880 --> 00:00:49,300
recitation.

19
00:00:49,300 --> 00:00:52,800
I'm not going to belabor it.

20
00:00:52,800 --> 00:00:57,400
I do want to ask you the
question, for what values will

21
00:00:57,400 --> 00:00:58,705
this program terminate?

22
00:00:58,705 --> 00:01:01,710

23
00:01:01,710 --> 00:01:04,239
That is to say the only
input is to x.

24
00:01:04,239 --> 00:01:06,950
For what values of
x is this program

25
00:01:06,950 --> 00:01:09,453
guaranteed to always stop?

26
00:01:09,453 --> 00:01:15,930

27
00:01:15,930 --> 00:01:18,050
Anybody want to volunteer
an answer to that?

28
00:01:18,050 --> 00:01:21,380

29
00:01:21,380 --> 00:01:22,660
Ask a simpler question.

30
00:01:22,660 --> 00:01:25,360
Let's assume that
x is a number.

31
00:01:25,360 --> 00:01:27,020
In fact, let's assume
it's an integer.

32
00:01:27,020 --> 00:01:29,930

33
00:01:29,930 --> 00:01:33,400
Will it terminate for all
positive integers, all

34
00:01:33,400 --> 00:01:35,900
positive values of x?

35
00:01:35,900 --> 00:01:36,950
Yeah.

36
00:01:36,950 --> 00:01:39,890
All negative values?

37
00:01:39,890 --> 00:01:41,690
As far as I can tell.

38
00:01:41,690 --> 00:01:43,250
How about 0?

39
00:01:43,250 --> 00:01:44,300
Yeah.

40
00:01:44,300 --> 00:01:48,640
So in fact, it terminates
for all values of x.

41
00:01:48,640 --> 00:01:51,470
How do I know that?

42
00:01:51,470 --> 00:01:53,560
And that's a key question.

43
00:01:53,560 --> 00:01:58,120
I know that because I've used,
and I mean by used as a mental

44
00:01:58,120 --> 00:02:01,620
tool, something in my head,
the notion of a

45
00:02:01,620 --> 00:02:02,870
decrementing function.

46
00:02:02,870 --> 00:02:11,360

47
00:02:11,360 --> 00:02:16,250
And every time I write a loop,
I think about one of these,

48
00:02:16,250 --> 00:02:19,540
because that explains to
me why the loop is

49
00:02:19,540 --> 00:02:22,900
guaranteed to terminate.

50
00:02:22,900 --> 00:02:26,920
We'll go over here where we have
a bigger board and look

51
00:02:26,920 --> 00:02:29,690
at the properties that
a decrementing

52
00:02:29,690 --> 00:02:30,940
function needs to have.

53
00:02:30,940 --> 00:02:35,850

54
00:02:35,850 --> 00:02:42,720
One, it will map some
set of program

55
00:02:42,720 --> 00:02:54,665
variables to an integer.

56
00:02:54,665 --> 00:03:04,880

57
00:03:04,880 --> 00:03:10,490
Two, when the loop is entered
for the first time or when I

58
00:03:10,490 --> 00:03:14,070
encountered the test of the loop
for the first time, its

59
00:03:14,070 --> 00:03:15,710
value is non-negative.

60
00:03:15,710 --> 00:03:30,770

61
00:03:30,770 --> 00:03:41,930
Three, when its value gets to
be less than or equal to 0,

62
00:03:41,930 --> 00:03:43,180
the loop terminates.

63
00:03:43,180 --> 00:03:49,530

64
00:03:49,530 --> 00:03:56,600
And finally four, it's
decreased each

65
00:03:56,600 --> 00:03:58,566
time through the loop.

66
00:03:58,566 --> 00:04:08,430

67
00:04:08,430 --> 00:04:13,290
So what we see is if it starts
to be a positive value or

68
00:04:13,290 --> 00:04:17,839
non-negative, and it's decreased
every time I execute

69
00:04:17,839 --> 00:04:22,710
the body of a loop, that
eventually, it's got to reach

70
00:04:22,710 --> 00:04:25,290
0 or something less than 0.

71
00:04:25,290 --> 00:04:26,720
And when it does,
the loop stops.

72
00:04:26,720 --> 00:04:29,820

73
00:04:29,820 --> 00:04:33,840
If such a function exists, then
the loop is guaranteed to

74
00:04:33,840 --> 00:04:35,090
always terminate.

75
00:04:35,090 --> 00:04:38,570

76
00:04:38,570 --> 00:04:42,190
Now, of course, one can count up
to a value instead of down.

77
00:04:42,190 --> 00:04:45,180
But there's always a trick we
can use of subtracting to make

78
00:04:45,180 --> 00:04:46,730
it the same.

79
00:04:46,730 --> 00:04:50,960
So what's the decrementing
function for this loop?

80
00:04:50,960 --> 00:04:52,625
How did I know it will
always terminate?

81
00:04:52,625 --> 00:04:58,030

82
00:04:58,030 --> 00:04:58,460
Yeah?

83
00:04:58,460 --> 00:05:00,915
AUDIENCE: [INAUDIBLE].

84
00:05:00,915 --> 00:05:04,760
PROFESSOR: Answer equals
answer plus 1.

85
00:05:04,760 --> 00:05:07,030
I don't think so.

86
00:05:07,030 --> 00:05:09,010
Does that satisfy all
of these properties?

87
00:05:09,010 --> 00:05:13,870

88
00:05:13,870 --> 00:05:17,320
Remember, a function is going
to map some set of program

89
00:05:17,320 --> 00:05:23,680
variables to an integer.

90
00:05:23,680 --> 00:05:26,440
So what are the interesting
program variables here?

91
00:05:26,440 --> 00:05:30,530
Well, there are only
two, ans and x.

92
00:05:30,530 --> 00:05:31,780
Right?

93
00:05:31,780 --> 00:05:33,385

94
00:05:33,385 --> 00:05:35,140
At least, that's
all I can see.

95
00:05:35,140 --> 00:05:39,270

96
00:05:39,270 --> 00:05:40,810
So what would be an interesting
function?

97
00:05:40,810 --> 00:05:45,900

98
00:05:45,900 --> 00:05:47,150
Somebody?

99
00:05:47,150 --> 00:05:48,950

100
00:05:48,950 --> 00:05:51,300
Surely, there's someone who
can figure this out.

101
00:05:51,300 --> 00:05:55,520

102
00:05:55,520 --> 00:05:57,040
Yes?

103
00:05:57,040 --> 00:05:58,583
Or no, you're just scratching
your head.

104
00:05:58,583 --> 00:06:00,270
You fooled me.

105
00:06:00,270 --> 00:06:02,630
I can't see because of the
light, but I'm sure there must

106
00:06:02,630 --> 00:06:05,241
be dozens of hands up if
I could only see them.

107
00:06:05,241 --> 00:06:07,890

108
00:06:07,890 --> 00:06:10,460
Actually, I don't see
any hands up.

109
00:06:10,460 --> 00:06:13,010

110
00:06:13,010 --> 00:06:14,375
This is not so hard, guys.

111
00:06:14,375 --> 00:06:19,430

112
00:06:19,430 --> 00:06:26,155
It's the absolute value of
x minus answer cubed.

113
00:06:26,155 --> 00:06:36,810

114
00:06:36,810 --> 00:06:39,850
So what does this
value start at?

115
00:06:39,850 --> 00:06:41,920
Let's pick a value.

116
00:06:41,920 --> 00:06:47,080
Suppose that x is equal to 8.

117
00:06:47,080 --> 00:06:52,240

118
00:06:52,240 --> 00:06:54,690
What is the initial value of
the decrementing function?

119
00:06:54,690 --> 00:06:57,250

120
00:06:57,250 --> 00:06:59,070
Wow.

121
00:06:59,070 --> 00:07:00,230
Come on.

122
00:07:00,230 --> 00:07:02,450
Let's be a little cooperative,
please.

123
00:07:02,450 --> 00:07:03,030
Yes?

124
00:07:03,030 --> 00:07:07,022
AUDIENCE: So it's 8, answer
is 0 and absolute

125
00:07:07,022 --> 00:07:07,521
value of x is 8.

126
00:07:07,521 --> 00:07:13,140
PROFESSOR: So it's 8 minus
0, which is equal to 8.

127
00:07:13,140 --> 00:07:17,805
So it satisfies conditions
one and conditions two.

128
00:07:17,805 --> 00:07:21,000

129
00:07:21,000 --> 00:07:23,695
What happens to this value every
time through the loop?

130
00:07:23,695 --> 00:07:29,400

131
00:07:29,400 --> 00:07:32,390
Does x change?

132
00:07:32,390 --> 00:07:35,060
Does answer change?

133
00:07:35,060 --> 00:07:38,220
And how does it change?

134
00:07:38,220 --> 00:07:40,490
It's increasing.

135
00:07:40,490 --> 00:07:41,870
What does answer start at?

136
00:07:41,870 --> 00:07:44,730
It starts at 0, and
it increases.

137
00:07:44,730 --> 00:07:48,700
So I know that answer cubed
will always be positive.

138
00:07:48,700 --> 00:07:49,870
Right?

139
00:07:49,870 --> 00:07:51,500
So I know that every
time through the

140
00:07:51,500 --> 00:07:54,840
loop, it will be 8.

141
00:07:54,840 --> 00:07:57,350
The first time through,
it'll be 8 minus 1

142
00:07:57,350 --> 00:07:58,600
cubed, which is 7.

143
00:07:58,600 --> 00:08:02,150

144
00:08:02,150 --> 00:08:06,030
And then the next time through,
it'll be 8 minus 2

145
00:08:06,030 --> 00:08:09,670
cubed, which is 0.

146
00:08:09,670 --> 00:08:10,920
And then, I exit the loop.

147
00:08:10,920 --> 00:08:14,500

148
00:08:14,500 --> 00:08:16,820
And it's that kind of reasoning
that I used to

149
00:08:16,820 --> 00:08:21,800
convince myself that this
loop terminates.

150
00:08:21,800 --> 00:08:24,590
And every time I write a loop,
and I hope every time you

151
00:08:24,590 --> 00:08:29,680
write a loop, you will think
about what's the reason the

152
00:08:29,680 --> 00:08:31,370
loop is going to terminate.

153
00:08:31,370 --> 00:08:34,470
And you will do it by thinking
about what the decrementing

154
00:08:34,470 --> 00:08:35,720
function is.

155
00:08:35,720 --> 00:08:37,929

156
00:08:37,929 --> 00:08:39,940
People get me on that?

157
00:08:39,940 --> 00:08:43,520
And whoever finally answered
a question surely

158
00:08:43,520 --> 00:08:44,770
deserves to be fed.

159
00:08:44,770 --> 00:08:49,060

160
00:08:49,060 --> 00:08:51,300
I obviously have to bring better
candy to encourage

161
00:08:51,300 --> 00:08:55,070
better responses.

162
00:08:55,070 --> 00:08:59,930
Now, let's go back and look
at the program itself.

163
00:08:59,930 --> 00:09:05,230
Now that we know it stops, and
you can take my word for it

164
00:09:05,230 --> 00:09:09,350
that it actually computes the
correct answer, let's think

165
00:09:09,350 --> 00:09:11,200
about what kind of algorithm
this is.

166
00:09:11,200 --> 00:09:13,240
What's the method?

167
00:09:13,240 --> 00:09:17,040
This is an example of
guess and check.

168
00:09:17,040 --> 00:09:20,190
And it's a particular kind
called exhaustive enumeration.

169
00:09:20,190 --> 00:09:37,680

170
00:09:37,680 --> 00:09:41,130
Each time through the loop, I'm
taking a guess at to what

171
00:09:41,130 --> 00:09:45,730
the value is, and I'm checking
whether it's true.

172
00:09:45,730 --> 00:09:48,330
But I'm enumerating
the guesses in a

173
00:09:48,330 --> 00:09:49,840
very systematic way.

174
00:09:49,840 --> 00:09:52,050
They're not just
random guesses.

175
00:09:52,050 --> 00:09:54,520
I'm enumerating all the
possible answers.

176
00:09:54,520 --> 00:09:58,670

177
00:09:58,670 --> 00:10:02,460
If I get through the entire
space of answers, or possible

178
00:10:02,460 --> 00:10:06,180
answers, and I don't find a
solution, then I know that it

179
00:10:06,180 --> 00:10:09,850
doesn't exist, and it's
not a perfect cube.

180
00:10:09,850 --> 00:10:13,180
So that's why it's called
exhaustive enumeration because

181
00:10:13,180 --> 00:10:15,740
I'm exhausting the space
of possible answers.

182
00:10:15,740 --> 00:10:20,880

183
00:10:20,880 --> 00:10:23,130
Does that makes sense
to everyone?

184
00:10:23,130 --> 00:10:25,350
So let's try it.

185
00:10:25,350 --> 00:10:31,810
Let's try it with say a very
large value of x, because

186
00:10:31,810 --> 00:10:34,150
that's always an issue, of
course, when we do exhaustive

187
00:10:34,150 --> 00:10:35,400
enumeration.

188
00:10:35,400 --> 00:10:38,210

189
00:10:38,210 --> 00:10:40,160
So I'm going to enter
this value.

190
00:10:40,160 --> 00:10:49,360

191
00:10:49,360 --> 00:10:51,350
Is that a perfect cube?

192
00:10:51,350 --> 00:10:52,600
Who thinks it is?

193
00:10:52,600 --> 00:10:54,750

194
00:10:54,750 --> 00:10:56,330
Who can tell me what it is?

195
00:10:56,330 --> 00:10:59,140
What's the cube root of that?

196
00:10:59,140 --> 00:11:02,270
Well, this is a question I did
not expect you to answer.

197
00:11:02,270 --> 00:11:07,930
But it's 1,251.

198
00:11:07,930 --> 00:11:10,550
That'll be in the first quiz,
so make a note of it.

199
00:11:10,550 --> 00:11:13,320

200
00:11:13,320 --> 00:11:16,160
Notice how quickly the
computer did this.

201
00:11:16,160 --> 00:11:17,920
It found the cube
root of quite a

202
00:11:17,920 --> 00:11:21,690
large number very quickly.

203
00:11:21,690 --> 00:11:24,380
And so while one might
initially think that

204
00:11:24,380 --> 00:11:29,890
exhaustive enumeration is a
silly technique because takes

205
00:11:29,890 --> 00:11:33,140
a lot of guesses, for an awful
lot of problems, we can

206
00:11:33,140 --> 00:11:38,230
actually just write a pretty
stupid program that's solves

207
00:11:38,230 --> 00:11:40,340
it by exhaustive enumeration.

208
00:11:40,340 --> 00:11:43,330
We typically refer to such
programs as brute force.

209
00:11:43,330 --> 00:11:45,980

210
00:11:45,980 --> 00:11:48,930
And brute force is often
exactly the right

211
00:11:48,930 --> 00:11:51,680
way to solve a problem.

212
00:11:51,680 --> 00:11:53,140
Why does it work?

213
00:11:53,140 --> 00:11:54,735
Because computers
are really fast.

214
00:11:54,735 --> 00:11:57,410

215
00:11:57,410 --> 00:11:59,550
How fast are computers?

216
00:11:59,550 --> 00:12:02,520
Well, today, a good computer
can execute in a single

217
00:12:02,520 --> 00:12:06,940
processor in the order of 100
million instructions a second.

218
00:12:06,940 --> 00:12:08,870
How fast is that?

219
00:12:08,870 --> 00:12:10,830
And now, we're going to see if
Mitchell has answered the

220
00:12:10,830 --> 00:12:13,620
question I asked in the
way in the class.

221
00:12:13,620 --> 00:12:17,710
How many instructions can a
computer execute between the

222
00:12:17,710 --> 00:12:20,240
time I say something and the
time the people in the back

223
00:12:20,240 --> 00:12:23,780
row hear it?

224
00:12:23,780 --> 00:12:27,950
Mitch thinks it's 400 million
instructions.

225
00:12:27,950 --> 00:12:29,370
I think that's about right.

226
00:12:29,370 --> 00:12:32,220
It's hundreds of millions
at any rate.

227
00:12:32,220 --> 00:12:34,750
It's kind of amazing between the
time I say something and

228
00:12:34,750 --> 00:12:39,370
the time you hear it, hundreds
of millions of instructions.

229
00:12:39,370 --> 00:12:42,900
It's mind boggling
how fast that is.

230
00:12:42,900 --> 00:12:48,030
And that's why we can often use
these kind of solutions.

231
00:12:48,030 --> 00:12:50,570
Next lecture, actually, even
a little bit later in this

232
00:12:50,570 --> 00:12:54,320
lecture, I hope to get to an
example of why that doesn't

233
00:12:54,320 --> 00:12:58,940
really get the job done,
at least not always.

234
00:12:58,940 --> 00:13:02,360
Before I do that, I want
to look at one

235
00:13:02,360 --> 00:13:04,910
more programming construct.

236
00:13:04,910 --> 00:13:09,070
And that's a variant
on the while loop.

237
00:13:09,070 --> 00:13:11,560
So if we think about what the
while loop we were just

238
00:13:11,560 --> 00:13:19,720
looking at did or does, as the
decrementing function told us,

239
00:13:19,720 --> 00:13:23,040
it's looking at all the possible
values of answer

240
00:13:23,040 --> 00:13:28,160
ranging from 0 to the
absolute value of x.

241
00:13:28,160 --> 00:13:32,110
And at each step testing and
doing something, we can

242
00:13:32,110 --> 00:13:36,575
abstract this process using
something called a for loop.

243
00:13:36,575 --> 00:13:54,200

244
00:13:54,200 --> 00:13:57,380
So let's look at this code.

245
00:13:57,380 --> 00:14:01,610
It's essentially exactly
the same algorithm.

246
00:14:01,610 --> 00:14:05,840
I got bored of typing ans
times ans times ans.

247
00:14:05,840 --> 00:14:10,990
So I used a Python notation
for exponentiation, which

248
00:14:10,990 --> 00:14:12,800
you'll see is star, star.

249
00:14:12,800 --> 00:14:16,590

250
00:14:16,590 --> 00:14:21,930
Now, be easier to read
if I get rid of that.

251
00:14:21,930 --> 00:14:24,760
But other than that, the
interesting thing I did was

252
00:14:24,760 --> 00:14:28,890
replace the while
loop by a for.

253
00:14:28,890 --> 00:14:34,170
So you'll see this line of code
there, for ans in range 0

254
00:14:34,170 --> 00:14:38,710
to abs of x plus 1.

255
00:14:38,710 --> 00:14:46,350
What that says is range is a
built-in function of Python

256
00:14:46,350 --> 00:14:52,130
that generates, in this case,
a sequence of integers,

257
00:14:52,130 --> 00:14:55,670
something called a tuple, which
we'll be looking at in a

258
00:14:55,670 --> 00:14:57,360
lecture or so.

259
00:14:57,360 --> 00:15:01,130
But for now, it's pretty simple
to think about what you

260
00:15:01,130 --> 00:15:12,230
get is if you look at the
expression range of x to y,

261
00:15:12,230 --> 00:15:19,605
that gives me a sequence
of values, x, x plus 1

262
00:15:19,605 --> 00:15:24,550
up to y minus 1.

263
00:15:24,550 --> 00:15:28,330
Notice not up to y, but
up to y minus 1.

264
00:15:28,330 --> 00:15:30,900
So it gives me a sequence
of length y--

265
00:15:30,900 --> 00:15:34,080

266
00:15:34,080 --> 00:15:37,970
well, assuming that's 0.

267
00:15:37,970 --> 00:15:38,900
Right?

268
00:15:38,900 --> 00:15:40,880
It doesn't have to be 0.

269
00:15:40,880 --> 00:15:41,475
It can be anything.

270
00:15:41,475 --> 00:15:46,210
It can be another
value as well.

271
00:15:46,210 --> 00:15:48,950
0 in my example.

272
00:15:48,950 --> 00:15:54,450
And then, the for loop executes
it on this value and

273
00:15:54,450 --> 00:15:57,910
the next iteration on this
value, and finally, at the

274
00:15:57,910 --> 00:16:01,400
very end on that value.

275
00:16:01,400 --> 00:16:06,280
So it executes it one iteration
of the loop on each

276
00:16:06,280 --> 00:16:10,290
value in this sequence
of values generated

277
00:16:10,290 --> 00:16:11,540
by the range statement.

278
00:16:11,540 --> 00:16:14,100

279
00:16:14,100 --> 00:16:16,460
And normally, it does
all of them.

280
00:16:16,460 --> 00:16:22,290
However, you'll see I've added
something called a break here,

281
00:16:22,290 --> 00:16:24,460
a command in Python.

282
00:16:24,460 --> 00:16:27,905
And what break says
is exit the loop.

283
00:16:27,905 --> 00:16:30,720

284
00:16:30,720 --> 00:16:35,670
So it exits it prematurely
without executing all of the

285
00:16:35,670 --> 00:16:37,265
values generated by range.

286
00:16:37,265 --> 00:16:42,670

287
00:16:42,670 --> 00:16:46,310
You can nest loops just like
you nest if statements.

288
00:16:46,310 --> 00:16:49,880
And if you do that break,
always executes--

289
00:16:49,880 --> 00:16:52,370
always exits rather the
innermost loop.

290
00:16:52,370 --> 00:16:54,940

291
00:16:54,940 --> 00:16:57,700
So what this does is it's
generates a set

292
00:16:57,700 --> 00:17:00,390
of values to test.

293
00:17:00,390 --> 00:17:03,800
It checks whether or not
it's got the answer.

294
00:17:03,800 --> 00:17:06,290
If it does, it terminates
the loop.

295
00:17:06,290 --> 00:17:09,780

296
00:17:09,780 --> 00:17:12,020
And eventually, you
exit the loop.

297
00:17:12,020 --> 00:17:14,869
And then, it just checks as
before whether or not it found

298
00:17:14,869 --> 00:17:19,589
a correct answer and does
the right thing.

299
00:17:19,589 --> 00:17:23,460
So you'll find, particularly
when you're iterating over

300
00:17:23,460 --> 00:17:26,470
integers, but later we'll see
when you're iterating over a

301
00:17:26,470 --> 00:17:31,410
lot of other kinds of things,
for loops are a very

302
00:17:31,410 --> 00:17:34,350
convenient shorthand.

303
00:17:34,350 --> 00:17:36,540
There's nothing you can't
do with a while loop.

304
00:17:36,540 --> 00:17:38,640
You don't need for loops.

305
00:17:38,640 --> 00:17:40,530
But they do make life easy.

306
00:17:40,530 --> 00:17:44,470
And over the semester, I think
you'll end up writing a lot

307
00:17:44,470 --> 00:17:47,650
more for loops than you
will while loops.

308
00:17:47,650 --> 00:17:50,950

309
00:17:50,950 --> 00:17:52,380
Any questions about this?

310
00:17:52,380 --> 00:17:55,560

311
00:17:55,560 --> 00:17:57,620
If not, I'm going to
move right along.

312
00:17:57,620 --> 00:18:01,280
So this is the moment.

313
00:18:01,280 --> 00:18:03,570
I'm going to move right along.

314
00:18:03,570 --> 00:18:06,840
So we've now got a program that
does something really

315
00:18:06,840 --> 00:18:08,770
silly, really.

316
00:18:08,770 --> 00:18:15,160
It finds cube roots
of perfect cubes.

317
00:18:15,160 --> 00:18:17,220
Well, that's not typically
useful.

318
00:18:17,220 --> 00:18:17,680
Right?

319
00:18:17,680 --> 00:18:21,960
You've even got these $0.50 four
function calculators that

320
00:18:21,960 --> 00:18:23,910
find square roots.

321
00:18:23,910 --> 00:18:28,570
And they don't insist that you
only give it perfect squares.

322
00:18:28,570 --> 00:18:31,130
So now, let's think about how
we would take this kind of

323
00:18:31,130 --> 00:18:36,440
program, and indeed, this kind
of method of writing programs

324
00:18:36,440 --> 00:18:38,570
and use it to find--

325
00:18:38,570 --> 00:18:43,610
for now, we'll look at the
square root of any number, of

326
00:18:43,610 --> 00:18:45,050
any floating point number.

327
00:18:45,050 --> 00:18:48,820

328
00:18:48,820 --> 00:18:52,450
Well, the first question we need
to ask is what do I mean?

329
00:18:52,450 --> 00:18:55,050

330
00:18:55,050 --> 00:18:56,930
That's kind of a subtle
question.

331
00:18:56,930 --> 00:18:58,945
What does it mean to find the
square root of a number?

332
00:18:58,945 --> 00:19:01,480

333
00:19:01,480 --> 00:19:03,180
What does it mean, for
example, to find the

334
00:19:03,180 --> 00:19:04,430
square root of 2?

335
00:19:04,430 --> 00:19:07,130

336
00:19:07,130 --> 00:19:14,340
Well, we know that that was an
endless series of digits

337
00:19:14,340 --> 00:19:16,190
before we can find the
square root of 2.

338
00:19:16,190 --> 00:19:16,550
Right?

339
00:19:16,550 --> 00:19:19,740
It does not have
a nice answer.

340
00:19:19,740 --> 00:19:23,030
So we can't just say we have to
find something that if we

341
00:19:23,030 --> 00:19:26,370
multiply it by itself,
it will equal 2.

342
00:19:26,370 --> 00:19:28,030
Because we can't find
such a thing.

343
00:19:28,030 --> 00:19:30,800

344
00:19:30,800 --> 00:19:33,170
So we've got to think
about a different

345
00:19:33,170 --> 00:19:35,590
notion of what we mean.

346
00:19:35,590 --> 00:19:37,890
Furthermore, even for some
numbers which there is a

347
00:19:37,890 --> 00:19:42,860
square root, it might be a
million decimal places long,

348
00:19:42,860 --> 00:19:47,260
and consequently, really
hard to find.

349
00:19:47,260 --> 00:19:50,270
So we need to think
about a different

350
00:19:50,270 --> 00:19:53,920
kind of concept here.

351
00:19:53,920 --> 00:20:11,070
And it's the concept of an
approximation, finding an

352
00:20:11,070 --> 00:20:14,570
answer that is good enough.

353
00:20:14,570 --> 00:20:17,560
So what should we do here?

354
00:20:17,560 --> 00:20:19,770
How do we think about this?

355
00:20:19,770 --> 00:20:25,690
Typically, what we do when we
think about an approximation

356
00:20:25,690 --> 00:20:30,110
is we define how good
an approximation

357
00:20:30,110 --> 00:20:31,360
we're willing to accept.

358
00:20:31,360 --> 00:20:35,590

359
00:20:35,590 --> 00:20:40,960
So for example, we might want
to say, I want to find a

360
00:20:40,960 --> 00:20:44,750
square root that lies
within epsilon of

361
00:20:44,750 --> 00:20:48,120
the true square root.

362
00:20:48,120 --> 00:21:11,410
So find a y such that y times
y is equal to what?

363
00:21:11,410 --> 00:21:12,180
What does it mean?

364
00:21:12,180 --> 00:21:15,605
How would I express it within
epsilon of the perfect answer?

365
00:21:15,605 --> 00:21:18,240

366
00:21:18,240 --> 00:21:21,860
I don't want to say it's equal
to x, because that may be

367
00:21:21,860 --> 00:21:26,820
impossible or too time
consuming to find.

368
00:21:26,820 --> 00:21:30,890
So really, what I mean is
x plus or minus epsilon.

369
00:21:30,890 --> 00:21:37,200

370
00:21:37,200 --> 00:21:38,350
So that's what I'm asking.

371
00:21:38,350 --> 00:21:39,930
Find one that's close enough.

372
00:21:39,930 --> 00:21:43,290

373
00:21:43,290 --> 00:21:45,190
And that's what the next
piece of code I

374
00:21:45,190 --> 00:21:46,440
want to show you does.

375
00:21:46,440 --> 00:22:12,620

376
00:22:12,620 --> 00:22:15,490
Excuse me.

377
00:22:15,490 --> 00:22:19,510
So I'm starting, just giving it
a value for x, so I don't

378
00:22:19,510 --> 00:22:20,680
have to keep typing one in.

379
00:22:20,680 --> 00:22:21,930
Let's say it's 25.

380
00:22:21,930 --> 00:22:24,290

381
00:22:24,290 --> 00:22:28,630
I'm going to take epsilon
to be 0.01.

382
00:22:28,630 --> 00:22:31,585
So I want it within that
distance of the true answer.

383
00:22:31,585 --> 00:22:34,330

384
00:22:34,330 --> 00:22:37,810
I'm going to keep track of the
number of guesses here, not

385
00:22:37,810 --> 00:22:40,540
because we need it to actually
compute the answer, but

386
00:22:40,540 --> 00:22:43,600
because I want to then discuss
how many iterations of the

387
00:22:43,600 --> 00:22:46,080
loop we're doing.

388
00:22:46,080 --> 00:22:51,270
We're going to start by setting
my first guess at 0.0.

389
00:22:51,270 --> 00:22:55,570
Again, this is going to be
exhaustive enumeration.

390
00:22:55,570 --> 00:23:00,250
Then, I'm going to essentially
encode this as a test of my

391
00:23:00,250 --> 00:23:05,280
while loop while the absolute
value of answer squared minus

392
00:23:05,280 --> 00:23:11,630
x is greater than or equal to
epsilon, and answer is less

393
00:23:11,630 --> 00:23:13,200
than equal to x.

394
00:23:13,200 --> 00:23:15,360
So it's now a more
complicated test.

395
00:23:15,360 --> 00:23:17,180
I've got a Boolean value.

396
00:23:17,180 --> 00:23:22,180
Two things have to be true to
execute the body of the loop.

397
00:23:22,180 --> 00:23:28,430
I'm going to increment answer
by a tiny amount, increment

398
00:23:28,430 --> 00:23:31,140
the number of guesses just so
I can keep track of it.

399
00:23:31,140 --> 00:23:34,610

400
00:23:34,610 --> 00:23:36,710
Maybe I'm going to comment
this out for the first go

401
00:23:36,710 --> 00:23:41,850
around just so we don't see too
many print statements and

402
00:23:41,850 --> 00:23:43,100
keep doing it.

403
00:23:43,100 --> 00:23:46,510

404
00:23:46,510 --> 00:23:48,370
And then when I'm done I'm going
to see whether or not

405
00:23:48,370 --> 00:23:54,630
what I found is indeed a square
root or close enough.

406
00:23:54,630 --> 00:23:58,470
So if we think about why this
loop terminates, why am I

407
00:23:58,470 --> 00:24:01,600
guaranteed that this loop
will terminate?

408
00:24:01,600 --> 00:24:03,660
What's my decrementing
function here?

409
00:24:03,660 --> 00:24:08,440

410
00:24:08,440 --> 00:24:09,690
Somebody?

411
00:24:09,690 --> 00:24:11,280

412
00:24:11,280 --> 00:24:13,380
What's the decrementing
function?

413
00:24:13,380 --> 00:24:17,180
What am I guaranteed to reduce
each time through, and when I

414
00:24:17,180 --> 00:24:18,430
get through, I'm done?

415
00:24:18,430 --> 00:24:22,960

416
00:24:22,960 --> 00:24:24,250
Yeah?

417
00:24:24,250 --> 00:24:26,600
AUDIENCE: [INAUDIBLE]

418
00:24:26,600 --> 00:24:31,458
answer squared minus
x1 times 1.

419
00:24:31,458 --> 00:24:32,660
PROFESSOR: No.

420
00:24:32,660 --> 00:24:34,930
Close, sort of.

421
00:24:34,930 --> 00:24:37,640
But I appreciate
you're trying.

422
00:24:37,640 --> 00:24:40,840
That's worth something
just for the effort.

423
00:24:40,840 --> 00:24:43,450
Somebody else.

424
00:24:43,450 --> 00:24:48,040
Remember, if we look at the
properties it has to have,

425
00:24:48,040 --> 00:24:50,940
it's going to guarantee me that
when it gets to the right

426
00:24:50,940 --> 00:24:54,360
value, I exit the loop, which
suggests it's going to

427
00:24:54,360 --> 00:24:56,420
certainly be part of the
test of the while.

428
00:24:56,420 --> 00:25:00,560

429
00:25:00,560 --> 00:25:02,790
Just look at this piece
over here at the end.

430
00:25:02,790 --> 00:25:06,770

431
00:25:06,770 --> 00:25:09,450
Answer starts at 0.

432
00:25:09,450 --> 00:25:12,940
I keep incrementing it.

433
00:25:12,940 --> 00:25:20,910
Eventually, answer minus x
will hit a value, right?

434
00:25:20,910 --> 00:25:23,390
Eventually, I'll get to
the point that this

435
00:25:23,390 --> 00:25:25,920
condition must be true--

436
00:25:25,920 --> 00:25:27,150
must be false rather.

437
00:25:27,150 --> 00:25:28,400
And then, I exit the loop.

438
00:25:28,400 --> 00:25:31,590

439
00:25:31,590 --> 00:25:35,650
So this piece is not
really the key.

440
00:25:35,650 --> 00:25:37,940
It's this piece that guarantees
me I'm going to get

441
00:25:37,940 --> 00:25:39,190
out eventually.

442
00:25:39,190 --> 00:25:41,650

443
00:25:41,650 --> 00:25:44,090
This piece can get
me out sooner.

444
00:25:44,090 --> 00:25:45,870
It's kind of an optimization,
if you will.

445
00:25:45,870 --> 00:25:49,980

446
00:25:49,980 --> 00:25:52,780
So I'm just going to go until
I find the answer.

447
00:25:52,780 --> 00:25:54,320
Let's see what happens
when I run it.

448
00:25:54,320 --> 00:26:00,860

449
00:26:00,860 --> 00:26:06,190
It tells me that 4.99, et cetera
is close to the square

450
00:26:06,190 --> 00:26:09,350
root of 25.

451
00:26:09,350 --> 00:26:13,210
So there are some things
to note about this.

452
00:26:13,210 --> 00:26:19,000
First, it didn't find 5, 25
happens to be a perfect

453
00:26:19,000 --> 00:26:21,790
square, yet I didn't find it.

454
00:26:21,790 --> 00:26:24,210
Is that OK?

455
00:26:24,210 --> 00:26:25,050
Yeah.

456
00:26:25,050 --> 00:26:27,220
Because that wasn't
what I said.

457
00:26:27,220 --> 00:26:30,050
What I said is find
a y that has these

458
00:26:30,050 --> 00:26:32,860
properties over here.

459
00:26:32,860 --> 00:26:34,740
And I did.

460
00:26:34,740 --> 00:26:37,160
I didn't say find the y that
gets closest to the

461
00:26:37,160 --> 00:26:38,850
square root of x.

462
00:26:38,850 --> 00:26:43,340
I said find one that has
these properties.

463
00:26:43,340 --> 00:26:51,030
Effectively, what this is is a
specification of the problem.

464
00:26:51,030 --> 00:26:56,410

465
00:26:56,410 --> 00:26:59,150
And I've now written a piece
of code that meets the

466
00:26:59,150 --> 00:27:00,730
specification.

467
00:27:00,730 --> 00:27:03,980
It does what I set out to do,
and that's good enough.

468
00:27:03,980 --> 00:27:09,060

469
00:27:09,060 --> 00:27:15,410
Now, let's turn this print
statement back on.

470
00:27:15,410 --> 00:27:20,370

471
00:27:20,370 --> 00:27:24,040
It took almost 1/2 million
guesses to get there.

472
00:27:24,040 --> 00:27:28,200

473
00:27:28,200 --> 00:27:31,280
But it was still blindingly
fast.

474
00:27:31,280 --> 00:27:36,070
So once again, exhaustive
enumeration seems to be OK.

475
00:27:36,070 --> 00:27:42,770
Suppose, however, I choose
a bigger number.

476
00:27:42,770 --> 00:27:49,296
Now, first, let's choose
something that doesn't have a

477
00:27:49,296 --> 00:27:50,450
good answer.

478
00:27:50,450 --> 00:27:51,700
Let's see what it
does for that.

479
00:27:51,700 --> 00:27:54,140

480
00:27:54,140 --> 00:27:55,110
All right.

481
00:27:55,110 --> 00:27:56,650
Pretty good.

482
00:27:56,650 --> 00:27:58,640
Also pretty fast.

483
00:27:58,640 --> 00:28:00,540
Not too many guesses.

484
00:28:00,540 --> 00:28:02,440
But now, let's try this one.

485
00:28:02,440 --> 00:28:12,670

486
00:28:12,670 --> 00:28:14,230
Well, it's going to wait.

487
00:28:14,230 --> 00:28:16,110
It's going to get done, but it's
going to take a little

488
00:28:16,110 --> 00:28:21,060
bit longer than maybe
we want it to take.

489
00:28:21,060 --> 00:28:22,940
Why is it taking so long?

490
00:28:22,940 --> 00:28:23,490
There it is.

491
00:28:23,490 --> 00:28:28,320
It found an answer, which
I think is good.

492
00:28:28,320 --> 00:28:30,010
But as you can see, it
took quite a few

493
00:28:30,010 --> 00:28:33,770
guesses to get there.

494
00:28:33,770 --> 00:28:35,430
So why?

495
00:28:35,430 --> 00:28:38,010
Well, let me first ask
this question.

496
00:28:38,010 --> 00:28:45,710
Can we look at the code and
anticipate how many guesses

497
00:28:45,710 --> 00:28:49,350
it's going to have to take?

498
00:28:49,350 --> 00:28:52,650
We're going back to this issue
of computational complexity,

499
00:28:52,650 --> 00:28:56,390
but here, not of the problem
but of the solution.

500
00:28:56,390 --> 00:28:59,160
So this is algorithmic
analysis.

501
00:28:59,160 --> 00:29:03,440
We're analyzing the algorithm,
this exhaustive enumeration

502
00:29:03,440 --> 00:29:07,430
algorithm, and trying to figure
out how long it's

503
00:29:07,430 --> 00:29:10,420
likely to take to run.

504
00:29:10,420 --> 00:29:11,890
Well, what does the running
time of this

505
00:29:11,890 --> 00:29:13,220
algorithm depend upon?

506
00:29:13,220 --> 00:29:16,740

507
00:29:16,740 --> 00:29:18,236
Yeah?

508
00:29:18,236 --> 00:29:19,550
AUDIENCE: [INAUDIBLE].

509
00:29:19,550 --> 00:29:24,180
PROFESSOR: It depends on
the actual square root.

510
00:29:24,180 --> 00:29:24,740
Yes.

511
00:29:24,740 --> 00:29:28,070
But in particular, the distance
of the actual square

512
00:29:28,070 --> 00:29:30,970
root from the starting point.

513
00:29:30,970 --> 00:29:33,760
So that's one factor
it depends on.

514
00:29:33,760 --> 00:29:35,520
But that's not the
only factor.

515
00:29:35,520 --> 00:29:36,790
What else does it depend on?

516
00:29:36,790 --> 00:29:40,630

517
00:29:40,630 --> 00:29:45,290
Oh, do we have an injury?

518
00:29:45,290 --> 00:29:48,420
We had a dropped pass and
a deflection there.

519
00:29:48,420 --> 00:29:50,300
All right.

520
00:29:50,300 --> 00:29:51,680
Yes?

521
00:29:51,680 --> 00:29:54,855
AUDIENCE: It depends on the
level of accuracy, so how you

522
00:29:54,855 --> 00:29:55,560
define epsilon.

523
00:29:55,560 --> 00:29:58,790
PROFESSOR: It depends upon
the value of epsilon.

524
00:29:58,790 --> 00:30:00,040
Absolutely.

525
00:30:00,040 --> 00:30:01,670

526
00:30:01,670 --> 00:30:03,190
How long it takes to run.

527
00:30:03,190 --> 00:30:04,440
AUDIENCE: [INAUDIBLE].

528
00:30:04,440 --> 00:30:08,514

529
00:30:08,514 --> 00:30:10,665
PROFESSOR: Someone with
a concern for safety.

530
00:30:10,665 --> 00:30:13,680

531
00:30:13,680 --> 00:30:17,040
it depends upon the actual value
of epsilon, because if

532
00:30:17,040 --> 00:30:22,510
epsilon is small, we may have
to take more steps to get a

533
00:30:22,510 --> 00:30:24,330
precise enough answer.

534
00:30:24,330 --> 00:30:27,970
And it depends upon
one more thing.

535
00:30:27,970 --> 00:30:28,410
Yeah?

536
00:30:28,410 --> 00:30:30,910
AUDIENCE: [INAUDIBLE] the
increment that [INAUDIBLE]?

537
00:30:30,910 --> 00:30:32,120
PROFESSOR: The increment.

538
00:30:32,120 --> 00:30:33,150
Exactly.

539
00:30:33,150 --> 00:30:36,740
Because the number of times we
go through the loop is going

540
00:30:36,740 --> 00:30:39,660
to be related to how
big a step we

541
00:30:39,660 --> 00:30:40,970
take each time through.

542
00:30:40,970 --> 00:30:45,900

543
00:30:45,900 --> 00:30:47,470
No applause?

544
00:30:47,470 --> 00:30:50,670
Thank you.

545
00:30:50,670 --> 00:30:54,080
So it depends upon all
of these things.

546
00:30:54,080 --> 00:30:59,170
And here, since we're trying
to find a pretty [? big ?]

547
00:30:59,170 --> 00:31:05,130
square root and a sort of
precise answer, but we're

548
00:31:05,130 --> 00:31:07,540
taking tiny steps, it's
going to take a

549
00:31:07,540 --> 00:31:09,950
long time to execute.

550
00:31:09,950 --> 00:31:12,220
So we could make it faster.

551
00:31:12,220 --> 00:31:20,240
For example, suppose I change
the step size to this.

552
00:31:20,240 --> 00:31:24,850

553
00:31:24,850 --> 00:31:28,580
Plus equal by says increment
the value by whatever the

554
00:31:28,580 --> 00:31:29,920
right side is.

555
00:31:29,920 --> 00:31:31,690
So I'm going to increment
it by 1.

556
00:31:31,690 --> 00:31:44,430

557
00:31:44,430 --> 00:31:46,770
Wow, it was really fast.

558
00:31:46,770 --> 00:31:47,700
But it didn't work.

559
00:31:47,700 --> 00:31:51,430
It failed.

560
00:31:51,430 --> 00:31:54,840
That's not so good.

561
00:31:54,840 --> 00:31:56,410
So I can't just do that.

562
00:31:56,410 --> 00:31:58,820
And of course, it's not
surprising, because I ended up

563
00:31:58,820 --> 00:32:02,670
jumping all over the answer.

564
00:32:02,670 --> 00:32:08,730
I could make epsilon smaller,
but that seems like cheating.

565
00:32:08,730 --> 00:32:15,030
So really, what I need to do is
find a better algorithm, a

566
00:32:15,030 --> 00:32:17,040
better way to attack
the problem.

567
00:32:17,040 --> 00:32:19,680

568
00:32:19,680 --> 00:32:22,420
Fortunately, I don't
have to invent it.

569
00:32:22,420 --> 00:32:26,880
Some people a lot smarter than
I am figured out a long time

570
00:32:26,880 --> 00:32:32,340
ago a good method for solving
this kind of problem.

571
00:32:32,340 --> 00:32:35,360
And they're doing it
using something

572
00:32:35,360 --> 00:32:36,940
called bisection search.

573
00:32:36,940 --> 00:32:49,370

574
00:32:49,370 --> 00:32:53,040
As we look at this particular
implementation of it, we're

575
00:32:53,040 --> 00:32:58,060
going to use two algorithmic
techniques that you'll use

576
00:32:58,060 --> 00:33:01,930
over and over again because
they're generally useful.

577
00:33:01,930 --> 00:33:07,810
So the first one related to
bisection search is we'll cut

578
00:33:07,810 --> 00:33:18,415
the search space in half
each iteration.

579
00:33:18,415 --> 00:33:23,720

580
00:33:23,720 --> 00:33:27,320
So with my brute force
algorithm, we're trimming the

581
00:33:27,320 --> 00:33:31,610
search base only a little
bit each step.

582
00:33:31,610 --> 00:33:38,040
So if we think about it, what it
looks like, we had a space

583
00:33:38,040 --> 00:33:40,000
of values to search
for the answer.

584
00:33:40,000 --> 00:33:42,830

585
00:33:42,830 --> 00:33:45,780
And I started here.

586
00:33:45,780 --> 00:33:49,750
And each step, I just trimmed
off a tiny, tiny little bit,

587
00:33:49,750 --> 00:33:55,280
0.001, leaving me a lot
of space to search.

588
00:33:55,280 --> 00:33:57,640
And that's why it
took so long.

589
00:33:57,640 --> 00:34:05,170
When I do bisection search, the
basic idea is each step I

590
00:34:05,170 --> 00:34:09,170
want to cut the search
space in half.

591
00:34:09,170 --> 00:34:13,600
Get rid of half of the search
space each time.

592
00:34:13,600 --> 00:34:18,540
So one way I could do
it is I start with a

593
00:34:18,540 --> 00:34:22,870
guess say in the middle.

594
00:34:22,870 --> 00:34:28,060
Just pick some guess that's in
the middle of my search space.

595
00:34:28,060 --> 00:34:31,270
And now I say is it too
high or too low?

596
00:34:31,270 --> 00:34:34,000

597
00:34:34,000 --> 00:34:35,850
I can easily answer
that question.

598
00:34:35,850 --> 00:34:37,560
I square it.

599
00:34:37,560 --> 00:34:40,420
See is my result bigger than
the actual square root or

600
00:34:40,420 --> 00:34:43,199
smaller than the actual
square root?

601
00:34:43,199 --> 00:34:47,370
That tells me whether my guess
is too big or too small.

602
00:34:47,370 --> 00:34:51,989
Once I know that, I know which
side of the guess the right

603
00:34:51,989 --> 00:34:53,239
answer is on.

604
00:34:53,239 --> 00:34:55,800

605
00:34:55,800 --> 00:35:00,970
So if I knew that my guess was
too big, then I know there's

606
00:35:00,970 --> 00:35:04,410
no point in looking over
here for my next guess.

607
00:35:04,410 --> 00:35:07,560
So I can get rid of this
whole half in one step.

608
00:35:07,560 --> 00:35:12,160

609
00:35:12,160 --> 00:35:13,690
Now, what should my
next guess be?

610
00:35:13,690 --> 00:35:16,850

611
00:35:16,850 --> 00:35:17,320
Yeah?

612
00:35:17,320 --> 00:35:19,248
AUDIENCE: [INAUDIBLE].

613
00:35:19,248 --> 00:35:20,680
PROFESSOR: My next
guess should be

614
00:35:20,680 --> 00:35:23,960
half way through there.

615
00:35:23,960 --> 00:35:25,210
Exactly.

616
00:35:25,210 --> 00:35:30,230

617
00:35:30,230 --> 00:35:37,530
And now, let's say this time
my answer is too small.

618
00:35:37,530 --> 00:35:39,080
Then I know I can
get rid of this.

619
00:35:39,080 --> 00:35:42,820

620
00:35:42,820 --> 00:35:46,175
So now, I'm very quickly pruning
my search space.

621
00:35:46,175 --> 00:35:52,550

622
00:35:52,550 --> 00:35:57,150
If I think about that, how many
times am I likely to have

623
00:35:57,150 --> 00:35:58,400
to prune it?

624
00:35:58,400 --> 00:36:05,300

625
00:36:05,300 --> 00:36:08,480
It's much faster, right?

626
00:36:08,480 --> 00:36:14,680
As we'll see later, it's
basically log base 2.

627
00:36:14,680 --> 00:36:19,880
If I have some number of
values to look at--

628
00:36:19,880 --> 00:36:22,770
and by the way, how many values
do I have in my search

629
00:36:22,770 --> 00:36:26,130
space to start with?

630
00:36:26,130 --> 00:36:27,520
What determines it?

631
00:36:27,520 --> 00:36:36,250
Clearly, the first value and the
last value, but also, how

632
00:36:36,250 --> 00:36:38,425
small I'm dividing it up.

633
00:36:38,425 --> 00:36:42,200

634
00:36:42,200 --> 00:36:43,080
Right?

635
00:36:43,080 --> 00:36:45,350
So I have to think
about that too.

636
00:36:45,350 --> 00:36:50,060
What is the precision with
which I do this.

637
00:36:50,060 --> 00:36:52,650
Am I looking at every
one millionth of a

638
00:36:52,650 --> 00:36:55,580
number or every 0.01?

639
00:36:55,580 --> 00:36:57,940
That will tell me
how big it is.

640
00:36:57,940 --> 00:37:05,740
Once I know how big my search
space is, I know that if I

641
00:37:05,740 --> 00:37:09,780
search it linearly looking at
every value, my worst cases, I

642
00:37:09,780 --> 00:37:11,860
look at everything until
I get to the end.

643
00:37:11,860 --> 00:37:15,330

644
00:37:15,330 --> 00:37:17,370
Well, my best case is
I get lucky, and my

645
00:37:17,370 --> 00:37:19,230
first guess is right.

646
00:37:19,230 --> 00:37:23,700
But if I use bisection search,
my worst case is going to be

647
00:37:23,700 --> 00:37:27,360
log number of values
in that space.

648
00:37:27,360 --> 00:37:32,010
Because each time, I throw
half of them away.

649
00:37:32,010 --> 00:37:35,700
We'll see that in more
detail later on.

650
00:37:35,700 --> 00:37:37,800
Let's go back and look
at the code now.

651
00:37:37,800 --> 00:37:57,980

652
00:37:57,980 --> 00:38:01,640
So it starts as before with
a value for epsilon.

653
00:38:01,640 --> 00:38:06,970
But now, I'm going to take a
lower bound, here, and an

654
00:38:06,970 --> 00:38:08,705
upper bound on my
search space.

655
00:38:08,705 --> 00:38:12,430

656
00:38:12,430 --> 00:38:15,840
I'm going to say my initial
guess will be the upper bound

657
00:38:15,840 --> 00:38:19,100
plus the lower bound
over 2 halfway

658
00:38:19,100 --> 00:38:20,350
through my search space.

659
00:38:20,350 --> 00:38:25,510

660
00:38:25,510 --> 00:38:30,390
And then, I'm just going to work
my way through it until I

661
00:38:30,390 --> 00:38:33,780
get to the answer or
don't find it.

662
00:38:33,780 --> 00:38:37,380

663
00:38:37,380 --> 00:38:40,050
So should we look at what's
going on here?

664
00:38:40,050 --> 00:38:41,300
Let's try this.

665
00:38:41,300 --> 00:38:43,420

666
00:38:43,420 --> 00:38:54,270
Well, let's first make sure it
works for a small value.

667
00:38:54,270 --> 00:38:57,580
Never test your program first
on something big.

668
00:38:57,580 --> 00:39:00,040
Always try your program in
something small first.

669
00:39:00,040 --> 00:39:02,950

670
00:39:02,950 --> 00:39:04,200
Let's try it on that.

671
00:39:04,200 --> 00:39:08,100

672
00:39:08,100 --> 00:39:09,350
Got an answer.

673
00:39:09,350 --> 00:39:11,720

674
00:39:11,720 --> 00:39:14,930
Notice that it's different from
the answer we got last

675
00:39:14,930 --> 00:39:16,535
time we looked for the
square root of 25.

676
00:39:16,535 --> 00:39:19,220

677
00:39:19,220 --> 00:39:24,830
But that's OK, because it's
still meets the specification.

678
00:39:24,830 --> 00:39:28,420
It's still within epsilon of
the actual square root.

679
00:39:28,420 --> 00:39:31,970
And I didn't have to say that
I wanted it below or the

680
00:39:31,970 --> 00:39:35,390
square root or above, just
said within epsilon.

681
00:39:35,390 --> 00:39:38,960
Sure enough, different
algorithm, different answer,

682
00:39:38,960 --> 00:39:44,990
but equally good, but
a lot faster.

683
00:39:44,990 --> 00:39:47,395
Now let's try it for
the big value.

684
00:39:47,395 --> 00:40:04,130

685
00:40:04,130 --> 00:40:06,264
Wow, that was a lot
faster, wasn't it?

686
00:40:06,264 --> 00:40:11,370

687
00:40:11,370 --> 00:40:14,350
It got me an answer.

688
00:40:14,350 --> 00:40:16,340
Probably, not exactly
the same answer as

689
00:40:16,340 --> 00:40:19,310
before but pretty close.

690
00:40:19,310 --> 00:40:23,530
But it did it in only
26 guesses.

691
00:40:23,530 --> 00:40:25,610
Pretty cool.

692
00:40:25,610 --> 00:40:30,410
And in fact, we'll see over and
over again that bisection

693
00:40:30,410 --> 00:40:34,250
search is a really good
technique for

694
00:40:34,250 --> 00:40:35,980
finding quick answers.

695
00:40:35,980 --> 00:40:40,900

696
00:40:40,900 --> 00:40:43,850
And again, why is it 26?

697
00:40:43,850 --> 00:40:48,350
Well, we had some number of
guesses to start with.

698
00:40:48,350 --> 00:40:52,850
After 1, it was half as big,
then a quarter is big, and

699
00:40:52,850 --> 00:40:56,430
eventually, log 2 of the size.

700
00:40:56,430 --> 00:40:59,270
But what was the size?

701
00:40:59,270 --> 00:41:05,780
Was it the number 12345?

702
00:41:05,780 --> 00:41:06,380
No.

703
00:41:06,380 --> 00:41:10,270
We already sort of talked
about that.

704
00:41:10,270 --> 00:41:11,860
What was it?

705
00:41:11,860 --> 00:41:16,760
Let's look at the code, and
let's think about what was the

706
00:41:16,760 --> 00:41:18,465
size of our initial
search space.

707
00:41:18,465 --> 00:41:22,320

708
00:41:22,320 --> 00:41:24,680
It's a little bit tricky to
think about this, right?

709
00:41:24,680 --> 00:41:31,350

710
00:41:31,350 --> 00:41:35,830
Now, we have to think a little
bit harder about when we exit

711
00:41:35,830 --> 00:41:38,940
the loop, because in
fundamentally, that's telling

712
00:41:38,940 --> 00:41:40,345
me the size of the
search space.

713
00:41:40,345 --> 00:41:42,890

714
00:41:42,890 --> 00:41:45,410
So what determined the size
of the search space?

715
00:41:45,410 --> 00:41:54,386

716
00:41:54,386 --> 00:41:57,810
Well, we talked about the upper
and the lower bound.

717
00:41:57,810 --> 00:42:00,950
But what's telling me
roughly speaking how

718
00:42:00,950 --> 00:42:05,450
many divisions I have?

719
00:42:05,450 --> 00:42:06,700
It's epsilon.

720
00:42:06,700 --> 00:42:08,700

721
00:42:08,700 --> 00:42:13,760
It's not 0.01 because when
I square it, it has to be

722
00:42:13,760 --> 00:42:16,110
smaller than 0.01.

723
00:42:16,110 --> 00:42:18,590
But that tells me roughly
how many I have.

724
00:42:18,590 --> 00:42:21,740

725
00:42:21,740 --> 00:42:27,970
And so it's going to be roughly
12345 divided by 0.01

726
00:42:27,970 --> 00:42:35,170
squared, which turns out to
be 26.897 more or less.

727
00:42:35,170 --> 00:42:38,170
So we could predict it.

728
00:42:38,170 --> 00:42:41,360
And son of a gun, when we ran
it, we actually matched the

729
00:42:41,360 --> 00:42:43,760
prediction.

730
00:42:43,760 --> 00:42:46,930
That's the great thing about
algorithmic analysis.

731
00:42:46,930 --> 00:42:50,320
We can actually get accurate
guesses as to how long a

732
00:42:50,320 --> 00:42:53,560
program is likely
to take to run.

733
00:42:53,560 --> 00:42:56,815
This is an important thing
because sometimes we do that

734
00:42:56,815 --> 00:42:58,480
and we say, oh, it's going
to take a year.

735
00:42:58,480 --> 00:42:59,990
I better not even try.

736
00:42:59,990 --> 00:43:02,560
I better find a smarter
algorithm.

737
00:43:02,560 --> 00:43:05,140
Or we do it and say, well, it's
going to take almost no

738
00:43:05,140 --> 00:43:06,220
time at all.

739
00:43:06,220 --> 00:43:07,960
I'm not going to waste
my time looking

740
00:43:07,960 --> 00:43:09,470
for a smarter algorithm.

741
00:43:09,470 --> 00:43:12,950
I'm going to live with
the one I've got.

742
00:43:12,950 --> 00:43:15,530
It's important, and again, as
I said, it's a topic we're

743
00:43:15,530 --> 00:43:17,720
going to get back to.

744
00:43:17,720 --> 00:43:21,260
Of course, whether it's
26, 27, or even 50

745
00:43:21,260 --> 00:43:23,020
doesn't really matter.

746
00:43:23,020 --> 00:43:26,160
What matters is it's
not a billion.

747
00:43:26,160 --> 00:43:26,710
Right?

748
00:43:26,710 --> 00:43:29,640
Because we don't really care
small differences.

749
00:43:29,640 --> 00:43:32,730
Whether it takes 25 or it
takes 50 will be an

750
00:43:32,730 --> 00:43:35,140
imperceptible difference.

751
00:43:35,140 --> 00:43:38,110
It's whether it's a huge
difference that matters.

752
00:43:38,110 --> 00:43:42,450
And that's really the kind of
things we're going after is

753
00:43:42,450 --> 00:43:45,530
orders of magnitude.

754
00:43:45,530 --> 00:43:49,810
Now, I have a question
about this program.

755
00:43:49,810 --> 00:43:52,330
I've been obsessing about
whether it's fast enough.

756
00:43:52,330 --> 00:43:54,250
And we've shown it is.

757
00:43:54,250 --> 00:43:55,980
But does it work?

758
00:43:55,980 --> 00:43:57,550
Kind of more important.

759
00:43:57,550 --> 00:44:00,300
It's always possible to write
a really fast program that

760
00:44:00,300 --> 00:44:02,770
gives you the wrong answer.

761
00:44:02,770 --> 00:44:04,790
The problem is to write a fast
program that give you the

762
00:44:04,790 --> 00:44:06,530
right answer.

763
00:44:06,530 --> 00:44:10,140
Does this program always work?

764
00:44:10,140 --> 00:44:11,590
Well, it worked for 25.

765
00:44:11,590 --> 00:44:15,010
It worked for 12345.

766
00:44:15,010 --> 00:44:16,750
Is that good enough?

767
00:44:16,750 --> 00:44:17,560
Probably not.

768
00:44:17,560 --> 00:44:21,360
We might want to try it
in some other values.

769
00:44:21,360 --> 00:44:23,040
I'll ask a simpler question.

770
00:44:23,040 --> 00:44:27,215
Does it always work on
positive values?

771
00:44:27,215 --> 00:44:34,110

772
00:44:34,110 --> 00:44:34,440
All right.

773
00:44:34,440 --> 00:44:35,680
I'll give you a hint.

774
00:44:35,680 --> 00:44:37,370
No.

775
00:44:37,370 --> 00:44:38,620
It does not.

776
00:44:38,620 --> 00:44:40,820

777
00:44:40,820 --> 00:44:44,190
I'm not going to, however,
tell you why it doesn't,

778
00:44:44,190 --> 00:44:46,040
because I want you to
think about it.

779
00:44:46,040 --> 00:44:47,690
And I want you to
tell me why it

780
00:44:47,690 --> 00:44:49,850
doesn't in the next lecture.

781
00:44:49,850 --> 00:44:55,810
But because I'm not a complete
sadist, I'll give you a hint.

782
00:44:55,810 --> 00:45:01,190
When we use bisection search, or
for that matter, any search

783
00:45:01,190 --> 00:45:08,630
method, we are depending upon
the fact that the answer lies

784
00:45:08,630 --> 00:45:10,470
somewhere in the region
we're searching.

785
00:45:10,470 --> 00:45:13,840

786
00:45:13,840 --> 00:45:20,190
If indeed the answer is out
here or out here, then it

787
00:45:20,190 --> 00:45:24,670
doesn't matter how carefully
I search this region.

788
00:45:24,670 --> 00:45:26,130
I'm not going to find
the answer.

789
00:45:26,130 --> 00:45:28,910

790
00:45:28,910 --> 00:45:35,260
And so this program doesn't work
on some potential values

791
00:45:35,260 --> 00:45:40,250
of x because the actual square
root of x will not lie in the

792
00:45:40,250 --> 00:45:44,000
region that the program
is searching.

793
00:45:44,000 --> 00:45:47,790
I leave it to you to think about
what such values are.

794
00:45:47,790 --> 00:45:52,540
And we can talk about that
on the next lecture.

795
00:45:52,540 --> 00:45:55,440

796
00:45:55,440 --> 00:45:59,420
Suppose I want to use this
program to find the cube root.

797
00:45:59,420 --> 00:46:01,180
Suppose it worked, and
I want it to use it

798
00:46:01,180 --> 00:46:03,150
to find a cube root.

799
00:46:03,150 --> 00:46:04,170
What would I have to change?

800
00:46:04,170 --> 00:46:06,890
How would I change it, so it
found cube roots instead of

801
00:46:06,890 --> 00:46:08,140
square roots?

802
00:46:08,140 --> 00:46:11,370

803
00:46:11,370 --> 00:46:12,740
Well, I can take it up.

804
00:46:12,740 --> 00:46:17,060
I could use cut and paste, and
paste it into my editor and

805
00:46:17,060 --> 00:46:18,670
get a new program.

806
00:46:18,670 --> 00:46:20,570
And how would I change
that new program to

807
00:46:20,570 --> 00:46:21,820
make it do cube roots?

808
00:46:21,820 --> 00:46:24,480

809
00:46:24,480 --> 00:46:27,270
Not very hard.

810
00:46:27,270 --> 00:46:29,235
Think only two places
have to get changed.

811
00:46:29,235 --> 00:46:33,150

812
00:46:33,150 --> 00:46:34,940
That's for the simplicity,
say cube

813
00:46:34,940 --> 00:46:36,305
roots of positive numbers.

814
00:46:36,305 --> 00:46:43,220

815
00:46:43,220 --> 00:46:46,590
I think you said the
right thing.

816
00:46:46,590 --> 00:46:52,270
All I have to do is change that
two to a three and that

817
00:46:52,270 --> 00:46:56,220
two to a three, and I'm done.

818
00:46:56,220 --> 00:46:59,450
And I should probably change the
message to say cube root.

819
00:46:59,450 --> 00:47:02,740

820
00:47:02,740 --> 00:47:03,990
Pretty easy.

821
00:47:03,990 --> 00:47:06,550

822
00:47:06,550 --> 00:47:11,690
On the other hand, suppose I
also want it to find the

823
00:47:11,690 --> 00:47:15,150
fourth root, and the fifth
root, and the sixth root,

824
00:47:15,150 --> 00:47:17,180
however many roots.

825
00:47:17,180 --> 00:47:19,900
Well, I'm going to get pretty
tired of cutting, and pasting,

826
00:47:19,900 --> 00:47:23,790
and building a whole
bunch of things.

827
00:47:23,790 --> 00:47:27,590
So really, what I want to do
is find a way to write the

828
00:47:27,590 --> 00:47:35,100
code that will find the nth root
of a number for any n.

829
00:47:35,100 --> 00:47:38,180

830
00:47:38,180 --> 00:47:42,270
To do that, I'm going
to introduce a

831
00:47:42,270 --> 00:47:44,690
new programming concept.

832
00:47:44,690 --> 00:47:47,670
And that concept is
the function.

833
00:47:47,670 --> 00:47:50,570
And that will be the main topic
of Thursday's lecture.

834
00:47:50,570 --> 00:47:55,647
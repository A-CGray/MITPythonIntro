1
00:00:00,000 --> 00:00:00,040

2
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

3
00:00:02,460 --> 00:00:03,870
Commons license.

4
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

5
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

6
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

7
00:00:13,460 --> 00:00:19,290
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:19,290 --> 00:00:20,540
ocw.mit.edu.

9
00:00:20,540 --> 00:00:22,790

10
00:00:22,790 --> 00:00:24,880
PROFESSOR: For those of you who
are unaccustomed to seeing

11
00:00:24,880 --> 00:00:27,325
it, that blue stuff through
the window is called sky.

12
00:00:27,325 --> 00:00:32,159

13
00:00:32,159 --> 00:00:33,340
OK.

14
00:00:33,340 --> 00:00:37,220
I left you last time
with a question.

15
00:00:37,220 --> 00:00:41,680
I'd shown you a bisection search
implementation, or I

16
00:00:41,680 --> 00:00:44,550
should say putative
implementation of the square

17
00:00:44,550 --> 00:00:49,400
root, and told you that it was
flawed, and asked you to think

18
00:00:49,400 --> 00:00:51,610
about what was wrong with it.

19
00:00:51,610 --> 00:00:53,320
So first, I'd just like
to take a poll.

20
00:00:53,320 --> 00:00:57,230
How many of you know what the
problem is, or at least what a

21
00:00:57,230 --> 00:00:59,280
problem is?

22
00:00:59,280 --> 00:01:01,320
OK well that's a good start.

23
00:01:01,320 --> 00:01:04,319
And I won't ask how many of
you don't know, because I

24
00:01:04,319 --> 00:01:06,700
presume that's the
rest of you.

25
00:01:06,700 --> 00:01:08,760
So let's look at it now.

26
00:01:08,760 --> 00:01:11,750
I'm not going to ask you the
answer, because I want to show

27
00:01:11,750 --> 00:01:13,890
people how to find it.

28
00:01:13,890 --> 00:01:18,500
So here's a slightly simplified
version of it.

29
00:01:18,500 --> 00:01:25,920

30
00:01:25,920 --> 00:01:28,300
Just get rid of this stuff here,
so it doesn't confuse

31
00:01:28,300 --> 00:01:29,550
the picture.

32
00:01:29,550 --> 00:01:35,070

33
00:01:35,070 --> 00:01:38,120
So this is roughly the one we
looked at on Tuesday, but I

34
00:01:38,120 --> 00:01:40,250
just took out some print
statements and things and

35
00:01:40,250 --> 00:01:42,230
simplified it.

36
00:01:42,230 --> 00:01:46,770
And let's just run it.

37
00:01:46,770 --> 00:01:49,620
And we'll run it with
trying to find the

38
00:01:49,620 --> 00:01:53,610
square root of 0.5.

39
00:01:53,610 --> 00:01:55,320
See what happens
when we run it.

40
00:01:55,320 --> 00:02:01,730

41
00:02:01,730 --> 00:02:04,280
Well, not much happens
when we run it.

42
00:02:04,280 --> 00:02:05,700
Actually quite a lot
is happening.

43
00:02:05,700 --> 00:02:08,000
We just can't see it.

44
00:02:08,000 --> 00:02:12,960
So this program is running
longer than I expected it to.

45
00:02:12,960 --> 00:02:18,990
So if you go to the keyboard and
you hit Control and C. It

46
00:02:18,990 --> 00:02:20,190
will interrupt the program.

47
00:02:20,190 --> 00:02:23,980
It generates what's called
a keyboard interrupt,

48
00:02:23,980 --> 00:02:27,430
and it stops it.

49
00:02:27,430 --> 00:02:29,490
And it tells us where it
happened to stop it.

50
00:02:29,490 --> 00:02:33,300
It happened to stop
it in line seven--

51
00:02:33,300 --> 00:02:36,030
the test of the while loop.

52
00:02:36,030 --> 00:02:38,650
And the problem is, the program
just seemed to be

53
00:02:38,650 --> 00:02:40,740
running forever.

54
00:02:40,740 --> 00:02:45,240
So despite my, perhaps
persuasive, argument last time

55
00:02:45,240 --> 00:02:48,070
about the decrementing function,
there's clearly a

56
00:02:48,070 --> 00:02:50,220
flaw in my logic.

57
00:02:50,220 --> 00:02:53,730
And, in fact, it does not
always terminate.

58
00:02:53,730 --> 00:02:57,510
So what do we do about it?

59
00:02:57,510 --> 00:02:59,260
Well this is the main trick.

60
00:02:59,260 --> 00:03:03,410
And one of the things I need
you to understand this

61
00:03:03,410 --> 00:03:08,010
semester is perhaps the most
important thing you'll learn

62
00:03:08,010 --> 00:03:10,940
is how to debug programs.

63
00:03:10,940 --> 00:03:14,330
Too many people think the hard
part is done when they write

64
00:03:14,330 --> 00:03:16,060
the code the first time.

65
00:03:16,060 --> 00:03:18,500
No, that's actually
the easy part.

66
00:03:18,500 --> 00:03:22,820
The hard part is actually
getting it to work.

67
00:03:22,820 --> 00:03:27,600
So the thing you need to learn
is how to debug code, and the

68
00:03:27,600 --> 00:03:29,580
nice thing is it's a
transferable skill.

69
00:03:29,580 --> 00:03:34,010
It's also fine for debugging
lab experiences or family

70
00:03:34,010 --> 00:03:38,290
members or anything else that
can be seriously awry.

71
00:03:38,290 --> 00:03:41,520
So the way I do it when I
program is typically with

72
00:03:41,520 --> 00:03:43,660
print statements.

73
00:03:43,660 --> 00:03:47,950
So the fact that the program was
running forever, suggests

74
00:03:47,950 --> 00:03:50,510
that I'm not exiting
the while loop.

75
00:03:50,510 --> 00:03:53,550
So clearly, I need to print
something in the while loop.

76
00:03:53,550 --> 00:03:56,350

77
00:03:56,350 --> 00:04:00,080
And the only three variables
it seems to be using are

78
00:04:00,080 --> 00:04:04,280
answer, low, and high.

79
00:04:04,280 --> 00:04:06,110
Those are the three
that change.

80
00:04:06,110 --> 00:04:09,680
So let's see what
the value is.

81
00:04:09,680 --> 00:04:13,430
Notice, by the way, that I
actually went to the trouble

82
00:04:13,430 --> 00:04:18,899
to type ans equals ans, low
equals low, et cetera.

83
00:04:18,899 --> 00:04:22,225
A lot of people would just say,
OK I'm going to print and

84
00:04:22,225 --> 00:04:25,420
they'll ans comma
low comma high.

85
00:04:25,420 --> 00:04:27,040
And then when they run
the code they'll

86
00:04:27,040 --> 00:04:29,440
forget which is which.

87
00:04:29,440 --> 00:04:33,880
The most common problem that
people have in debugging

88
00:04:33,880 --> 00:04:38,410
programs is that
they are lazy.

89
00:04:38,410 --> 00:04:41,330
They think they're saving
themselves work, and in fact

90
00:04:41,330 --> 00:04:42,830
they're creating work.

91
00:04:42,830 --> 00:04:45,390
So my first piece of
advice to you as

92
00:04:45,390 --> 00:04:49,100
debuggers is don't be lazy.

93
00:04:49,100 --> 00:04:51,970
Maybe you heard this from your
mother at some point in life,

94
00:04:51,970 --> 00:04:53,080
or your father.

95
00:04:53,080 --> 00:04:55,000
But now you're hearing
it from me.

96
00:04:55,000 --> 00:04:58,850
Try and just do it right
the first time.

97
00:04:58,850 --> 00:05:00,985
So let's run it and see
what happens now.

98
00:05:00,985 --> 00:05:04,470

99
00:05:04,470 --> 00:05:06,085
Well at least it's printing
some output.

100
00:05:06,085 --> 00:05:09,550

101
00:05:09,550 --> 00:05:13,610
And it's chugging away
and chug-- uh-oh--

102
00:05:13,610 --> 00:05:18,580
so now, we see we have
a real problem.

103
00:05:18,580 --> 00:05:22,820
We've reached a fixed point,
where every time through the

104
00:05:22,820 --> 00:05:25,610
loop, nothing is changing.

105
00:05:25,610 --> 00:05:27,760
Well the first time we go
through the loop and nothing

106
00:05:27,760 --> 00:05:31,550
changes we know we're in
trouble, because nothing's

107
00:05:31,550 --> 00:05:32,620
going to ever change.

108
00:05:32,620 --> 00:05:35,790
And therefore, we're going to
be in the loop forever.

109
00:05:35,790 --> 00:05:39,120
So we see, I've gone
to a stage where

110
00:05:39,120 --> 00:05:42,660
everything equals 0.5.

111
00:05:42,660 --> 00:05:46,620
And now if I go back and look at
the code, and I ask myself

112
00:05:46,620 --> 00:05:52,070
the question well what happens
when everything is 0.5, and I

113
00:05:52,070 --> 00:05:54,040
can see the problem.

114
00:05:54,040 --> 00:05:55,480
It's this statement here.

115
00:05:55,480 --> 00:06:00,270

116
00:06:00,270 --> 00:06:01,670
Yep, turn it around maybe.

117
00:06:01,670 --> 00:06:04,590

118
00:06:04,590 --> 00:06:08,600
But that's never going to change
now, because it's 0.5

119
00:06:08,600 --> 00:06:15,230
plus 0.5, divided by 2 is 0.5.

120
00:06:15,230 --> 00:06:17,610
And it'll just stay
there forever.

121
00:06:17,610 --> 00:06:19,030
So that's my problem.

122
00:06:19,030 --> 00:06:22,770
I have to somehow change
my code now, so that

123
00:06:22,770 --> 00:06:24,020
this doesn't happen.

124
00:06:24,020 --> 00:06:26,830

125
00:06:26,830 --> 00:06:29,610
So what is the problem?

126
00:06:29,610 --> 00:06:31,950
Now somebody can tell
me, simply.

127
00:06:31,950 --> 00:06:34,130
What is the problem here?

128
00:06:34,130 --> 00:06:37,570
What was the flaw in my
reasoning when I first set

129
00:06:37,570 --> 00:06:41,026
this program up?

130
00:06:41,026 --> 00:06:42,433
Yeah?

131
00:06:42,433 --> 00:06:44,652
AUDIENCE: [INAUDIBLE]

132
00:06:44,652 --> 00:06:46,223
PROFESSOR: Louder please?

133
00:06:46,223 --> 00:06:48,155
AUDIENCE: You don't have a high
minus low is less than or

134
00:06:48,155 --> 00:06:52,019
equal to epsilon.

135
00:06:52,019 --> 00:06:54,700
PROFESSOR: So the comment was I
don't have a high minus low

136
00:06:54,700 --> 00:06:58,230
is less than or equal
to epsilon.

137
00:06:58,230 --> 00:07:01,570
True, but that's not really
the real flaw.

138
00:07:01,570 --> 00:07:03,569
Yeah?

139
00:07:03,569 --> 00:07:05,048
AUDIENCE: The fraction is
greater than the original

140
00:07:05,048 --> 00:07:08,499
fraction, so the solution is
not in the search space.

141
00:07:08,499 --> 00:07:09,980
PROFESSOR: Exactly.

142
00:07:09,980 --> 00:07:16,700
So the answer is the problem was
that I did a search in a

143
00:07:16,700 --> 00:07:20,640
region, and the answer wasn't
in that region.

144
00:07:20,640 --> 00:07:25,770
Because the square root
of 0.5 does not lie

145
00:07:25,770 --> 00:07:29,650
between 0 and 0.5.

146
00:07:29,650 --> 00:07:32,860
Silly me, when I thought about
it, I didn't think of finding

147
00:07:32,860 --> 00:07:36,680
the square root of numbers
less than 1.

148
00:07:36,680 --> 00:07:40,380
So what's a simple fix?

149
00:07:40,380 --> 00:07:44,500
Well what I can do is the
following: I'll go back and

150
00:07:44,500 --> 00:07:48,895
say high is going to be
the max of x and 1.

151
00:07:48,895 --> 00:07:54,200

152
00:07:54,200 --> 00:07:57,430
So now I'm going to ensure that
the square root actually

153
00:07:57,430 --> 00:07:59,200
does lie in the region
I'm searching.

154
00:07:59,200 --> 00:08:02,050

155
00:08:02,050 --> 00:08:02,870
I hope.

156
00:08:02,870 --> 00:08:05,498
Let's run it.

157
00:08:05,498 --> 00:08:07,290
Ah.

158
00:08:07,290 --> 00:08:09,580
All right, well I got to some
stuff at the end which you

159
00:08:09,580 --> 00:08:14,800
shouldn't worry about, but it
found something that I guess

160
00:08:14,800 --> 00:08:16,050
is a good enough answer.

161
00:08:16,050 --> 00:08:21,724

162
00:08:21,724 --> 00:08:38,990
We'll get rid of that code I
put in this morning which

163
00:08:38,990 --> 00:08:40,289
we'll get to this later.

164
00:08:40,289 --> 00:08:48,090

165
00:08:48,090 --> 00:08:52,450
OK so I've now fixed
the program.

166
00:08:52,450 --> 00:08:53,410
Everyone with me on that?

167
00:08:53,410 --> 00:08:55,750
Any questions?

168
00:08:55,750 --> 00:08:59,600
And the thing to understand is
conceptually what was wrong

169
00:08:59,600 --> 00:09:03,290
with my reasoning, that I'm
doing a search in a region

170
00:09:03,290 --> 00:09:05,140
where the answer doesn't lie.

171
00:09:05,140 --> 00:09:06,840
So I'm not going to find it.

172
00:09:06,840 --> 00:09:10,920
And the other thing to
understand is my systematic

173
00:09:10,920 --> 00:09:13,650
way of finding the bug.

174
00:09:13,650 --> 00:09:16,120
Now I confess I knew the bug
was there when I wrote the

175
00:09:16,120 --> 00:09:18,630
code, so I kind of cheated
with the debugging.

176
00:09:18,630 --> 00:09:20,380
But even if I hadn't
known, this is what

177
00:09:20,380 --> 00:09:21,490
I would have done.

178
00:09:21,490 --> 00:09:24,610
I would have put in that
print statement.

179
00:09:24,610 --> 00:09:28,770
All right, so now we have
actually a pretty good piece

180
00:09:28,770 --> 00:09:31,580
of code for finding
square roots.

181
00:09:31,580 --> 00:09:34,540
And as we looked at on Tuesday,
I can use the same

182
00:09:34,540 --> 00:09:35,890
piece of code.

183
00:09:35,890 --> 00:09:39,640
I can modify it to get cube
roots, or fourth roots, or

184
00:09:39,640 --> 00:09:41,160
fifth roots.

185
00:09:41,160 --> 00:09:46,030
And so I have a general
framework for doing things.

186
00:09:46,030 --> 00:09:52,020
But it's pretty unsatisfying in
that sense, because let's

187
00:09:52,020 --> 00:09:54,320
look at it.

188
00:09:54,320 --> 00:09:58,060
If I wanted to find the square
root of some number other than

189
00:09:58,060 --> 00:10:04,216
0.5, I have to go and edit the
code, replace the assignment

190
00:10:04,216 --> 00:10:07,940
to x by whatever I'm
trying to do.

191
00:10:07,940 --> 00:10:11,880
If I want to do cube roots I
have to cut and paste and edit

192
00:10:11,880 --> 00:10:13,130
and do things.

193
00:10:13,130 --> 00:10:15,180

194
00:10:15,180 --> 00:10:19,560
There's no very good way to now
embed this piece of code

195
00:10:19,560 --> 00:10:22,390
inside a larger computation.

196
00:10:22,390 --> 00:10:27,330
Imagine that I've got some
10,000 line program that needs

197
00:10:27,330 --> 00:10:31,010
to find the square root six or
seven times, well now I'm

198
00:10:31,010 --> 00:10:33,500
going to have six or seven
copies of this code in my

199
00:10:33,500 --> 00:10:36,440
program, for every time I
need the square root.

200
00:10:36,440 --> 00:10:39,230

201
00:10:39,230 --> 00:10:41,535
Clearly not what
you want to do.

202
00:10:41,535 --> 00:10:44,070

203
00:10:44,070 --> 00:10:49,870
In general, having more
code is a bad thing.

204
00:10:49,870 --> 00:10:53,460
So it's not like you're given an
essay to write and someone

205
00:10:53,460 --> 00:10:57,030
tells you it's got to be 5,000
words, and you just sweat

206
00:10:57,030 --> 00:11:01,810
blood trying to figure out how
to stretch it to be that long.

207
00:11:01,810 --> 00:11:04,020
In code, it's the other
way around.

208
00:11:04,020 --> 00:11:07,520
Most of the time we want to make
it shorter not longer.

209
00:11:07,520 --> 00:11:11,330
And the reason we want to do
that is the difficulty of

210
00:11:11,330 --> 00:11:16,280
getting code to work grows,
maybe even grows

211
00:11:16,280 --> 00:11:19,860
quadratically, or worse but
the size of the code.

212
00:11:19,860 --> 00:11:21,820
So the more code you have,
the harder it is

213
00:11:21,820 --> 00:11:23,370
to get it to work.

214
00:11:23,370 --> 00:11:26,950
So one of the things good
programmers learn to do is

215
00:11:26,950 --> 00:11:30,170
write less code.

216
00:11:30,170 --> 00:11:32,840
And so we don't measure
productivity of a programmer

217
00:11:32,840 --> 00:11:36,540
by the number of lines of code
they produce each day, but we

218
00:11:36,540 --> 00:11:38,890
measure it by the amount
of functionality they

219
00:11:38,890 --> 00:11:40,560
produce each day.

220
00:11:40,560 --> 00:11:43,390
And we give them bonus points
if they achieve the desired

221
00:11:43,390 --> 00:11:46,610
functionality with less code.

222
00:11:46,610 --> 00:11:51,470
So let's talk about how
we can write less code

223
00:11:51,470 --> 00:11:54,980
and accomplish more.

224
00:11:54,980 --> 00:11:59,320
Well to do that, we're going
to look at a new language

225
00:11:59,320 --> 00:12:00,090
mechanism--

226
00:12:00,090 --> 00:12:03,410
actually not new, but
new to this class--

227
00:12:03,410 --> 00:12:05,750
called a function.

228
00:12:05,750 --> 00:12:11,310
But before we do that, I want
to pull back and talk about

229
00:12:11,310 --> 00:12:14,880
what it is we hope to accomplish
by introducing

230
00:12:14,880 --> 00:12:18,610
functions into our programming
language.

231
00:12:18,610 --> 00:12:24,160
We want to provide a mechanism
that provides for two things:

232
00:12:24,160 --> 00:12:31,900
decomposition and abstraction.

233
00:12:31,900 --> 00:12:42,400

234
00:12:42,400 --> 00:12:46,590
What decomposition does, is
it creates structure.

235
00:12:46,590 --> 00:12:55,770

236
00:12:55,770 --> 00:12:59,740
It allows us to break our
program up into something

237
00:12:59,740 --> 00:13:00,990
called modules.

238
00:13:00,990 --> 00:13:04,370

239
00:13:04,370 --> 00:13:07,440
And the module we'll focus on
today is function, but later

240
00:13:07,440 --> 00:13:10,320
we'll see there's another
important kind of module in

241
00:13:10,320 --> 00:13:13,900
Python called the class.

242
00:13:13,900 --> 00:13:22,650
And the advantage of a module is
it should be self-contained

243
00:13:22,650 --> 00:13:23,900
and reusable.

244
00:13:23,900 --> 00:13:26,010

245
00:13:26,010 --> 00:13:30,510
So it's a self-contained unit
of functionality that can be

246
00:13:30,510 --> 00:13:32,086
used in multiple contexts.

247
00:13:32,086 --> 00:13:35,680

248
00:13:35,680 --> 00:13:39,310
Abstraction suppresses
details.

249
00:13:39,310 --> 00:13:48,410

250
00:13:48,410 --> 00:13:52,620
It allows us to use a piece
of code as if it

251
00:13:52,620 --> 00:13:55,070
were a black box.

252
00:13:55,070 --> 00:13:59,870
That is, something whose
interior details we can't see,

253
00:13:59,870 --> 00:14:03,640
don't need to see, and shouldn't
even want to see.

254
00:14:03,640 --> 00:14:06,670

255
00:14:06,670 --> 00:14:09,220
We only need to understand
what it does,

256
00:14:09,220 --> 00:14:11,580
not how it does it.

257
00:14:11,580 --> 00:14:15,610
And that lets us use code
that other people

258
00:14:15,610 --> 00:14:18,620
have written easily.

259
00:14:18,620 --> 00:14:21,095
And, in fact, use code that
we have written easily.

260
00:14:21,095 --> 00:14:25,180

261
00:14:25,180 --> 00:14:28,790
It's one of those few occasions
where I think Thomas

262
00:14:28,790 --> 00:14:32,900
Gray was right, when he said,
"ignorance is bliss."

263
00:14:32,900 --> 00:14:35,505
Sometimes knowing
less is better.

264
00:14:35,505 --> 00:14:38,040

265
00:14:38,040 --> 00:14:41,400
All right, so let's look at
the way functions work.

266
00:14:41,400 --> 00:14:44,860
The functions let us
break code into

267
00:14:44,860 --> 00:14:49,390
reusable, coherent pieces.

268
00:14:49,390 --> 00:14:52,930
Now we've already looked at
similar kinds of things.

269
00:14:52,930 --> 00:14:57,090
When we looked at say floating
point numbers, and we wrote

270
00:14:57,090 --> 00:15:01,050
operations like plus or divide,
whatever, we didn't

271
00:15:01,050 --> 00:15:03,240
worry about how they
were actually

272
00:15:03,240 --> 00:15:05,460
implemented in the machine.

273
00:15:05,460 --> 00:15:08,030
We said OK they do something,
they're kind of like dividing

274
00:15:08,030 --> 00:15:10,570
real numbers, let's not worry
about the details.

275
00:15:10,570 --> 00:15:13,810

276
00:15:13,810 --> 00:15:15,420
We do that with a
lot of things.

277
00:15:15,420 --> 00:15:16,590
We looked at strings.

278
00:15:16,590 --> 00:15:18,740
We concatenated strings.

279
00:15:18,740 --> 00:15:21,370
Well we didn't worry about
how did Python

280
00:15:21,370 --> 00:15:22,590
go about doing that.

281
00:15:22,590 --> 00:15:25,610
We just assumed it did it,
and it had the meaning

282
00:15:25,610 --> 00:15:27,710
we wanted it to.

283
00:15:27,710 --> 00:15:32,100
What functions let us do is
extend the language in some

284
00:15:32,100 --> 00:15:38,290
sense by adding new primitives
that we can use just the way

285
00:15:38,290 --> 00:15:39,745
we used the built-in
primitives.

286
00:15:39,745 --> 00:15:42,250

287
00:15:42,250 --> 00:15:46,060
So let's look at an
example here.

288
00:15:46,060 --> 00:15:47,625
I've written a very
simple function.

289
00:15:47,625 --> 00:15:56,440

290
00:15:56,440 --> 00:15:59,670
Does something that we actually
did already when we

291
00:15:59,670 --> 00:16:02,220
looked at square roots.

292
00:16:02,220 --> 00:16:06,360
It's a function called
within epsilon.

293
00:16:06,360 --> 00:16:09,990
And let me comment this out
while I'm thinking about it,

294
00:16:09,990 --> 00:16:11,435
so we don't have to live
with it later.

295
00:16:11,435 --> 00:16:17,150

296
00:16:17,150 --> 00:16:21,100
And I now want to walk you,
slowly, through what this

297
00:16:21,100 --> 00:16:23,550
function does.

298
00:16:23,550 --> 00:16:30,400
So at the start, it uses the
keyword Def, short for define.

299
00:16:30,400 --> 00:16:32,850
Following that is a name.

300
00:16:32,850 --> 00:16:35,520
I chose the name
within epsilon.

301
00:16:35,520 --> 00:16:40,230
You can choose any name you
want for a function.

302
00:16:40,230 --> 00:16:43,660
I'm strongly encourage you to
choose mnemonic names, that is

303
00:16:43,660 --> 00:16:47,200
to say names that
have a meaning.

304
00:16:47,200 --> 00:16:50,430
So in some sense you see it says
within epsilon, and you

305
00:16:50,430 --> 00:16:53,430
know what it does already.

306
00:16:53,430 --> 00:16:57,070
Following that, it has three
things called formal

307
00:16:57,070 --> 00:16:59,050
parameters.

308
00:16:59,050 --> 00:17:02,460
I'll come back to in a minute,
what that means.

309
00:17:02,460 --> 00:17:04,690
And then after that, it's
got something called

310
00:17:04,690 --> 00:17:07,960
the function body.

311
00:17:07,960 --> 00:17:21,589
So we see that a function has a
name, it has parameters, and

312
00:17:21,589 --> 00:17:22,839
it has a body.

313
00:17:22,839 --> 00:17:25,119

314
00:17:25,119 --> 00:17:28,990
The body is the code that's
part of the function.

315
00:17:28,990 --> 00:17:36,380

316
00:17:36,380 --> 00:17:41,600
In the body, you can write
any code you want.

317
00:17:41,600 --> 00:17:44,310
Plus, there's something you
can't write outside of a

318
00:17:44,310 --> 00:17:48,160
function, called return.

319
00:17:48,160 --> 00:17:54,760
That's a special command that
says whoever calls me has

320
00:17:54,760 --> 00:17:57,570
called me to have me
compute a value.

321
00:17:57,570 --> 00:18:01,570
I'm going to return the value
that this person would want.

322
00:18:01,570 --> 00:18:05,090
And then here we see something
that's very important.

323
00:18:05,090 --> 00:18:09,380
This is where we get
abstraction, and that's the

324
00:18:09,380 --> 00:18:12,420
specification of the function.

325
00:18:12,420 --> 00:18:15,170
And it says here, there
are two pieces to it.

326
00:18:15,170 --> 00:18:21,720
One that its parameters x, y,
and epsilon, are all floats.

327
00:18:21,720 --> 00:18:25,015
And furthermore, epsilon
is greater than 0.

328
00:18:25,015 --> 00:18:28,450

329
00:18:28,450 --> 00:18:34,790
You can imagine this is
important, and it returns true

330
00:18:34,790 --> 00:18:38,840
if x is within epsilon of y.

331
00:18:38,840 --> 00:18:42,450
Otherwise it will
return false.

332
00:18:42,450 --> 00:18:46,960
If I want to use within epsilon,
I don't need to look

333
00:18:46,960 --> 00:18:49,130
at the code.

334
00:18:49,130 --> 00:18:53,190
I look instead at the
specification.

335
00:18:53,190 --> 00:18:56,730
Now here where the code is one
line, maybe I haven't gained a

336
00:18:56,730 --> 00:18:58,650
lot by looking at the
specification

337
00:18:58,650 --> 00:18:59,900
instead of the code.

338
00:18:59,900 --> 00:19:04,350
But you can imagine if the code
were 1,000 lines, I'd

339
00:19:04,350 --> 00:19:08,900
much rather read the
specification than the code.

340
00:19:08,900 --> 00:19:14,920
We'll also see for other reasons
later why it's in fact

341
00:19:14,920 --> 00:19:16,640
dangerous to look at the code.

342
00:19:16,640 --> 00:19:20,210

343
00:19:20,210 --> 00:19:23,960
How do I use it?

344
00:19:23,960 --> 00:19:27,210
I use it by invoking it.

345
00:19:27,210 --> 00:19:34,560
So I could, for example write
something like print within

346
00:19:34,560 --> 00:19:45,210
epsilon, of two, three, one.

347
00:19:45,210 --> 00:19:46,460
What's it going to print?

348
00:19:46,460 --> 00:19:48,990

349
00:19:48,990 --> 00:19:50,840
Pardon?

350
00:19:50,840 --> 00:19:52,410
Why is it going to print
an error do you think?

351
00:19:52,410 --> 00:19:54,390
AUDIENCE: Because you
haven't put epsilon.

352
00:19:54,390 --> 00:19:55,875
PROFESSOR: Ah, typed it wrong.

353
00:19:55,875 --> 00:19:58,350
Thank you.

354
00:19:58,350 --> 00:19:59,340
You're correct.

355
00:19:59,340 --> 00:20:01,320
It would have printed
an error.

356
00:20:01,320 --> 00:20:04,785
Now what will it print?

357
00:20:04,785 --> 00:20:06,035
AUDIENCE: [INAUDIBLE]

358
00:20:06,035 --> 00:20:08,270

359
00:20:08,270 --> 00:20:09,520
PROFESSOR: Sure enough.

360
00:20:09,520 --> 00:20:11,840

361
00:20:11,840 --> 00:20:19,850
I could also, if I chose,
write something like val

362
00:20:19,850 --> 00:20:37,575
equals that, then if I want
I could print val.

363
00:20:37,575 --> 00:20:42,750

364
00:20:42,750 --> 00:20:44,890
Now it's going to print false.

365
00:20:44,890 --> 00:20:49,760
So within epsilon is just like
plus or something else, does

366
00:20:49,760 --> 00:20:52,070
some computation,
returns a value.

367
00:20:52,070 --> 00:20:56,530
I can use that value any place
I could have used an

368
00:20:56,530 --> 00:20:57,780
expression.

369
00:20:57,780 --> 00:20:59,530

370
00:20:59,530 --> 00:21:03,130
Now one more thing to
look at with this.

371
00:21:03,130 --> 00:21:05,825
Suppose I don't return
anything.

372
00:21:05,825 --> 00:21:11,800

373
00:21:11,800 --> 00:21:14,910
Anyone want to guess what
it's going to do now?

374
00:21:14,910 --> 00:21:17,830
I point this out, because this
is a very common error.

375
00:21:17,830 --> 00:21:22,580
People write lots of code,
calculate some wonderful value

376
00:21:22,580 --> 00:21:25,060
and then forget to return it.

377
00:21:25,060 --> 00:21:27,830
What's it going to do now?

378
00:21:27,830 --> 00:21:29,270
Well let's run it and see.

379
00:21:29,270 --> 00:21:32,770
That, by the way, is a good
habit to get into.

380
00:21:32,770 --> 00:21:35,730
It's going to return the
special value none.

381
00:21:35,730 --> 00:21:38,150
Remember we looked at that
earlier, meaning I

382
00:21:38,150 --> 00:21:41,180
don't have a value.

383
00:21:41,180 --> 00:21:45,330
So if you see in your code some
none popping up where you

384
00:21:45,330 --> 00:21:50,820
don't expect it to, it's
probably because you forgot to

385
00:21:50,820 --> 00:21:53,630
return a value.

386
00:21:53,630 --> 00:21:54,900
So just keep that in mind.

387
00:21:54,900 --> 00:21:57,980

388
00:21:57,980 --> 00:22:04,870
All right, now there's a
big advantage of this.

389
00:22:04,870 --> 00:22:10,630
Once I've written this code I
can now anywhere I want call

390
00:22:10,630 --> 00:22:14,760
within epsilon, and I don't have
to duplicate the code.

391
00:22:14,760 --> 00:22:16,010
I only do it once.

392
00:22:16,010 --> 00:22:19,040

393
00:22:19,040 --> 00:22:22,010
As I said earlier maybe I'm not
gaining much, because the

394
00:22:22,010 --> 00:22:25,040
body is so short.

395
00:22:25,040 --> 00:22:29,490
On the other hand, I'm still
gaining something.

396
00:22:29,490 --> 00:22:35,880
Notice that when I look at the
code down here, it's easy to

397
00:22:35,880 --> 00:22:39,080
read, I'm printing within
epsilon two, three, and one.

398
00:22:39,080 --> 00:22:42,010

399
00:22:42,010 --> 00:22:45,360
And I don't have to decode this
and tell me that that's

400
00:22:45,360 --> 00:22:47,420
what that's doing.

401
00:22:47,420 --> 00:22:51,920
So if I have a function and I
choose the names properly,

402
00:22:51,920 --> 00:22:56,460
code that uses the function
is much easier to read.

403
00:22:56,460 --> 00:22:57,710
And that can be a big value.

404
00:22:57,710 --> 00:23:04,000

405
00:23:04,000 --> 00:23:06,620
All right, let's look
at another example.

406
00:23:06,620 --> 00:23:12,880

407
00:23:12,880 --> 00:23:16,440
So here I've got this
function, f.

408
00:23:16,440 --> 00:23:19,470

409
00:23:19,470 --> 00:23:22,670
I've chose a non-mnemonic name,
because there isn't much

410
00:23:22,670 --> 00:23:23,920
meaning to this function.

411
00:23:23,920 --> 00:23:27,650

412
00:23:27,650 --> 00:23:31,220
What f does, it is a
formal parameter x.

413
00:23:31,220 --> 00:23:34,220
It sets x to x plus 1.

414
00:23:34,220 --> 00:23:37,650
Then it prints x
and returns x--

415
00:23:37,650 --> 00:23:38,900
pretty boring.

416
00:23:38,900 --> 00:23:46,340

417
00:23:46,340 --> 00:23:47,960
So let's see what
it does here.

418
00:23:47,960 --> 00:23:52,300

419
00:23:52,300 --> 00:23:58,260
So now I'm going to set x to
three, set z, or zed if you

420
00:23:58,260 --> 00:24:02,330
happen to be Canadian,
to f of x.

421
00:24:02,330 --> 00:24:05,900
And then print the values
of z and x.

422
00:24:05,900 --> 00:24:10,330
Also in f, before I return
x, I'm going to print it.

423
00:24:10,330 --> 00:24:14,160

424
00:24:14,160 --> 00:24:16,030
So let's see what happens
when I run this one.

425
00:24:16,030 --> 00:24:20,210

426
00:24:20,210 --> 00:24:25,590
It prints four, four,
and then three.

427
00:24:25,590 --> 00:24:28,570
All right, what's going on?

428
00:24:28,570 --> 00:24:31,250
Why did it do that?

429
00:24:31,250 --> 00:24:36,650
Well it's pretty easy to see
why it printed four here,

430
00:24:36,650 --> 00:24:46,020
because I called f of x with
an x equal to 3, and then I

431
00:24:46,020 --> 00:24:47,940
incremented it by one, and
then I printed it.

432
00:24:47,940 --> 00:24:51,380

433
00:24:51,380 --> 00:25:00,120
It's probably also easy to
understand why z was four,

434
00:25:00,120 --> 00:25:05,200
because I returned the value of
x here, which was four and

435
00:25:05,200 --> 00:25:06,870
it printed it.

436
00:25:06,870 --> 00:25:08,750
But why is this x three?

437
00:25:08,750 --> 00:25:12,130

438
00:25:12,130 --> 00:25:19,550
And the answer is this x and
that x have nothing to do with

439
00:25:19,550 --> 00:25:20,800
each other.

440
00:25:20,800 --> 00:25:23,540

441
00:25:23,540 --> 00:25:24,660
Right?

442
00:25:24,660 --> 00:25:29,050
I could just as easily have
chosen some other value for

443
00:25:29,050 --> 00:25:35,340
the formal parameter, say
George, and said George is

444
00:25:35,340 --> 00:25:38,455
equal to George plus 1, print
George, return George.

445
00:25:38,455 --> 00:25:42,550

446
00:25:42,550 --> 00:25:48,080
There is no relation between the
name of the formal and, in

447
00:25:48,080 --> 00:25:54,130
this case, x defined in the
calling environment.

448
00:25:54,130 --> 00:25:57,180
So now let's think about that
by working slowly and

449
00:25:57,180 --> 00:26:02,120
carefully through what happens
when we call a function.

450
00:26:02,120 --> 00:26:05,440

451
00:26:05,440 --> 00:26:09,190
So the first thing that happens
at the call, and I'll

452
00:26:09,190 --> 00:26:22,910
just work it through this one,
is the formal parameter, x in

453
00:26:22,910 --> 00:26:29,520
this case, is bound--

454
00:26:29,520 --> 00:26:32,670
and I'll come back to what
binding means, that's a

455
00:26:32,670 --> 00:26:34,280
critical concept here--

456
00:26:34,280 --> 00:26:37,960

457
00:26:37,960 --> 00:26:46,805
to the value of the
actual parameter.

458
00:26:46,805 --> 00:26:50,300

459
00:26:50,300 --> 00:26:58,550
So these are important terms,
actual and formal, which in

460
00:26:58,550 --> 00:27:02,065
this case, also happens
to be called x.

461
00:27:02,065 --> 00:27:07,130

462
00:27:07,130 --> 00:27:20,900
But what's happening here, is
upon entry of a function, a

463
00:27:20,900 --> 00:27:23,020
new scope is created.

464
00:27:23,020 --> 00:27:33,160

465
00:27:33,160 --> 00:27:35,340
What's a scope?

466
00:27:35,340 --> 00:27:45,070
A scope is a mapping from
names to objects.

467
00:27:45,070 --> 00:27:57,380

468
00:27:57,380 --> 00:28:01,510
So if we look at what's going
on over here, we can draw a

469
00:28:01,510 --> 00:28:03,420
little picture.

470
00:28:03,420 --> 00:28:04,910
Well before I draw a picture,
I'm going to look at a

471
00:28:04,910 --> 00:28:07,860
slightly more complicated
example.

472
00:28:07,860 --> 00:28:10,740
Well, yeah let's do that.

473
00:28:10,740 --> 00:28:16,530
This one is not in your
handout, but it is

474
00:28:16,530 --> 00:28:19,900
illustrative of, I think, what's
really going on here.

475
00:28:19,900 --> 00:28:32,590

476
00:28:32,590 --> 00:28:35,060
Here I've got another
beautifully named function, in

477
00:28:35,060 --> 00:28:42,250
this case f1, and inside it,
I've defined another function,

478
00:28:42,250 --> 00:28:45,406
called g, which takes
no arguments.

479
00:28:45,406 --> 00:28:48,720

480
00:28:48,720 --> 00:28:51,460
I've set x to abc.

481
00:28:51,460 --> 00:28:55,460

482
00:28:55,460 --> 00:28:58,550
Then I haven't shown you these
assert statements yet, or

483
00:28:58,550 --> 00:29:00,480
haven't talked about them.

484
00:29:00,480 --> 00:29:07,350
Assert is a command in which the
keyword assert is followed

485
00:29:07,350 --> 00:29:10,040
by an expression that
evaluates to

486
00:29:10,040 --> 00:29:12,950
either true or false.

487
00:29:12,950 --> 00:29:16,830
If it evaluates to true,
it does nothing.

488
00:29:16,830 --> 00:29:18,420
It just continues.

489
00:29:18,420 --> 00:29:21,610
If it evaluates to false,
it stops your

490
00:29:21,610 --> 00:29:24,480
program dead in its tracks.

491
00:29:24,480 --> 00:29:28,140
So I've just used it here as a
trick to make my program stop

492
00:29:28,140 --> 00:29:30,930
when I run it.

493
00:29:30,930 --> 00:29:36,140
In general, you'll find that
I use asserts quite a lot.

494
00:29:36,140 --> 00:29:41,020
So for example, in the next
piece of code, which

495
00:29:41,020 --> 00:29:43,310
is called find root.

496
00:29:43,310 --> 00:29:47,150
It takes the root, is it square,
or cube, whatever, the

497
00:29:47,150 --> 00:29:50,690
value, and epsilon.

498
00:29:50,690 --> 00:29:53,730
It assumes that powers, and
int, and val, and epsilon

499
00:29:53,730 --> 00:29:57,880
float, in the specification.

500
00:29:57,880 --> 00:30:01,320
And then you'll notice, I
start by putting in an

501
00:30:01,320 --> 00:30:04,250
assertion here.

502
00:30:04,250 --> 00:30:08,610
And what I'm asserting is that
the actuals to which these

503
00:30:08,610 --> 00:30:12,530
formals are bound, have the
properties the specification

504
00:30:12,530 --> 00:30:15,080
says they do.

505
00:30:15,080 --> 00:30:18,150
This is what's called defensive
programming.

506
00:30:18,150 --> 00:30:21,760
In principle, I shouldn't have
to do that, because in

507
00:30:21,760 --> 00:30:27,130
principle, nobody should call
this with incorrect values.

508
00:30:27,130 --> 00:30:29,490
But, in fact, it can happen.

509
00:30:29,490 --> 00:30:32,550
Programmers occasionally
make mistakes.

510
00:30:32,550 --> 00:30:36,190
And so I'm protecting myself
by checking that the

511
00:30:36,190 --> 00:30:39,060
assumptions are met, and
if they're not, my

512
00:30:39,060 --> 00:30:41,960
program will just stop.

513
00:30:41,960 --> 00:30:44,550
Then I can go hunt down the fool
that called it with the

514
00:30:44,550 --> 00:30:46,390
wrong parameters--

515
00:30:46,390 --> 00:30:47,640
probably myself.

516
00:30:47,640 --> 00:30:49,770

517
00:30:49,770 --> 00:30:52,760
So asserts are good for that,
and I'll use them a lot for

518
00:30:52,760 --> 00:30:54,750
these kinds of things.

519
00:30:54,750 --> 00:30:58,590
I'll also use them when I
think I know what value

520
00:30:58,590 --> 00:31:01,030
something should be in a program
at some point, and I'm

521
00:31:01,030 --> 00:31:02,920
not sure it really is.

522
00:31:02,920 --> 00:31:05,710
I'll assert that it has the
value I think it is.

523
00:31:05,710 --> 00:31:09,390
I'll assert that x is six, if I
think it's going to be six.

524
00:31:09,390 --> 00:31:11,840
And then my program will
conveniently stop for me if

525
00:31:11,840 --> 00:31:13,490
it's not true.

526
00:31:13,490 --> 00:31:14,820
All right so that's assert.

527
00:31:14,820 --> 00:31:19,970

528
00:31:19,970 --> 00:31:22,800
Other than that, I think there's
nothing here you

529
00:31:22,800 --> 00:31:24,050
haven't seen before.

530
00:31:24,050 --> 00:31:27,350

531
00:31:27,350 --> 00:31:31,610
So what's going to happen, we're
going to step through

532
00:31:31,610 --> 00:31:33,645
this piece by piece.

533
00:31:33,645 --> 00:31:37,220

534
00:31:37,220 --> 00:31:45,250
So initially, as we look at it,
we enter the main body of

535
00:31:45,250 --> 00:31:49,090
the program, which is not
wrapped in a function.

536
00:31:49,090 --> 00:31:52,210
So what IDLE will do, or the
interpreter will do, is it

537
00:31:52,210 --> 00:31:57,730
will start by executing
each def.

538
00:31:57,730 --> 00:32:01,030
But executing a def doesn't do
anything, but put some names

539
00:32:01,030 --> 00:32:03,570
in the environment.

540
00:32:03,570 --> 00:32:05,910
Then it will go and start
actually running and

541
00:32:05,910 --> 00:32:11,440
interpreting the code that's not
nested inside a function.

542
00:32:11,440 --> 00:32:15,700
So the first thing that will
happen is the interpreter will

543
00:32:15,700 --> 00:32:20,240
build for me what's
called the scope.

544
00:32:20,240 --> 00:32:23,680
I've already mentioned,
that's a mapping

545
00:32:23,680 --> 00:32:27,260
from names to objects.

546
00:32:27,260 --> 00:32:35,881
So in the outermost scope, it
will first find the name f1.

547
00:32:35,881 --> 00:32:41,140

548
00:32:41,140 --> 00:32:46,860
F1 it will tell me that f1 maps
to an object that happens

549
00:32:46,860 --> 00:32:48,110
to be a function.

550
00:32:48,110 --> 00:32:53,180

551
00:32:53,180 --> 00:32:56,270
So it will come over here--

552
00:32:56,270 --> 00:32:59,310
and I'm just going to draw some
picture, we'll assume

553
00:32:59,310 --> 00:33:02,860
that's the memory of
the computer--

554
00:33:02,860 --> 00:33:05,590
and it will map to something
that happens to be a bunch of

555
00:33:05,590 --> 00:33:07,210
code, if you will.

556
00:33:07,210 --> 00:33:08,460
All right?

557
00:33:08,460 --> 00:33:11,190

558
00:33:11,190 --> 00:33:13,060
It will then stop.

559
00:33:13,060 --> 00:33:16,650

560
00:33:16,650 --> 00:33:20,650
It will then notice that it's
got, at the outermost level a

561
00:33:20,650 --> 00:33:21,985
variable called x.

562
00:33:21,985 --> 00:33:26,230

563
00:33:26,230 --> 00:33:30,500
And that will map to an integer,
which will initially

564
00:33:30,500 --> 00:33:32,730
have no value in it.

565
00:33:32,730 --> 00:33:36,830
And then after the assignment,
it will now be bound to the

566
00:33:36,830 --> 00:33:38,800
object three.

567
00:33:38,800 --> 00:33:43,860

568
00:33:43,860 --> 00:33:52,030
It will then create another
object z, but before it can

569
00:33:52,030 --> 00:33:56,250
bind a value to it, it will
invoke the function f1.

570
00:33:56,250 --> 00:33:59,460

571
00:33:59,460 --> 00:34:02,245
Now the interpreter starts
to execute f1.

572
00:34:02,245 --> 00:34:05,460

573
00:34:05,460 --> 00:34:11,659
When it does that, it will
create another scope.

574
00:34:11,659 --> 00:34:13,805
So this is the main scope.

575
00:34:13,805 --> 00:34:18,400

576
00:34:18,400 --> 00:34:22,310
It will next create a scope
called the f1 scope.

577
00:34:22,310 --> 00:34:26,520

578
00:34:26,520 --> 00:34:34,500
In that, it will have another
name g, which will be

579
00:34:34,500 --> 00:34:35,750
bound to some code.

580
00:34:35,750 --> 00:34:42,600

581
00:34:42,600 --> 00:34:49,489
It will have a name x, which
will be initially

582
00:34:49,489 --> 00:34:54,302
bound to the actual.

583
00:34:54,302 --> 00:34:58,750
So in this case, it will be
bound to the object three.

584
00:34:58,750 --> 00:35:06,070

585
00:35:06,070 --> 00:35:08,480
We'll then eventually
do a print.

586
00:35:08,480 --> 00:35:13,205
It will involve g, which will
now create the g scope.

587
00:35:13,205 --> 00:35:21,500

588
00:35:21,500 --> 00:35:29,640
And the g scope will create a
name x, which in this case

589
00:35:29,640 --> 00:35:32,030
will be bound to
the string abc.

590
00:35:32,030 --> 00:35:38,070

591
00:35:38,070 --> 00:35:42,670
It will then start executing
g, and it will stop.

592
00:35:42,670 --> 00:35:45,890

593
00:35:45,890 --> 00:35:47,670
So let's see what
that looks like.

594
00:35:47,670 --> 00:35:53,270

595
00:35:53,270 --> 00:35:55,865
Sure enough, it got an
assert false, gave

596
00:35:55,865 --> 00:35:58,630
an assertion error.

597
00:35:58,630 --> 00:36:05,120
What I can do now is go up to
this debug here, and go to

598
00:36:05,120 --> 00:36:08,810
what's called a stack viewer.

599
00:36:08,810 --> 00:36:15,800
Each of these scopes is what's
called a stack frame.

600
00:36:15,800 --> 00:36:18,890
Now why are they called
stack frames?

601
00:36:18,890 --> 00:36:22,110

602
00:36:22,110 --> 00:36:28,105
Because when we do it, we begin
with the main scope.

603
00:36:28,105 --> 00:36:32,520

604
00:36:32,520 --> 00:36:35,955
We call f, and we
get the scope.

605
00:36:35,955 --> 00:36:38,830

606
00:36:38,830 --> 00:36:42,190
f calls g and we get
the g scope.

607
00:36:42,190 --> 00:36:46,450

608
00:36:46,450 --> 00:36:50,060
When g completes, which alas
it doesn't because of the

609
00:36:50,060 --> 00:36:57,820
error, it pops the stack, and
gets rid of the g scope.

610
00:36:57,820 --> 00:37:02,690
And now the stack is the f and
the main, and then when f

611
00:37:02,690 --> 00:37:06,180
completes, it will have
just the main.

612
00:37:06,180 --> 00:37:09,530
So it's last in, first out,
which is typically called a

613
00:37:09,530 --> 00:37:11,060
stack in computing--

614
00:37:11,060 --> 00:37:13,660

615
00:37:13,660 --> 00:37:18,520
or a LIFO, if you're a course
15 major, and do accounting.

616
00:37:18,520 --> 00:37:22,330
So let's look at the
stack viewer.

617
00:37:22,330 --> 00:37:25,780
And I apologize for the small
type font, but I was unable to

618
00:37:25,780 --> 00:37:28,970
make it look bigger.

619
00:37:28,970 --> 00:37:33,200
So it says at the top we've
got an assertion error.

620
00:37:33,200 --> 00:37:39,240
And then you'll note it's got
three stacks: the main, the f1

621
00:37:39,240 --> 00:37:41,390
stack, and the g stack.

622
00:37:41,390 --> 00:37:44,860
I forgot I called
it f1, not f.

623
00:37:44,860 --> 00:37:47,670
Then I can inspect
them further.

624
00:37:47,670 --> 00:37:52,350
So the g stack has local
and global variables.

625
00:37:52,350 --> 00:37:58,850
The local variables include
x, which is equal to abc.

626
00:37:58,850 --> 00:38:02,310
Globals we'll get to later.

627
00:38:02,310 --> 00:38:10,040
If I look at f1, it also has a
local called x, but its value

628
00:38:10,040 --> 00:38:14,390
is now four, not abc.

629
00:38:14,390 --> 00:38:16,790
And it has a value called
g, which is a

630
00:38:16,790 --> 00:38:21,470
function, as we discussed.

631
00:38:21,470 --> 00:38:32,660
And if I look at main, it has a
bunch of things, but it has

632
00:38:32,660 --> 00:38:35,480
everything that's available in
the interpreter, which because

633
00:38:35,480 --> 00:38:38,200
we've looked at within
epsilon it's there.

634
00:38:38,200 --> 00:38:42,730
But you'll notice it's x is 3.

635
00:38:42,730 --> 00:38:44,340
All right?

636
00:38:44,340 --> 00:38:48,860
So the stack viewer can be very
handy, to look at what

637
00:38:48,860 --> 00:38:50,610
you've got, when you've
got a bunch of calls.

638
00:38:50,610 --> 00:38:53,720

639
00:38:53,720 --> 00:39:00,010
Now if we go back to our code
here, and we'll take this out.

640
00:39:00,010 --> 00:39:07,015
And suppose what we do is
we assert false here.

641
00:39:07,015 --> 00:39:14,510

642
00:39:14,510 --> 00:39:23,980
Now if we look at the stack
viewer, we see that we have f1

643
00:39:23,980 --> 00:39:27,780
in main, but g is
no longer there.

644
00:39:27,780 --> 00:39:29,610
It's gone.

645
00:39:29,610 --> 00:39:32,390
All those variables don't exist
anymore, because I'm no

646
00:39:32,390 --> 00:39:33,640
longer in g.

647
00:39:33,640 --> 00:39:36,090

648
00:39:36,090 --> 00:39:38,400
This is the nice thing, because
it means if you call

649
00:39:38,400 --> 00:39:40,670
something 1,000 times,
it doesn't

650
00:39:40,670 --> 00:39:42,530
use up all your memory.

651
00:39:42,530 --> 00:39:44,920
Every time it's finished,
it gets rid of what

652
00:39:44,920 --> 00:39:46,170
it no longer needs.

653
00:39:46,170 --> 00:39:51,580

654
00:39:51,580 --> 00:39:52,550
All right?

655
00:39:52,550 --> 00:39:54,300
Does that make sense?

656
00:39:54,300 --> 00:39:55,940
This is an important
thing to get--

657
00:39:55,940 --> 00:39:59,036
yeah, thank you, question.

658
00:39:59,036 --> 00:39:59,530
AUDIENCE: --the assertion.

659
00:39:59,530 --> 00:40:00,518
PROFESSOR: Where did I--

660
00:40:00,518 --> 00:40:03,482
AUDIENCE: Where did you put this
other assertion, when you

661
00:40:03,482 --> 00:40:04,470
just changed--

662
00:40:04,470 --> 00:40:05,458
PROFESSOR: Ah, where did I
put the other assertion?

663
00:40:05,458 --> 00:40:15,850
If we look at the code, you'll
see I put it after I call g,

664
00:40:15,850 --> 00:40:22,040
and g is by now returned, but
before I left f1, which is why

665
00:40:22,040 --> 00:40:26,060
the f1 stack is still present.

666
00:40:26,060 --> 00:40:28,810
That makes sense to you?

667
00:40:28,810 --> 00:40:34,320
Which stacks exist, which stack
frames exist, depends

668
00:40:34,320 --> 00:40:37,360
upon which functions
are still active.

669
00:40:37,360 --> 00:40:38,830
Yeah?

670
00:40:38,830 --> 00:40:39,679
AUDIENCE: How come
you don't need a

671
00:40:39,679 --> 00:40:43,430
return under the g function?

672
00:40:43,430 --> 00:40:44,973
PROFESSOR: Oh, because there's
not going to be anything

673
00:40:44,973 --> 00:40:46,080
interesting.

674
00:40:46,080 --> 00:40:47,662
It's useless.

675
00:40:47,662 --> 00:40:48,010
Right?

676
00:40:48,010 --> 00:40:49,750
Why don't I need a
return under g?

677
00:40:49,750 --> 00:40:52,070
Well if I wanted it to do
something useful, I would need

678
00:40:52,070 --> 00:40:53,385
to return something.

679
00:40:53,385 --> 00:40:56,260
But I'd probably also want to
pass it some arguments, rather

680
00:40:56,260 --> 00:40:58,810
than have it take no
arguments, as well.

681
00:40:58,810 --> 00:41:01,290
So it's here just to be the
simplest thing I could put

682
00:41:01,290 --> 00:41:03,450
that created a stack frame.

683
00:41:03,450 --> 00:41:08,250
But don't try and interpre it as
being anything meaningful.

684
00:41:08,250 --> 00:41:09,414
Yeah?

685
00:41:09,414 --> 00:41:11,662
AUDIENCE: Would you run into
problems assuming that g did

686
00:41:11,662 --> 00:41:13,270
something to x and
then returned it?

687
00:41:13,270 --> 00:41:14,716
Would you run into any problems
that you named the

688
00:41:14,716 --> 00:41:17,126
variable the same?

689
00:41:17,126 --> 00:41:18,572
You know, that you
used x twice?

690
00:41:18,572 --> 00:41:19,054
Would you want to--

691
00:41:19,054 --> 00:41:20,030
PROFESSOR: No.

692
00:41:20,030 --> 00:41:24,620
If an x exists, or any variable
exists within a

693
00:41:24,620 --> 00:41:28,540
function body, when you leave
that function, that variable

694
00:41:28,540 --> 00:41:31,010
is gone forever.

695
00:41:31,010 --> 00:41:34,340
These are just names.

696
00:41:34,340 --> 00:41:36,920
They have no intrinsic
meaning.

697
00:41:36,920 --> 00:41:40,900
So one of the ways to think
about it, and we'll see this

698
00:41:40,900 --> 00:41:43,720
later when we get to classes--

699
00:41:43,720 --> 00:41:45,170
a lot later.

700
00:41:45,170 --> 00:41:48,860
You could, if you wanted, think
about this as really the

701
00:41:48,860 --> 00:41:55,000
name g.x, and you could really
think of this as the name of

702
00:41:55,000 --> 00:42:01,710
f1.x, and you could think of
this as the name of main.x,

703
00:42:01,710 --> 00:42:06,090
indicating that they're
really not the same.

704
00:42:06,090 --> 00:42:10,430
But it would be kind of a pain
to write them all that way.

705
00:42:10,430 --> 00:42:11,670
OK?

706
00:42:11,670 --> 00:42:13,650
So different scopes have
different names

707
00:42:13,650 --> 00:42:16,040
available to them.

708
00:42:16,040 --> 00:42:18,810
You can use the names in the
scope, and you have to keep

709
00:42:18,810 --> 00:42:20,700
track of what they mean.

710
00:42:20,700 --> 00:42:23,990

711
00:42:23,990 --> 00:42:24,260
OK?

712
00:42:24,260 --> 00:42:25,110
Any other questions?

713
00:42:25,110 --> 00:42:28,200
These are great questions, and
I really do appreciate them.

714
00:42:28,200 --> 00:42:28,910
Yeah?

715
00:42:28,910 --> 00:42:30,842
AUDIENCE: Does this also
happen with four loops?

716
00:42:30,842 --> 00:42:33,257
Like if you say 4x in
range something,

717
00:42:33,257 --> 00:42:34,706
can you use x later?

718
00:42:34,706 --> 00:42:35,672
Or is it x--

719
00:42:35,672 --> 00:42:36,638
PROFESSOR: You can
use x later.

720
00:42:36,638 --> 00:42:38,087
AUDIENCE: Okay so--

721
00:42:38,087 --> 00:42:40,140
PROFESSOR: x will be available
outside the loop.

722
00:42:40,140 --> 00:42:43,020

723
00:42:43,020 --> 00:42:46,470
This was if you said for x in
something, is x available

724
00:42:46,470 --> 00:42:47,170
outside the loop?

725
00:42:47,170 --> 00:42:48,600
Yes.

726
00:42:48,600 --> 00:42:51,130
And in fact, you'll often want
to test what the final value

727
00:42:51,130 --> 00:42:53,480
of x is, when you
leave the loop.

728
00:42:53,480 --> 00:42:56,810

729
00:42:56,810 --> 00:42:59,650
OK, the next thing on your
handout, and I'm not going to

730
00:42:59,650 --> 00:43:05,520
go over it, is using functions
to implement something that

731
00:43:05,520 --> 00:43:07,480
finds roots.

732
00:43:07,480 --> 00:43:09,630
There's no real point in
my walking you through

733
00:43:09,630 --> 00:43:11,570
this code in class.

734
00:43:11,570 --> 00:43:13,520
I did include it
in the handout.

735
00:43:13,520 --> 00:43:16,500
And by the way, the handouts
are all available after

736
00:43:16,500 --> 00:43:18,910
lecture, online.

737
00:43:18,910 --> 00:43:22,380
Is that, I think you should work
through in your own, and

738
00:43:22,380 --> 00:43:25,340
make sure you understand it,
to get a sense of how

739
00:43:25,340 --> 00:43:26,960
functions work.

740
00:43:26,960 --> 00:43:29,650
And it's certainly related to
the current problem set, which

741
00:43:29,650 --> 00:43:32,190
would be another good reason
to work through it--

742
00:43:32,190 --> 00:43:34,430
the problem set that will
be posted today--

743
00:43:34,430 --> 00:43:38,210
the new problem set, PS 2.

744
00:43:38,210 --> 00:43:42,750
Note again how careful I am
about the specifications.

745
00:43:42,750 --> 00:43:56,600
And I should point out something
interesting, if I

746
00:43:56,600 --> 00:44:02,330
type find root, open para--
well let's do this here.

747
00:44:02,330 --> 00:44:14,070

748
00:44:14,070 --> 00:44:16,910
Let's clear things up.

749
00:44:16,910 --> 00:44:22,210
Let's get rid of things
that will cause

750
00:44:22,210 --> 00:44:23,460
the program to halt.

751
00:44:23,460 --> 00:44:33,190

752
00:44:33,190 --> 00:44:37,740
Notice that when I type find
root open, open paren, it's

753
00:44:37,740 --> 00:44:39,230
given me the values--

754
00:44:39,230 --> 00:44:42,860
the names of the formal
parameters, which I've chosen

755
00:44:42,860 --> 00:44:46,430
in such way that will remind me
what their value should be.

756
00:44:46,430 --> 00:44:51,260
And it's also given me part of
the specification, the piece

757
00:44:51,260 --> 00:44:56,830
in the triple quotation marks
to tell me the rules I'm

758
00:44:56,830 --> 00:44:59,890
supposed to be following
here on these things.

759
00:44:59,890 --> 00:45:02,080
So it's a very handy thing.

760
00:45:02,080 --> 00:45:05,990
And as you use IDLE, you'll get
used to the fact that this

761
00:45:05,990 --> 00:45:09,480
is a convenience.

762
00:45:09,480 --> 00:45:12,290
All right, work your way
through that code.

763
00:45:12,290 --> 00:45:14,820
Make sure you know
what it does.

764
00:45:14,820 --> 00:45:20,670
Finally, today I want to switch
gears, and talk about

765
00:45:20,670 --> 00:45:22,870
something else.

766
00:45:22,870 --> 00:45:26,620
Up till now, all of the programs
we've looked at have

767
00:45:26,620 --> 00:45:28,590
been numeric--

768
00:45:28,590 --> 00:45:30,060
they've played with numbers.

769
00:45:30,060 --> 00:45:33,060
And I've done that, because I
assumed you guys all had some

770
00:45:33,060 --> 00:45:36,420
intuition about numbers.

771
00:45:36,420 --> 00:45:39,890
I've use strings as a primitive
data element to

772
00:45:39,890 --> 00:45:43,250
print things, but we haven't
done anything very interesting

773
00:45:43,250 --> 00:45:44,500
with strings.

774
00:45:44,500 --> 00:45:46,570

775
00:45:46,570 --> 00:45:52,590
However strings are indeed quite
interesting, in that

776
00:45:52,590 --> 00:45:56,910
they're the first non-scalar
value we've looked at.

777
00:45:56,910 --> 00:46:01,250
You'll recall non-scalar values
are values that can be

778
00:46:01,250 --> 00:46:03,880
decomposed.

779
00:46:03,880 --> 00:46:25,110
So if we now look at the code
again, I've got this little

780
00:46:25,110 --> 00:46:28,530
piece of code called
sumDigits.

781
00:46:28,530 --> 00:46:31,500
So before, the for statement
we looked at

782
00:46:31,500 --> 00:46:34,570
was for x in range.

783
00:46:34,570 --> 00:46:42,850
Well you can apply it to a for
statement to any type that has

784
00:46:42,850 --> 00:46:46,110
a way to enumerate
its elements.

785
00:46:46,110 --> 00:46:56,860
So for c in STR, actually of
1952, so I've taken the number

786
00:46:56,860 --> 00:47:01,240
1952 and converted it to a
string so it will now be quote

787
00:47:01,240 --> 00:47:07,110
one nine five two, I can now
do something to every

788
00:47:07,110 --> 00:47:10,780
character in that string.

789
00:47:10,780 --> 00:47:13,840
And what I'm doing is converting
it back to an int,

790
00:47:13,840 --> 00:47:16,010
and then adding it.

791
00:47:16,010 --> 00:47:18,140
So this will give me the
sum of the digits.

792
00:47:18,140 --> 00:47:25,290

793
00:47:25,290 --> 00:47:26,540
17.

794
00:47:26,540 --> 00:47:28,300

795
00:47:28,300 --> 00:47:32,500
This is a very convenient
mechanism, and you'll use for

796
00:47:32,500 --> 00:47:34,270
a lot, this way.

797
00:47:34,270 --> 00:47:36,830
You'll use it in fact more for
this sort of thing then you

798
00:47:36,830 --> 00:47:38,480
will for ints.

799
00:47:38,480 --> 00:47:41,420

800
00:47:41,420 --> 00:47:43,680
Now I can also select values.

801
00:47:43,680 --> 00:47:46,370

802
00:47:46,370 --> 00:47:48,140
So if I look at--

803
00:47:48,140 --> 00:47:57,470

804
00:47:57,470 --> 00:47:59,370
I don't know what's
going on here.

805
00:47:59,370 --> 00:48:02,470
Every once in while when you go
back and forth between the

806
00:48:02,470 --> 00:48:05,910
editor and the shell, the shell
hangs and you have to go

807
00:48:05,910 --> 00:48:07,055
try it again.

808
00:48:07,055 --> 00:48:16,850
If I go to s equals abc, I can
look at individual elements of

809
00:48:16,850 --> 00:48:22,780
s, for example s sub
0, which will be a.

810
00:48:22,780 --> 00:48:25,950
I can also look at
slices of s.

811
00:48:25,950 --> 00:48:28,970
So for example s
from 0 to one.

812
00:48:28,970 --> 00:48:33,920

813
00:48:33,920 --> 00:48:35,950
That's interesting.

814
00:48:35,950 --> 00:48:37,080
What is it doing?

815
00:48:37,080 --> 00:48:38,230
Now try and infer.

816
00:48:38,230 --> 00:48:39,480
I'll give you another example.

817
00:48:39,480 --> 00:48:47,060

818
00:48:47,060 --> 00:48:49,990
So you'll remember when we
did range from x to y, it

819
00:48:49,990 --> 00:48:52,770
went y minus 1.

820
00:48:52,770 --> 00:48:54,455
Same kind of thing is
happening here.

821
00:48:54,455 --> 00:48:58,430

822
00:48:58,430 --> 00:49:02,460
So that's why s from 0 to one
gives me only one character,

823
00:49:02,460 --> 00:49:07,190
but s from 0 to two gives me
the character string ab.

824
00:49:07,190 --> 00:49:17,800
This is what's called slicing,
and it's very common.

825
00:49:17,800 --> 00:49:21,540
What a slice does, is it
makes a new copy--

826
00:49:21,540 --> 00:49:24,970
makes a new object, in this
case-- which is a sub-string

827
00:49:24,970 --> 00:49:26,220
of the original string.

828
00:49:26,220 --> 00:49:30,180

829
00:49:30,180 --> 00:49:32,590
There are many other things
I can do on strings.

830
00:49:32,590 --> 00:49:41,470
I can do something like s.find,
and it will tell me

831
00:49:41,470 --> 00:49:45,230
that b is at position
number one in s.

832
00:49:45,230 --> 00:49:51,440
So use Google, whatever you use,
to find the Python web

833
00:49:51,440 --> 00:49:53,830
page that describe strings, and
it will give you all of

834
00:49:53,830 --> 00:49:56,880
the operations you can do.

835
00:49:56,880 --> 00:49:58,130
And they're quite convenient.

836
00:49:58,130 --> 00:50:02,310

837
00:50:02,310 --> 00:50:05,060
One other scalar type that
you're going to need for the

838
00:50:05,060 --> 00:50:09,520
problem set is tuples, and
that will be discussed in

839
00:50:09,520 --> 00:50:12,300
recitation tomorrow.

840
00:50:12,300 --> 00:50:13,550
OK, thanks a lot.

841
00:50:13,550 --> 00:50:17,727
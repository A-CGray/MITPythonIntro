1
00:00:00,000 --> 00:00:00,530

2
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

3
00:00:02,960 --> 00:00:04,370
Commons license.

4
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

5
00:00:07,410 --> 00:00:11,060
offer high-quality educational
resources for free.

6
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

7
00:00:13,960 --> 00:00:17,890
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:17,890 --> 00:00:19,140
ocw.mit.edu.

9
00:00:19,140 --> 00:00:23,490

10
00:00:23,490 --> 00:00:25,110
PROFESSOR: By way of review,
we're going to

11
00:00:25,110 --> 00:00:27,970
start off with loops.

12
00:00:27,970 --> 00:00:31,990
So, what are two loops that
we've covered in lecture or

13
00:00:31,990 --> 00:00:33,808
two types of loops?

14
00:00:33,808 --> 00:00:35,140
AUDIENCE: FOR and WHILE.

15
00:00:35,140 --> 00:00:37,930

16
00:00:37,930 --> 00:00:38,430
PROFESSOR: OK.

17
00:00:38,430 --> 00:00:38,840
Yeah.

18
00:00:38,840 --> 00:00:39,760
FOR and WHILE.

19
00:00:39,760 --> 00:00:41,690
I'm going to start with WHILE
loops because that's what I

20
00:00:41,690 --> 00:00:42,940
have first.

21
00:00:42,940 --> 00:00:44,770

22
00:00:44,770 --> 00:00:47,020
Can someone walk me through the
syntax of a WHILE loop?

23
00:00:47,020 --> 00:00:52,700

24
00:00:52,700 --> 00:00:54,680
AUDIENCE: WHILE condition.

25
00:00:54,680 --> 00:00:57,540
PROFESSOR: WHILE condition and
what type is this condition?

26
00:00:57,540 --> 00:00:59,160
AUDIENCE: [INAUDIBLE]

27
00:00:59,160 --> 00:00:59,550
PROFESSOR: OK.

28
00:00:59,550 --> 00:01:01,710
And then I have--

29
00:01:01,710 --> 00:01:02,800
AUDIENCE: [INAUDIBLE]

30
00:01:02,800 --> 00:01:08,990
PROFESSOR: And then a block
of code, indicated by

31
00:01:08,990 --> 00:01:10,290
indentation.

32
00:01:10,290 --> 00:01:11,800
OK.

33
00:01:11,800 --> 00:01:15,347
Next question is, what
does this code do?

34
00:01:15,347 --> 00:01:22,652

35
00:01:22,652 --> 00:01:25,590
AUDIENCE:Executes the loop and
returns Boolean values.

36
00:01:25,590 --> 00:01:25,870
PROFESSOR: Right.

37
00:01:25,870 --> 00:01:29,490
That's a little bit
too high level.

38
00:01:29,490 --> 00:01:31,902
Specifically, what does
this loop do?

39
00:01:31,902 --> 00:01:34,663
AUDIENCE: Prints the even
numbers from 2 to 10.

40
00:01:34,663 --> 00:01:35,913
PROFESSOR: Perfect.

41
00:01:35,913 --> 00:01:44,570

42
00:01:44,570 --> 00:01:46,860
That's exactly the kind of
comment we're looking for.

43
00:01:46,860 --> 00:01:49,120
When you're doing your problem
sets or you're just coding in

44
00:01:49,120 --> 00:01:53,560
general, you want to have a
comment that describes in an

45
00:01:53,560 --> 00:01:56,250
abstract way what's going on
in the chunks of code.

46
00:01:56,250 --> 00:02:00,610
You don't want to have
a comment that says

47
00:02:00,610 --> 00:02:05,100
assigns 2 to a.

48
00:02:05,100 --> 00:02:09,340
Continues looping
until a is 10.

49
00:02:09,340 --> 00:02:11,100
Comments like that aren't really
helpful because you can

50
00:02:11,100 --> 00:02:13,040
get that by reading the code.

51
00:02:13,040 --> 00:02:15,080
So that's exactly right.

52
00:02:15,080 --> 00:02:15,860
It's perfect.

53
00:02:15,860 --> 00:02:19,980
I don't have candy to
pass out, though.

54
00:02:19,980 --> 00:02:21,695
Next question is what's the
decrementing function?

55
00:02:21,695 --> 00:02:27,050

56
00:02:27,050 --> 00:02:29,080
The way to think of a
decrementing function is that

57
00:02:29,080 --> 00:02:33,400
it's a statement that moves
the loop closer to

58
00:02:33,400 --> 00:02:35,460
termination.

59
00:02:35,460 --> 00:02:36,640
In this case--

60
00:02:36,640 --> 00:02:37,890
AUDIENCE: 10 minus a.

61
00:02:37,890 --> 00:02:41,800

62
00:02:41,800 --> 00:02:46,030
PROFESSOR: Yeah, 10 minus
a or a plus equal 2.

63
00:02:46,030 --> 00:02:47,985
As we're incrementing a, we're
getting closer and closer to

64
00:02:47,985 --> 00:02:50,038
10 and that's going to cause
us to kick out of the loop.

65
00:02:50,038 --> 00:02:58,420

66
00:02:58,420 --> 00:02:59,980
Next thing.

67
00:02:59,980 --> 00:03:01,290
Is a a good variable name?

68
00:03:01,290 --> 00:03:06,410

69
00:03:06,410 --> 00:03:10,510
The answer is no, otherwise,
I wouldn't have asked it.

70
00:03:10,510 --> 00:03:13,030
But a better variable name
might be even_number.

71
00:03:13,030 --> 00:03:16,000

72
00:03:16,000 --> 00:03:20,140
Because, instead of just a being
an integer, now we know

73
00:03:20,140 --> 00:03:21,720
what it's supposed to represent
in the code.

74
00:03:21,720 --> 00:03:24,550

75
00:03:24,550 --> 00:03:31,230
And it becomes clearer when we
go to execute it or run it.

76
00:03:31,230 --> 00:03:37,180

77
00:03:37,180 --> 00:03:40,970
For loops, same thing.

78
00:03:40,970 --> 00:03:43,970
Could someone walk me through
the syntax for a FOR loop?

79
00:03:43,970 --> 00:03:48,480

80
00:03:48,480 --> 00:03:51,930
And first question, does this
loop do the same thing as a

81
00:03:51,930 --> 00:03:53,180
WHILE loop?

82
00:03:53,180 --> 00:03:59,010

83
00:03:59,010 --> 00:04:01,250
If this is our WHILE
loop, does this

84
00:04:01,250 --> 00:04:02,500
loop do the same thing?

85
00:04:02,500 --> 00:04:05,758

86
00:04:05,758 --> 00:04:07,174
AUDIENCE: Yes.

87
00:04:07,174 --> 00:04:07,646
PROFESSOR: OK.

88
00:04:07,646 --> 00:04:08,850
Let's see.

89
00:04:08,850 --> 00:04:15,060
The WHILE loop printed out 4,
6,8,10 and 12; this is going

90
00:04:15,060 --> 00:04:19,820
to print out, 8 and 10.

91
00:04:19,820 --> 00:04:23,790
The reason is where we have
the increment, right?

92
00:04:23,790 --> 00:04:39,470
If we had done this, they would
print out both the same.

93
00:04:39,470 --> 00:04:40,900
A little aside.

94
00:04:40,900 --> 00:04:42,150
That was a bug I just caught.

95
00:04:42,150 --> 00:04:44,900

96
00:04:44,900 --> 00:04:46,350
Someone walk me through the
syntax for a FOR loop.

97
00:04:46,350 --> 00:04:53,028

98
00:04:53,028 --> 00:04:54,278
AUDIENCE: [INAUDIBLE]

99
00:04:54,278 --> 00:04:57,130

100
00:04:57,130 --> 00:05:02,030
PROFESSOR: A FOR keyword and
then what do we have here?

101
00:05:02,030 --> 00:05:04,690
A variable of some sort.

102
00:05:04,690 --> 00:05:11,250
Then we have in keyword and then
we have this thing here.

103
00:05:11,250 --> 00:05:13,780
We're going to get to tuples
in a second, but this is a

104
00:05:13,780 --> 00:05:16,420
tuple literal.

105
00:05:16,420 --> 00:05:19,270
And for FOR loops, a FOR loop
requires something that is

106
00:05:19,270 --> 00:05:23,530
enumerable, which means that we
can take one element after

107
00:05:23,530 --> 00:05:26,350
the other and assign it
to the variable i.

108
00:05:26,350 --> 00:05:30,030

109
00:05:30,030 --> 00:05:37,450
FOR loops iterate over
enumerable items.

110
00:05:37,450 --> 00:05:39,740
Thank you.

111
00:05:39,740 --> 00:05:40,950
That's exactly what I
was talking about.

112
00:05:40,950 --> 00:05:43,690
If I'm speaking too low, just
jack your thumbs up.

113
00:05:43,690 --> 00:05:47,200

114
00:05:47,200 --> 00:05:50,310
This construction is
inconvenient though.

115
00:05:50,310 --> 00:05:53,520
If we wanted to list all
the numbers that

116
00:05:53,520 --> 00:05:54,630
we wanted to print--

117
00:05:54,630 --> 00:05:56,180
2 to 10 is not too hard.

118
00:05:56,180 --> 00:05:57,430
But let's say we wanted
all the even numbers

119
00:05:57,430 --> 00:05:59,910
between 2 and 100.

120
00:05:59,910 --> 00:06:04,360
I don't want to have to write
out all 50 of those.

121
00:06:04,360 --> 00:06:08,750
So we get to the
range function.

122
00:06:08,750 --> 00:06:09,770
You've seen this before.

123
00:06:09,770 --> 00:06:11,020
We just haven't ever
explained it.

124
00:06:11,020 --> 00:06:13,450

125
00:06:13,450 --> 00:06:17,140
All the range function does is
it takes between one and three

126
00:06:17,140 --> 00:06:22,090
parameters and returns
a list of integers.

127
00:06:22,090 --> 00:06:25,580
So let's say that I pass
it one parameter.

128
00:06:25,580 --> 00:06:27,960
I'm going to give it
the integer 100.

129
00:06:27,960 --> 00:06:31,330
This is going to give
me nothing because I

130
00:06:31,330 --> 00:06:32,580
didn't print it out.

131
00:06:32,580 --> 00:06:37,020

132
00:06:37,020 --> 00:06:42,255
This is going to give
me integers 0 to 99.

133
00:06:42,255 --> 00:06:48,710

134
00:06:48,710 --> 00:06:51,110
If I give it two parameters,
what it's going

135
00:06:51,110 --> 00:06:52,410
to do is give me?

136
00:06:52,410 --> 00:07:00,400
The integers between
1 and 100.

137
00:07:00,400 --> 00:07:02,770
In this case, it starts off
at 1 and it gets to 99.

138
00:07:02,770 --> 00:07:06,050

139
00:07:06,050 --> 00:07:08,120
One important point is that
when you give it two

140
00:07:08,120 --> 00:07:12,570
parameters, the first one is
inclusive and the second

141
00:07:12,570 --> 00:07:13,820
parameter is exclusive.

142
00:07:13,820 --> 00:07:17,290

143
00:07:17,290 --> 00:07:18,640
Does everyone follow that?

144
00:07:18,640 --> 00:07:21,580

145
00:07:21,580 --> 00:07:26,670
Finally, the third form is
with three parameters.

146
00:07:26,670 --> 00:07:32,070
I have a start, an end, start
inclusive, end exclusive, and

147
00:07:32,070 --> 00:07:34,400
then a step.

148
00:07:34,400 --> 00:07:46,030
This will give me all the odd
numbers between 1 and 100.

149
00:07:46,030 --> 00:07:49,530
We can also go in reverse.

150
00:07:49,530 --> 00:07:57,120
If I want to go count down from
100 to 1, I can give it a

151
00:07:57,120 --> 00:07:58,370
negative step.

152
00:07:58,370 --> 00:08:02,570

153
00:08:02,570 --> 00:08:06,040
If you want help on using the
range function, there's a

154
00:08:06,040 --> 00:08:08,860
handy command called help,
which you can type in the

155
00:08:08,860 --> 00:08:10,110
interactive prompt.

156
00:08:10,110 --> 00:08:14,940

157
00:08:14,940 --> 00:08:18,420
This gives you the syntax
for using range.

158
00:08:18,420 --> 00:08:21,680
You can do this for any
function in Python.

159
00:08:21,680 --> 00:08:25,590
It's going to tell you,
here's the name.

160
00:08:25,590 --> 00:08:27,010
Here's a parameter start.

161
00:08:27,010 --> 00:08:28,350
Here's a parameter stop.

162
00:08:28,350 --> 00:08:30,650
Here's a parameter step.

163
00:08:30,650 --> 00:08:33,940
This little arrow here means
this is what it returns, a

164
00:08:33,940 --> 00:08:35,190
list of integers.

165
00:08:35,190 --> 00:08:37,600

166
00:08:37,600 --> 00:08:41,005
When you type help and you see
one of these square brackets

167
00:08:41,005 --> 00:08:43,499
that means the perimeter
is optional.

168
00:08:43,499 --> 00:08:46,560

169
00:08:46,560 --> 00:08:47,680
A start is optional.

170
00:08:47,680 --> 00:08:49,390
Step is optional.

171
00:08:49,390 --> 00:08:51,880
Stop, we always have a stop.

172
00:08:51,880 --> 00:08:54,580
We always know when we're
stopping a range.

173
00:08:54,580 --> 00:08:58,815
That's why we can pass one,
two, or three parameters.

174
00:08:58,815 --> 00:09:02,010
Is anyone confused on that?

175
00:09:02,010 --> 00:09:05,370
AUDIENCE: If you only put stop,
it will start with 0?

176
00:09:05,370 --> 00:09:05,950
PROFESSOR: Right.

177
00:09:05,950 --> 00:09:10,150
If you only put one parameter,
then it will start from 0.

178
00:09:10,150 --> 00:09:11,870
So the start is implicit.

179
00:09:11,870 --> 00:09:14,500

180
00:09:14,500 --> 00:09:15,750
Are we good on this?

181
00:09:15,750 --> 00:09:28,100

182
00:09:28,100 --> 00:09:34,860
So, we can code our FOR loop
like that, which for five

183
00:09:34,860 --> 00:09:37,540
numbers is not too inconvenient,
or is

184
00:09:37,540 --> 00:09:38,150
convenient.

185
00:09:38,150 --> 00:09:43,440
But if we have 500 numbers, it
makes it a lot easier to just

186
00:09:43,440 --> 00:09:47,600
change one end point than
it is to type in

187
00:09:47,600 --> 00:09:48,850
500 numbers, right?

188
00:09:48,850 --> 00:09:51,682

189
00:09:51,682 --> 00:09:52,932
OK.

190
00:09:52,932 --> 00:10:00,628

191
00:10:00,628 --> 00:10:02,616
AUDIENCE: Can you create
a range for floats?

192
00:10:02,616 --> 00:10:06,095
So let's say you want to
do it by float size?

193
00:10:06,095 --> 00:10:07,160
PROFESSOR: That's
a good question.

194
00:10:07,160 --> 00:10:08,560
We should try it.

195
00:10:08,560 --> 00:10:09,986
Why don't we give it a shot?

196
00:10:09,986 --> 00:10:15,160

197
00:10:15,160 --> 00:10:16,970
The question was can we make
a range of floats?

198
00:10:16,970 --> 00:10:19,880

199
00:10:19,880 --> 00:10:28,200
Let's try 1.02 to 10.0.

200
00:10:28,200 --> 00:10:30,240
It'll give us an
answer, right?

201
00:10:30,240 --> 00:10:32,525
But it also gives
us a warning.

202
00:10:32,525 --> 00:10:36,150
It says that an integer
argument is expected.

203
00:10:36,150 --> 00:10:38,837
Let's say I do this.

204
00:10:38,837 --> 00:10:42,250

205
00:10:42,250 --> 00:10:45,070
Will this work?

206
00:10:45,070 --> 00:10:46,370
What's it's going to
do is it's going to

207
00:10:46,370 --> 00:10:48,550
truncate the floats.

208
00:10:48,550 --> 00:10:51,150
It's going to truncate the start
to 1 and it's going to

209
00:10:51,150 --> 00:10:53,290
truncate the end to 10.

210
00:10:53,290 --> 00:10:57,000
Then it'll just return the
integers as required.

211
00:10:57,000 --> 00:10:59,760
So you can, but it doesn't
work the way

212
00:10:59,760 --> 00:11:01,010
you think it would.

213
00:11:01,010 --> 00:11:05,970

214
00:11:05,970 --> 00:11:12,330
Moving on, you hit tuples
in lecture this week.

215
00:11:12,330 --> 00:11:18,080
So we're done with the
old review stuff.

216
00:11:18,080 --> 00:11:19,970
Can anyone tell me
what a tuple is?

217
00:11:19,970 --> 00:11:27,800

218
00:11:27,800 --> 00:11:35,893
It's a non-scalar data type
that can hold many items.

219
00:11:35,893 --> 00:11:38,940

220
00:11:38,940 --> 00:11:40,300
What does non-scalar mean?

221
00:11:40,300 --> 00:11:45,260

222
00:11:45,260 --> 00:11:48,648
AUDIENCE: It's multiple elements
that you can search

223
00:11:48,648 --> 00:11:50,420
individually.

224
00:11:50,420 --> 00:11:51,590
AUDIENCE: It's a field that
you can hold only

225
00:11:51,590 --> 00:11:54,600
one value at a time.

226
00:11:54,600 --> 00:11:55,400
PROFESSOR: You're both right.

227
00:11:55,400 --> 00:11:58,130
A scalar can hold only one
element at a time.

228
00:11:58,130 --> 00:12:02,750
A non-scalar can hold more than
one element at a time.

229
00:12:02,750 --> 00:12:04,910
Tuples are actually the
second scalar data

230
00:12:04,910 --> 00:12:07,080
type that we've seen.

231
00:12:07,080 --> 00:12:08,350
A string is the first.

232
00:12:08,350 --> 00:12:10,255
A string can have multiple
characters.

233
00:12:10,255 --> 00:12:13,250

234
00:12:13,250 --> 00:12:13,990
Tuples are flexible.

235
00:12:13,990 --> 00:12:15,240
We can have tuples of numbers.

236
00:12:15,240 --> 00:12:18,130

237
00:12:18,130 --> 00:12:23,350
This syntax, the parentheses
with a set of elements

238
00:12:23,350 --> 00:12:26,200
separated by commas,
this is the literal

239
00:12:26,200 --> 00:12:29,390
syntax for a tuple.

240
00:12:29,390 --> 00:12:32,280
All we're saying is that my
tuple of numbers has the

241
00:12:32,280 --> 00:12:36,750
approximation of
pi, 2, 1, -100.

242
00:12:36,750 --> 00:12:39,230
We can have tuples of strings.

243
00:12:39,230 --> 00:12:42,600
We can have tuples of anything,
but you'll get to

244
00:12:42,600 --> 00:12:43,850
that in a second.

245
00:12:43,850 --> 00:12:47,108

246
00:12:47,108 --> 00:12:50,590
AUDIENCE: Can you mix the data
types inside of that?

247
00:12:50,590 --> 00:12:52,050
PROFESSOR: Yes, we're going
to get to that.

248
00:12:52,050 --> 00:12:55,390

249
00:12:55,390 --> 00:12:57,230
The question was, can
you mix data types?

250
00:12:57,230 --> 00:12:58,100
The answer is yes.

251
00:12:58,100 --> 00:13:02,140
We'll get to that in a second.

252
00:13:02,140 --> 00:13:05,870
To access individual elements
of a tuple, we do something

253
00:13:05,870 --> 00:13:07,670
called indexing.

254
00:13:07,670 --> 00:13:10,030
We specify an index by--

255
00:13:10,030 --> 00:13:14,350
if I have tuple_of_numbers, my
variable name, I have a left

256
00:13:14,350 --> 00:13:17,290
square bracket and a right
square bracket, and I have an

257
00:13:17,290 --> 00:13:20,440
integer in between.

258
00:13:20,440 --> 00:13:24,710
This would give me the item
in the tuple that

259
00:13:24,710 --> 00:13:27,490
exists at index 0.

260
00:13:27,490 --> 00:13:35,520
Tuples are indexed starting at
0 and in increments of 1.

261
00:13:35,520 --> 00:13:37,410
When I say tuple_of_numbers[0],
what

262
00:13:37,410 --> 00:13:40,590
should this print out?

263
00:13:40,590 --> 00:13:41,940
AUDIENCE: 3.14159.

264
00:13:41,940 --> 00:13:42,700
PROFESSOR: Right.

265
00:13:42,700 --> 00:13:45,900
It will print out 3.14159.

266
00:13:45,900 --> 00:13:49,292
Now if I change this to 1,
what will this print out?

267
00:13:49,292 --> 00:13:51,140
AUDIENCE: 2.

268
00:13:51,140 --> 00:13:53,320
PROFESSOR: Exactly.

269
00:13:53,320 --> 00:13:59,120
It doesn't matter what data type
is contained in tuple.

270
00:13:59,120 --> 00:14:04,340
If it's string, it'll just print
out whatever's here,

271
00:14:04,340 --> 00:14:07,510
which is 'what'.

272
00:14:07,510 --> 00:14:11,260
You can also use negative
indices.

273
00:14:11,260 --> 00:14:15,560
Negative indices tell Python
that I want to go to one past

274
00:14:15,560 --> 00:14:18,360
the end of the tuple.

275
00:14:18,360 --> 00:14:21,040
In this case, tuple_of_
strings, I'm out here

276
00:14:21,040 --> 00:14:24,260
somewhere, and then walk
back 1, or however

277
00:14:24,260 --> 00:14:26,700
many the integer is.

278
00:14:26,700 --> 00:14:28,840
I have here tuple_of_strings
minus 1.

279
00:14:28,840 --> 00:14:32,480
Python's going to go to
somewhere around here and then

280
00:14:32,480 --> 00:14:35,820
walk back one and
give me 'name'.

281
00:14:35,820 --> 00:14:40,890

282
00:14:40,890 --> 00:14:44,090
Now what if I do minus 3?

283
00:14:44,090 --> 00:14:46,910

284
00:14:46,910 --> 00:14:49,440
What's that going
to print out?

285
00:14:49,440 --> 00:14:50,690
Is.

286
00:14:50,690 --> 00:14:57,220

287
00:14:57,220 --> 00:14:59,210
Let's see who is paying
attention.

288
00:14:59,210 --> 00:15:02,190
What's this going to do?

289
00:15:02,190 --> 00:15:03,440
AUDIENCE: [INAUDIBLE]

290
00:15:03,440 --> 00:15:05,690

291
00:15:05,690 --> 00:15:09,490
AUDIENCE: My name,
or name, rather?

292
00:15:09,490 --> 00:15:13,002
PROFESSOR: Remember we index
tuples at 0, right?

293
00:15:13,002 --> 00:15:14,250
AUDIENCE: That's going
to give an error.

294
00:15:14,250 --> 00:15:15,460
PROFESSOR: Exactly.

295
00:15:15,460 --> 00:15:19,210
It's going to tell us
index out of range.

296
00:15:19,210 --> 00:15:24,210
We have four elements in
tuple strings 0, 1, 2,

297
00:15:24,210 --> 00:15:27,070
3, oops, we're off.

298
00:15:27,070 --> 00:15:29,600

299
00:15:29,600 --> 00:15:32,040
You can get outside of a
tuple and get an error.

300
00:15:32,040 --> 00:15:34,660

301
00:15:34,660 --> 00:15:36,526
To avoid that--

302
00:15:36,526 --> 00:15:37,024
sorry?

303
00:15:37,024 --> 00:15:39,020
AUDIENCE: The thing is when you
said for tuple_of_numbers,

304
00:15:39,020 --> 00:15:44,970
you said 1 and 3.141, number,
which would technically be 0

305
00:15:44,970 --> 00:15:46,225
in this case, wouldn't it?

306
00:15:46,225 --> 00:15:47,120
PROFESSOR: No, I switched it.

307
00:15:47,120 --> 00:15:47,860
AUDIENCE: You switched it.

308
00:15:47,860 --> 00:15:49,110
PROFESSOR: Yeah.

309
00:15:49,110 --> 00:15:51,190

310
00:15:51,190 --> 00:15:54,030
Just to make you feel better--

311
00:15:54,030 --> 00:15:54,762
AUDIENCE: I see it now.

312
00:15:54,762 --> 00:15:56,080
PROFESSOR: You got it?

313
00:15:56,080 --> 00:15:57,330
OK.

314
00:15:57,330 --> 00:16:01,610

315
00:16:01,610 --> 00:16:03,230
It's always possible that
I made an error.

316
00:16:03,230 --> 00:16:07,280

317
00:16:07,280 --> 00:16:09,080
In your code, in order to avoid
that, you can check

318
00:16:09,080 --> 00:16:12,170
yourself by getting the length
of tuple_of_numbers.

319
00:16:12,170 --> 00:16:13,470
So there's a function len.

320
00:16:13,470 --> 00:16:17,540

321
00:16:17,540 --> 00:16:18,630
It's going to tell us that

322
00:16:18,630 --> 00:16:20,250
tuple_of_numbers has 6 elements.

323
00:16:20,250 --> 00:16:24,800
We can count them:
1, 2, 3, 4, 5, 6.

324
00:16:24,800 --> 00:16:30,110
What's the last index
of this tuple?

325
00:16:30,110 --> 00:16:31,360
5, right?

326
00:16:31,360 --> 00:16:36,500

327
00:16:36,500 --> 00:16:40,350
Back to your question, tuples
can hold different data types.

328
00:16:40,350 --> 00:16:49,290

329
00:16:49,290 --> 00:16:52,595
They can hold data types that
are different from each other.

330
00:16:52,595 --> 00:16:56,390
I'm wording that improperly.

331
00:16:56,390 --> 00:16:59,280
So, here we have a float
and three strings.

332
00:16:59,280 --> 00:17:02,750
This is a heterogeneous
data structure.

333
00:17:02,750 --> 00:17:04,770
A homogeneous data structure
would be one that you would

334
00:17:04,770 --> 00:17:09,069
say only hold ints only
holds floats.

335
00:17:09,069 --> 00:17:10,810
But tuples are very flexible.

336
00:17:10,810 --> 00:17:13,339
So, we have a float here
and some strings.

337
00:17:13,339 --> 00:17:15,369
Then you could also
have tuples that

338
00:17:15,369 --> 00:17:16,619
contain other tuples.

339
00:17:16,619 --> 00:17:20,030

340
00:17:20,030 --> 00:17:24,260
In this case, how many
elements does

341
00:17:24,260 --> 00:17:26,476
tuple_of_tuples have?

342
00:17:26,476 --> 00:17:28,448
AUDIENCE: 3.

343
00:17:28,448 --> 00:17:31,430
PROFESSOR: 3.

344
00:17:31,430 --> 00:17:36,740
The first element is a tuple,
the second element is 'got',

345
00:17:36,740 --> 00:17:38,470
and the third element
is 'real'.

346
00:17:38,470 --> 00:17:41,240

347
00:17:41,240 --> 00:17:43,865
What should this print out?

348
00:17:43,865 --> 00:17:45,200
AUDIENCE: [INAUDIBLE]

349
00:17:45,200 --> 00:17:46,450
PROFESSOR: Yeah.

350
00:17:46,450 --> 00:17:50,370

351
00:17:50,370 --> 00:17:52,538
I had to sanitize that quote.

352
00:17:52,538 --> 00:17:55,180
AUDIENCE: Why does it print
out the strings?

353
00:17:55,180 --> 00:17:59,270
PROFESSOR: Python's behavior,
when it sees a tuple data type

354
00:17:59,270 --> 00:18:02,980
and you call it with the print
statement, is it represents as

355
00:18:02,980 --> 00:18:06,180
a string a tuple the
way you would

356
00:18:06,180 --> 00:18:11,680
literally write out a tuple.

357
00:18:11,680 --> 00:18:14,010
'Stuff, just' is a tuple
with the two

358
00:18:14,010 --> 00:18:15,990
strings 'stuff' and 'just'.

359
00:18:15,990 --> 00:18:21,680
Python is going to print out the
literal representation of

360
00:18:21,680 --> 00:18:22,930
that tuple.

361
00:18:22,930 --> 00:18:25,410

362
00:18:25,410 --> 00:18:32,640
Another way to try and explain
it, let's say that I print out

363
00:18:32,640 --> 00:18:34,480
the entire tuple.

364
00:18:34,480 --> 00:18:37,760
What should this look like?

365
00:18:37,760 --> 00:18:39,495
Well, It's going to be
just the literal

366
00:18:39,495 --> 00:18:40,745
representation of the tuple.

367
00:18:40,745 --> 00:18:47,600

368
00:18:47,600 --> 00:18:50,645
What does it mean for the data
type to be immutable?

369
00:18:50,645 --> 00:18:59,150

370
00:18:59,150 --> 00:19:00,110
AUDIENCE: You can't change it.

371
00:19:00,110 --> 00:19:02,050
You can't add another
element to it?

372
00:19:02,050 --> 00:19:03,930
PROFESSOR: You can't
change it.

373
00:19:03,930 --> 00:19:09,270
If I try to change the first
element of tuple_of_numbers,

374
00:19:09,270 --> 00:19:10,930
it's going to tell me
it doesn't support--

375
00:19:10,930 --> 00:19:12,750
or Python's going to tell me
it doesn't support item

376
00:19:12,750 --> 00:19:15,510
assignment.

377
00:19:15,510 --> 00:19:16,760
You'll see this error.

378
00:19:16,760 --> 00:19:29,010

379
00:19:29,010 --> 00:19:33,860
Tuples support something called
slicing, which means

380
00:19:33,860 --> 00:19:38,060
that if I have a
tuple_of_numbers

381
00:19:38,060 --> 00:19:39,720
and I give it a--

382
00:19:39,720 --> 00:19:42,580
where I normally put just a
single integer for an index,

383
00:19:42,580 --> 00:19:47,150
if I give it a start index and
an end index, separated by

384
00:19:47,150 --> 00:19:54,060
this colon, Python's going to
get the item at index 1 to

385
00:19:54,060 --> 00:19:58,810
whatever this end element
is minus 1.

386
00:19:58,810 --> 00:20:02,180
It helps if I just
print it out.

387
00:20:02,180 --> 00:20:04,565
To make it a little bit
easier to follow.

388
00:20:04,565 --> 00:20:12,260

389
00:20:12,260 --> 00:20:14,790
I've said I've told Python that
I want a slice out of

390
00:20:14,790 --> 00:20:18,640
this tuple from 1 to 3.

391
00:20:18,640 --> 00:20:23,960
What Python's going to go do is
look into tuple_of_numbers.

392
00:20:23,960 --> 00:20:25,970
This is element 0.

393
00:20:25,970 --> 00:20:29,490
This is index 1; it's
going to pull in 2.

394
00:20:29,490 --> 00:20:32,650
This is index 2; i it's
going to pull in 1.

395
00:20:32,650 --> 00:20:35,200
Then 3--

396
00:20:35,200 --> 00:20:40,730
in Python, we go 1 past the end
of the range that we want.

397
00:20:40,730 --> 00:20:43,320
It's going to return
a tuple of 2, 1.

398
00:20:43,320 --> 00:20:44,570
This is slicing a tuple.

399
00:20:44,570 --> 00:20:48,340

400
00:20:48,340 --> 00:20:50,854
Anyone confused by that?

401
00:20:50,854 --> 00:20:51,750
No?

402
00:20:51,750 --> 00:20:53,000
Wow.

403
00:20:53,000 --> 00:20:55,270

404
00:20:55,270 --> 00:20:57,980
There are many different ways
that we can slice a tuple.

405
00:20:57,980 --> 00:21:01,320
We can have an implicit start.

406
00:21:01,320 --> 00:21:06,520
If you see this, where there's
no number before the colon,

407
00:21:06,520 --> 00:21:09,010
that tells Python start
at index 0.

408
00:21:09,010 --> 00:21:12,760

409
00:21:12,760 --> 00:21:19,820
Then, in complimentary fashion,
if you see this,

410
00:21:19,820 --> 00:21:23,170
where you have an integer on the
left side and nothing on

411
00:21:23,170 --> 00:21:27,120
the right side, it tells Python
go from index 1 all the

412
00:21:27,120 --> 00:21:28,430
way to the end of the tuple.

413
00:21:28,430 --> 00:21:34,410

414
00:21:34,410 --> 00:21:38,253
What happens is I do this?

415
00:21:38,253 --> 00:21:43,920

416
00:21:43,920 --> 00:21:46,920
What's that telling
Python to do?

417
00:21:46,920 --> 00:21:48,390
AUDIENCE: [INAUDIBLE]

418
00:21:48,390 --> 00:21:49,050
PROFESSOR: Yeah.

419
00:21:49,050 --> 00:21:52,960
It looks redundant but it will
become important to us when we

420
00:21:52,960 --> 00:21:56,840
get to lists and something
called aliasing.

421
00:21:56,840 --> 00:21:59,570
What this does is it tells
Python to take a slice that is

422
00:21:59,570 --> 00:22:00,820
the entire tuple.

423
00:22:00,820 --> 00:22:04,250

424
00:22:04,250 --> 00:22:07,280
Then when we do these
slices, we can also

425
00:22:07,280 --> 00:22:09,530
use negative indices.

426
00:22:09,530 --> 00:22:15,220
This is going to tell Python
to go from 0 to the last

427
00:22:15,220 --> 00:22:18,400
element minus 1.

428
00:22:18,400 --> 00:22:19,650
It'll look like that.

429
00:22:19,650 --> 00:22:25,000

430
00:22:25,000 --> 00:22:26,090
Everyone following?

431
00:22:26,090 --> 00:22:27,270
We good?

432
00:22:27,270 --> 00:22:29,065
AUDIENCE: It was minuses
from the end--

433
00:22:29,065 --> 00:22:29,420
PROFESSOR: Yeah.

434
00:22:29,420 --> 00:22:29,806
AUDIENCE: --of the tuple?

435
00:22:29,806 --> 00:22:32,060
PROFESSOR: Okay.

436
00:22:32,060 --> 00:22:34,240
I wonder if this would work?

437
00:22:34,240 --> 00:22:35,490
I don't know.

438
00:22:35,490 --> 00:22:37,530

439
00:22:37,530 --> 00:22:41,530
No, it has unexpected
behavior.

440
00:22:41,530 --> 00:22:42,220
I don't know why.

441
00:22:42,220 --> 00:22:43,470
I'll have to look that up.

442
00:22:43,470 --> 00:22:47,800

443
00:22:47,800 --> 00:22:50,670
Tuples are also--

444
00:22:50,670 --> 00:22:52,020
we already said earlier
that they were

445
00:22:52,020 --> 00:22:53,210
enumerable items, right?

446
00:22:53,210 --> 00:22:55,530
So we can use a FOR
loop with them.

447
00:22:55,530 --> 00:23:00,570
If I want to print out all the
numbers in tuple_of_numbers, I

448
00:23:00,570 --> 00:23:04,840
have my FOR loop, my variable,
in, and then

449
00:23:04,840 --> 00:23:06,090
my enumerable object.

450
00:23:06,090 --> 00:23:10,800

451
00:23:10,800 --> 00:23:12,050
OK?

452
00:23:12,050 --> 00:23:16,970

453
00:23:16,970 --> 00:23:18,220
I have a question now.

454
00:23:18,220 --> 00:23:21,120

455
00:23:21,120 --> 00:23:23,350
Who thinks this will work?

456
00:23:23,350 --> 00:23:24,785
We know that tuples
are immutable.

457
00:23:24,785 --> 00:23:33,427

458
00:23:33,427 --> 00:23:33,918
AUDIENCE: Yeah.

459
00:23:33,918 --> 00:23:35,890
But you have to change
the inside.

460
00:23:35,890 --> 00:23:37,840
PROFESSOR: Right.

461
00:23:37,840 --> 00:23:39,090
It's going to work.

462
00:23:39,090 --> 00:23:41,633

463
00:23:41,633 --> 00:23:43,355
I still have print up here.

464
00:23:43,355 --> 00:23:46,960

465
00:23:46,960 --> 00:23:49,540
What I'm doing is I'm taking
tuple_of_numbers and I'm

466
00:23:49,540 --> 00:23:51,480
printing before.

467
00:23:51,480 --> 00:23:55,740
Then what I'm doing here is
I'm telling Python to take

468
00:23:55,740 --> 00:24:02,130
this tuple and this tuple and
add them together and reassign

469
00:24:02,130 --> 00:24:03,380
it back to tuple_of_numbers.

470
00:24:03,380 --> 00:24:06,630

471
00:24:06,630 --> 00:24:11,910
So, It looks like I'm
modifying the tuple.

472
00:24:11,910 --> 00:24:15,170
But in reality, what's
happening is I'm

473
00:24:15,170 --> 00:24:16,420
creating a new tuple.

474
00:24:16,420 --> 00:24:20,130

475
00:24:20,130 --> 00:24:23,170
Let's say I have ton here.

476
00:24:23,170 --> 00:24:26,660
Ton is short for
tuple_of_numers.

477
00:24:26,660 --> 00:24:32,110
Originally, it's telling Python
that some chunk of

478
00:24:32,110 --> 00:24:39,320
memory has a tuple
of 1, 2, 3, 4.

479
00:24:39,320 --> 00:24:47,090
When I say a statement like
ton equal ton plus another

480
00:24:47,090 --> 00:24:51,740
tuple, what it's telling Python
to do is create another

481
00:24:51,740 --> 00:24:58,730
chunk of memory that includes
ton, whatever's in ton, and

482
00:24:58,730 --> 00:24:59,980
the other tuple.

483
00:24:59,980 --> 00:25:03,730

484
00:25:03,730 --> 00:25:07,540
Then this assignment statement
tells Python that ton now

485
00:25:07,540 --> 00:25:10,965
points to this new object.

486
00:25:10,965 --> 00:25:13,857
You had a question?

487
00:25:13,857 --> 00:25:16,671
AUDIENCE:Does Python have
a garbage collector?

488
00:25:16,671 --> 00:25:19,350
PROFESSOR: It's an advanced
question.

489
00:25:19,350 --> 00:25:23,190
The question was, does Python
have a garbage collector to

490
00:25:23,190 --> 00:25:25,860
discard this memory that's
no longer being used.

491
00:25:25,860 --> 00:25:27,660
The answer is yes.

492
00:25:27,660 --> 00:25:29,740
If you don't know what a garbage
collector is, don't

493
00:25:29,740 --> 00:25:30,220
worry about it.

494
00:25:30,220 --> 00:25:31,230
You don't need to.

495
00:25:31,230 --> 00:25:34,230
But to answer your question,
yes, it does.

496
00:25:34,230 --> 00:25:38,166

497
00:25:38,166 --> 00:25:40,668
I don't want to get
too far into it.

498
00:25:40,668 --> 00:25:43,300

499
00:25:43,300 --> 00:25:45,870
Does everyone follow that?

500
00:25:45,870 --> 00:25:48,365
That also is going to be
important when we get to lists

501
00:25:48,365 --> 00:25:53,250
and aliasing, that type of
object creation modification.

502
00:25:53,250 --> 00:25:57,350

503
00:25:57,350 --> 00:25:59,400
We won't get to that
for a while.

504
00:25:59,400 --> 00:26:00,410
Everyone's good with this?

505
00:26:00,410 --> 00:26:01,722
I can move on?

506
00:26:01,722 --> 00:26:02,972
All right.

507
00:26:02,972 --> 00:26:04,850

508
00:26:04,850 --> 00:26:11,200
Python has what some might
consider a wart,

509
00:26:11,200 --> 00:26:13,840
when it comes to tuples.

510
00:26:13,840 --> 00:26:17,410
That is when you want to create
a tuple with a single

511
00:26:17,410 --> 00:26:18,660
element in it.

512
00:26:18,660 --> 00:26:23,370

513
00:26:23,370 --> 00:26:28,680
People just starting out with
Python would sometimes mistake

514
00:26:28,680 --> 00:26:32,272
the tuple literal of a single
element to be this: So,

515
00:26:32,272 --> 00:26:34,730
parenthesis with a
single integer.

516
00:26:34,730 --> 00:26:37,850
The problem is that parentheses
are the grouping

517
00:26:37,850 --> 00:26:40,460
operatorS in Python,
but they're also

518
00:26:40,460 --> 00:26:41,940
used for making tuples.

519
00:26:41,940 --> 00:26:45,220
They serve a dual purpose.

520
00:26:45,220 --> 00:26:48,880
What Python will say is, oh,
I've got a number between two

521
00:26:48,880 --> 00:26:49,910
parentheses.

522
00:26:49,910 --> 00:26:52,530
Well, this person really wants
this integer to have high

523
00:26:52,530 --> 00:26:54,010
precedence.

524
00:26:54,010 --> 00:26:57,380
We're going to make an integer
50 and assign it to oopsie.

525
00:26:57,380 --> 00:26:59,880
But it's not what we want.

526
00:26:59,880 --> 00:27:04,660
We want a tuple with
50 as one element.

527
00:27:04,660 --> 00:27:09,780
The way you do that is you have
a lone comma after the

528
00:27:09,780 --> 00:27:11,030
first element.

529
00:27:11,030 --> 00:27:13,600

530
00:27:13,600 --> 00:27:16,610
If we run this and we look at
what it prints out, you see

531
00:27:16,610 --> 00:27:20,900
that oopsie has the integer 50,
which is not what we want.

532
00:27:20,900 --> 00:27:22,150
We want what's in onesie.

533
00:27:22,150 --> 00:27:34,460

534
00:27:34,460 --> 00:27:35,710
Anyone confused by that?

535
00:27:35,710 --> 00:27:40,250

536
00:27:40,250 --> 00:27:41,675
We're zooming along here.

537
00:27:41,675 --> 00:27:45,720

538
00:27:45,720 --> 00:27:51,990
Strings, they're actually
a lot like tuples.

539
00:27:51,990 --> 00:27:52,970
They're immutable.

540
00:27:52,970 --> 00:27:54,420
You can't change them.

541
00:27:54,420 --> 00:27:57,150
They're non-scalar.

542
00:27:57,150 --> 00:28:00,520
They have multiple characters
within them.

543
00:28:00,520 --> 00:28:03,310
If I printed out-- everyone's
seen this--

544
00:28:03,310 --> 00:28:05,850
I can get to individual
characters.

545
00:28:05,850 --> 00:28:10,650
If I want to get to the first
character in name, I use 0.

546
00:28:10,650 --> 00:28:13,080
If I want to get to the second
character, I can use 1.

547
00:28:13,080 --> 00:28:23,940

548
00:28:23,940 --> 00:28:26,300
Then of course they're
immutable, so that's going to

549
00:28:26,300 --> 00:28:27,550
tell me that I can't do that.

550
00:28:27,550 --> 00:28:36,650

551
00:28:36,650 --> 00:28:37,960
They also support iteration.

552
00:28:37,960 --> 00:28:41,040

553
00:28:41,040 --> 00:28:45,430
So, if I want to print out all
the letters in name, one on

554
00:28:45,430 --> 00:28:48,410
each line, I can do this.

555
00:28:48,410 --> 00:28:54,010
Not too useful, but it works.

556
00:28:54,010 --> 00:28:56,224
You looked confused.

557
00:28:56,224 --> 00:28:58,880
AUDIENCE: How did that happen?

558
00:28:58,880 --> 00:29:00,130
PROFESSOR: How did
that happen?

559
00:29:00,130 --> 00:29:03,450

560
00:29:03,450 --> 00:29:04,740
So, name is a string.

561
00:29:04,740 --> 00:29:06,320
Follow that?

562
00:29:06,320 --> 00:29:09,030
String is just a bunch
of characters.

563
00:29:09,030 --> 00:29:13,170

564
00:29:13,170 --> 00:29:17,470
It is enumerable, meaning that
we can go one character at a

565
00:29:17,470 --> 00:29:19,410
time through the string.

566
00:29:19,410 --> 00:29:24,320

567
00:29:24,320 --> 00:29:25,715
That's what the FOR loop does.

568
00:29:25,715 --> 00:29:28,390

569
00:29:28,390 --> 00:29:30,810
AUDIENCE: Do spaces count
as characters?

570
00:29:30,810 --> 00:29:31,082
PROFESSOR: Good.

571
00:29:31,082 --> 00:29:33,600
The question was do spaces
count as characters.

572
00:29:33,600 --> 00:29:35,840
The answer is yes, they do.

573
00:29:35,840 --> 00:29:48,880
If I write spaces there and I
run this again, as I iterate

574
00:29:48,880 --> 00:29:52,830
through the string, I get a
space where I'm supposed to.

575
00:29:52,830 --> 00:30:01,430

576
00:30:01,430 --> 00:30:03,370
Is everyone good with this?

577
00:30:03,370 --> 00:30:04,620
OK.

578
00:30:04,620 --> 00:30:06,990

579
00:30:06,990 --> 00:30:09,370
Like tuples, you can
take slices.

580
00:30:09,370 --> 00:30:15,330

581
00:30:15,330 --> 00:30:16,580
That's going to give me 'it'.

582
00:30:16,580 --> 00:30:19,090

583
00:30:19,090 --> 00:30:24,495
Strings also have
many functions.

584
00:30:24,495 --> 00:30:28,550

585
00:30:28,550 --> 00:30:32,110
This is an incomplete list of
functions that you can use on

586
00:30:32,110 --> 00:30:34,030
string objects.

587
00:30:34,030 --> 00:30:43,880
I can make everything uppercase,
lowercase.

588
00:30:43,880 --> 00:30:49,920

589
00:30:49,920 --> 00:30:52,405
I can also find characters.

590
00:30:52,405 --> 00:31:01,000

591
00:31:01,000 --> 00:31:05,570
What find does is it
finds the index of

592
00:31:05,570 --> 00:31:06,970
the left-most character.

593
00:31:06,970 --> 00:31:13,150
If I want to find i, it returns
1, because i is at

594
00:31:13,150 --> 00:31:16,320
index 1 in the string.

595
00:31:16,320 --> 00:31:19,540
I could also do something
like this.

596
00:31:19,540 --> 00:31:23,990
I can find an entire string.

597
00:31:23,990 --> 00:31:27,350
'tch', the substring,
starts at index 2.

598
00:31:27,350 --> 00:31:33,110

599
00:31:33,110 --> 00:31:36,000
AUDIENCE: What does it return
if it can't find it?

600
00:31:36,000 --> 00:31:39,260
PROFESSOR: If it doesn't
find it--

601
00:31:39,260 --> 00:31:40,510
let's put in garbage--

602
00:31:40,510 --> 00:31:43,850

603
00:31:43,850 --> 00:31:45,100
you get negative 1.

604
00:31:45,100 --> 00:31:55,320

605
00:31:55,320 --> 00:31:57,420
We can also call a
replace function.

606
00:31:57,420 --> 00:31:59,530
If I want to replace
m with p--

607
00:31:59,530 --> 00:32:02,510

608
00:32:02,510 --> 00:32:06,290
it doesn't make sense
anymore--

609
00:32:06,290 --> 00:32:07,255
I can do that.

610
00:32:07,255 --> 00:32:09,580
The question is, how would I use
this to change the string?

611
00:32:09,580 --> 00:32:14,080

612
00:32:14,080 --> 00:32:18,410
Think back to how we
modified the tuple.

613
00:32:18,410 --> 00:32:21,040
We created a new object and
then we assigned it to a

614
00:32:21,040 --> 00:32:24,570
variable of the same name.

615
00:32:24,570 --> 00:32:26,970
If I know that replace is going
to return a string with

616
00:32:26,970 --> 00:32:36,625
m replaced, I can do that.

617
00:32:36,625 --> 00:32:46,070

618
00:32:46,070 --> 00:32:47,320
Does everyone follow that?

619
00:32:47,320 --> 00:32:49,750

620
00:32:49,750 --> 00:32:50,925
AUDIENCE: Is the version
that that

621
00:32:50,925 --> 00:32:52,570
captures your string function?

622
00:32:52,570 --> 00:32:54,500
PROFESSOR: That's
a good question.

623
00:32:54,500 --> 00:32:58,020
That also gives me a perfect
opportunity to demonstrate

624
00:32:58,020 --> 00:33:00,920
another command that you'll
find helpful.

625
00:33:00,920 --> 00:33:04,740
If you're working with an object
like string, you can

626
00:33:04,740 --> 00:33:07,650
use a command in the interactive
editor called dir.

627
00:33:07,650 --> 00:33:15,320
If you type dir str, it's going
to return all of the

628
00:33:15,320 --> 00:33:18,470
symbols that exist within
the str object.

629
00:33:18,470 --> 00:33:24,110
You can also type help str, and
it will give you a nicer

630
00:33:24,110 --> 00:33:25,360
version of this.

631
00:33:25,360 --> 00:33:28,260

632
00:33:28,260 --> 00:33:30,347
AUDIENCE: In this case, the
first character indicates what

633
00:33:30,347 --> 00:33:32,236
you're trying to replace and
the second is what you're

634
00:33:32,236 --> 00:33:35,230
replacing it with?

635
00:33:35,230 --> 00:33:35,780
PROFESSOR: Right.

636
00:33:35,780 --> 00:33:41,350
We can do help str replace,
and it'll tell us.

637
00:33:41,350 --> 00:33:41,827
AUDIENCE: OK.

638
00:33:41,827 --> 00:33:44,689
So it did one.

639
00:33:44,689 --> 00:33:47,074
And then the count in this
case would be if you had

640
00:33:47,074 --> 00:33:49,460
multiple instances?

641
00:33:49,460 --> 00:33:49,940
PROFESSOR: Yes.

642
00:33:49,940 --> 00:33:50,082
AUDIENCE: OK.

643
00:33:50,082 --> 00:33:52,106
So like if you had your name
a couple times, you could

644
00:33:52,106 --> 00:33:53,940
replace it a few times.

645
00:33:53,940 --> 00:33:54,900
PROFESSOR: Right.

646
00:33:54,900 --> 00:33:58,720
If I were particularly
narcissistic that day, I could

647
00:33:58,720 --> 00:34:00,730
replace it multiple times.

648
00:34:00,730 --> 00:34:03,570
So let's demonstrate
that because some

649
00:34:03,570 --> 00:34:04,820
people might be confused.

650
00:34:04,820 --> 00:34:07,150

651
00:34:07,150 --> 00:34:11,389
Let's say, I want
to replace t.

652
00:34:11,389 --> 00:34:17,230

653
00:34:17,230 --> 00:34:18,480
I'm going to replace
it with r.

654
00:34:18,480 --> 00:34:25,909

655
00:34:25,909 --> 00:34:27,650
Whoops.

656
00:34:27,650 --> 00:34:29,780
Well, why didn't it replace
these to t's here?

657
00:34:29,780 --> 00:34:33,119

658
00:34:33,119 --> 00:34:35,510
AUDIENCE: [INAUDIBLE]

659
00:34:35,510 --> 00:34:36,850
PROFESSOR: Right.

660
00:34:36,850 --> 00:34:38,030
In strings, you differentiate
between

661
00:34:38,030 --> 00:34:39,280
lowercase and uppercase.

662
00:34:39,280 --> 00:34:41,370

663
00:34:41,370 --> 00:34:44,780
If I wanted to get the behavior
that I was hoping

664
00:34:44,780 --> 00:34:48,810
for, I could do it this way.

665
00:34:48,810 --> 00:34:55,659

666
00:34:55,659 --> 00:34:57,400
Now I have something that's
not even remotely

667
00:34:57,400 --> 00:34:59,600
looking like English.

668
00:34:59,600 --> 00:35:02,200
Or, I could do something
like this.

669
00:35:02,200 --> 00:35:05,860

670
00:35:05,860 --> 00:35:11,640
I'm going to make everything
lowercase, and

671
00:35:11,640 --> 00:35:13,035
then replace the t.

672
00:35:13,035 --> 00:35:16,674

673
00:35:16,674 --> 00:35:18,361
AUDIENCE: So that's
pretty exact that

674
00:35:18,361 --> 00:35:21,020
you have to be, lower--

675
00:35:21,020 --> 00:35:23,600
PROFESSOR: Remember what I said
first recitation that

676
00:35:23,600 --> 00:35:25,920
computers will do exactly what
you tell them to do and

677
00:35:25,920 --> 00:35:27,170
nothing more or less.

678
00:35:27,170 --> 00:35:29,910

679
00:35:29,910 --> 00:35:31,962
There we go.

680
00:35:31,962 --> 00:35:32,870
AUDIENCE: It's good though.

681
00:35:32,870 --> 00:35:34,690
It figured out [INAUDIBLE]

682
00:35:34,690 --> 00:35:37,640
PROFESSOR: Python is a
very nice language.

683
00:35:37,640 --> 00:35:40,310
It's one of my favorite
languages right now.

684
00:35:40,310 --> 00:35:45,000
Because, it's not as fussy as
some other languages, like

685
00:35:45,000 --> 00:35:52,850
MATLAB or C or C++ or TCL.

686
00:35:52,850 --> 00:35:54,890
Anyone of those.

687
00:35:54,890 --> 00:35:57,490
Is everyone good on strings?

688
00:35:57,490 --> 00:35:58,930
I can move on?

689
00:35:58,930 --> 00:36:01,390
Just remember, if you need help
on any of these commands,

690
00:36:01,390 --> 00:36:03,609
just remember you have the help
command at your disposal.

691
00:36:03,609 --> 00:36:05,445
AUDIENCE: It'll automatically
default to do everything,

692
00:36:05,445 --> 00:36:08,660
unless you tell it something to
do like two of the letters.

693
00:36:08,660 --> 00:36:10,600
PROFESSOR: Yes.

694
00:36:10,600 --> 00:36:13,630
We didn't demonstrate that.

695
00:36:13,630 --> 00:36:15,460
Demonstrations are worth
a thousand words.

696
00:36:15,460 --> 00:36:19,030
If I wanted to, for whatever
reason, only replace the first

697
00:36:19,030 --> 00:36:22,230
two t's, I could tell it to only
replace two t's within

698
00:36:22,230 --> 00:36:23,480
the string.

699
00:36:23,480 --> 00:36:26,570

700
00:36:26,570 --> 00:36:29,872
It leaves the other t alone.

701
00:36:29,872 --> 00:36:33,275
AUDIENCE: How would you pick
out the last field?

702
00:36:33,275 --> 00:36:34,525
PROFESSOR: That's
a good question.

703
00:36:34,525 --> 00:36:37,560

704
00:36:37,560 --> 00:36:38,860
I don't have a ready
answer for you.

705
00:36:38,860 --> 00:36:49,310

706
00:36:49,310 --> 00:36:55,610
You see these functions with
r in front of them?

707
00:36:55,610 --> 00:37:01,620
The string object often has
functions that will start from

708
00:37:01,620 --> 00:37:03,780
the right side as opposed
to the left side.

709
00:37:03,780 --> 00:37:09,390
The find command I showed you
has an rfind command as well.

710
00:37:09,390 --> 00:37:10,960
This guy right here.

711
00:37:10,960 --> 00:37:18,040
I'm pointing on if there is
the analog to replace.

712
00:37:18,040 --> 00:37:20,420
Can I get back to you?

713
00:37:20,420 --> 00:37:22,590
I don't want to spend all our
time searching for this and

714
00:37:22,590 --> 00:37:23,840
then fail spectacularly.

715
00:37:23,840 --> 00:37:26,550

716
00:37:26,550 --> 00:37:28,870
I'll get back to you on that.

717
00:37:28,870 --> 00:37:29,780
Is it possible?

718
00:37:29,780 --> 00:37:30,120
Yeah.

719
00:37:30,120 --> 00:37:33,100
Is there a one-liner function?

720
00:37:33,100 --> 00:37:34,350
I can't tell you
at the moment.

721
00:37:34,350 --> 00:37:39,960

722
00:37:39,960 --> 00:37:41,960
But again, that's why you
have dir and help.

723
00:37:41,960 --> 00:37:43,390
You can find this
out on your own.

724
00:37:43,390 --> 00:37:49,940

725
00:37:49,940 --> 00:37:53,600
Next thing, BREAK.

726
00:37:53,600 --> 00:37:54,770
We're done with strings.

727
00:37:54,770 --> 00:37:56,480
We're done with tuples.

728
00:37:56,480 --> 00:37:58,430
We're still working on loops.

729
00:37:58,430 --> 00:38:01,200
Everyone's seen this function
before, right?

730
00:38:01,200 --> 00:38:09,030
This is our find-the-cube-ro
ot-of-a-perfect-cube function.

731
00:38:09,030 --> 00:38:13,510
If I give it 27, and I tell
Python to stop printing my

732
00:38:13,510 --> 00:38:25,440
name, that's what this does.

733
00:38:25,440 --> 00:38:31,180
As a toy example to illustrate
the BREAK statement--

734
00:38:31,180 --> 00:38:33,940
first of all, can someone tell
me in English what the BREAK

735
00:38:33,940 --> 00:38:35,810
statement does?

736
00:38:35,810 --> 00:38:39,830
AUDIENCE: Would it just
stop the program.

737
00:38:39,830 --> 00:38:41,520
PROFESSOR: Well, It doesn't stop
the program, but it kicks

738
00:38:41,520 --> 00:38:42,770
you out of the loop.

739
00:38:42,770 --> 00:38:46,620

740
00:38:46,620 --> 00:38:54,630
We can rewrite the cube root
program to work like this.

741
00:38:54,630 --> 00:39:00,260
Instead of our stopping criteria
being answer cubed

742
00:39:00,260 --> 00:39:03,980
less than the absolute value
of the number, we're just

743
00:39:03,980 --> 00:39:10,540
going to tell the FOR loop to
go from a range 0 to the

744
00:39:10,540 --> 00:39:13,200
absolute value of the
input plus 1.

745
00:39:13,200 --> 00:39:14,841
Why do we have the
plus 1 there?

746
00:39:14,841 --> 00:39:17,550
AUDIENCE: So it goes to the
absolute value of x.

747
00:39:17,550 --> 00:39:17,980
PROFESSOR: Yeah.

748
00:39:17,980 --> 00:39:20,570
Because, otherwise, it would
go to 1 before the absolute

749
00:39:20,570 --> 00:39:22,800
value of x.

750
00:39:22,800 --> 00:39:27,850
Then we break out of this loop,
if answer cubed is equal

751
00:39:27,850 --> 00:39:28,970
to absolute value of x.

752
00:39:28,970 --> 00:39:33,590
As soon as we see that it's
equal to x, we're going to

753
00:39:33,590 --> 00:39:34,890
call BREAK.

754
00:39:34,890 --> 00:39:38,150
That's going to immediately kick
us out to here, without

755
00:39:38,150 --> 00:39:39,890
executing any more
of the FOR loop.

756
00:39:39,890 --> 00:39:47,170

757
00:39:47,170 --> 00:39:49,240
Do people understand that?

758
00:39:49,240 --> 00:39:51,194
Are people good with that?

759
00:39:51,194 --> 00:39:51,634
AUDIENCE: Does it break you
of the innermost loop? or

760
00:39:51,634 --> 00:39:54,120
[INAUDIBLE]

761
00:39:54,120 --> 00:39:55,170
PROFESSOR: Yes.

762
00:39:55,170 --> 00:39:57,180
Good question.

763
00:39:57,180 --> 00:39:58,590
Does it break you out
of the innermost

764
00:39:58,590 --> 00:40:00,320
loop or all the loops?

765
00:40:00,320 --> 00:40:02,710
The answer is the
innermost loop.

766
00:40:02,710 --> 00:40:04,520
When he says innermost,
what he's talking

767
00:40:04,520 --> 00:40:06,040
about are nested loops.

768
00:40:06,040 --> 00:40:08,922
Let's say I have something
like this.

769
00:40:08,922 --> 00:40:17,110
I'm creating on the fly
now, so excuse my

770
00:40:17,110 --> 00:40:18,360
inability to type.

771
00:40:18,360 --> 00:40:45,060

772
00:40:45,060 --> 00:40:47,420
What is this going to do?

773
00:40:47,420 --> 00:40:51,320
This is an example
of a nested loop.

774
00:40:51,320 --> 00:40:54,200
We have an outer loop
here, then we have

775
00:40:54,200 --> 00:40:55,450
an inner loop here.

776
00:40:55,450 --> 00:40:58,110

777
00:40:58,110 --> 00:41:00,640
All the outer loop is doing is
it's going from the integers

778
00:41:00,640 --> 00:41:02,940
0, 1, 2, 3 to 9.

779
00:41:02,940 --> 00:41:05,730

780
00:41:05,730 --> 00:41:08,700
And then we have an inner loop,
which looks like it

781
00:41:08,700 --> 00:41:13,190
should go from the integers
10 to 100.

782
00:41:13,190 --> 00:41:19,000
But we have the statement
in here if j mod 2--

783
00:41:19,000 --> 00:41:21,990
that's what the percent
sign is, modulus--

784
00:41:21,990 --> 00:41:23,460
is equal to 0.

785
00:41:23,460 --> 00:41:28,700
What we're saying is if j is
evenly divisible by 2, we're

786
00:41:28,700 --> 00:41:30,990
going to break.

787
00:41:30,990 --> 00:41:32,240
Now, the question is--

788
00:41:32,240 --> 00:41:38,610

789
00:41:38,610 --> 00:41:46,130
this is obviously going
to break when j is 10.

790
00:41:46,130 --> 00:41:47,660
This loop is going
to execute once.

791
00:41:47,660 --> 00:41:50,820

792
00:41:50,820 --> 00:42:02,045
The question is does it print
out only one set of i,j

793
00:42:02,045 --> 00:42:04,180
values, or does it
print out 10?

794
00:42:04,180 --> 00:42:08,200

795
00:42:08,200 --> 00:42:09,920
I'm getting to the answer
to this question.

796
00:42:09,920 --> 00:42:12,820
If BREAK statement breaks out
of all the loops, then we

797
00:42:12,820 --> 00:42:16,710
would only see one printout
of i and j.

798
00:42:16,710 --> 00:42:19,350
But if it only breaks out of
this inner loop, then we

799
00:42:19,350 --> 00:42:25,180
should see 10, followed
by 'here'.

800
00:42:25,180 --> 00:42:28,080
So it breaks out of
the inner loop.

801
00:42:28,080 --> 00:42:29,330
Long answer, but
demonstration.

802
00:42:29,330 --> 00:42:31,876

803
00:42:31,876 --> 00:42:33,195
Is anyone confused by that?

804
00:42:33,195 --> 00:42:38,620

805
00:42:38,620 --> 00:42:39,900
Is so, anyone too
shy to admit it?

806
00:42:39,900 --> 00:42:43,150

807
00:42:43,150 --> 00:42:44,400
There's office hours.

808
00:42:44,400 --> 00:42:47,150

809
00:42:47,150 --> 00:42:48,400
Or, you can talk to
me afterwards.

810
00:42:48,400 --> 00:42:58,030

811
00:42:58,030 --> 00:43:00,810
PROFESSOR: Now we're going to
get to functions, which are

812
00:43:00,810 --> 00:43:03,010
triple underlined and circled
over here because they're

813
00:43:03,010 --> 00:43:04,660
extraordinarily important
for you to understand.

814
00:43:04,660 --> 00:43:07,280

815
00:43:07,280 --> 00:43:10,040
Can someone wing it and
tell me what they

816
00:43:10,040 --> 00:43:11,290
think a function is?

817
00:43:11,290 --> 00:43:19,778

818
00:43:19,778 --> 00:43:21,236
AUDIENCE: It's a snippet of code
that takes some input,

819
00:43:21,236 --> 00:43:23,690
does something to it, and
returns some output.

820
00:43:23,690 --> 00:43:25,020
PROFESSOR: Perfect.

821
00:43:25,020 --> 00:43:26,780
It's a bit of code.

822
00:43:26,780 --> 00:43:28,810
It's named, so you
can refer to it.

823
00:43:28,810 --> 00:43:32,930
It takes input, does something
with it, and returns

824
00:43:32,930 --> 00:43:36,130
something, some value.

825
00:43:36,130 --> 00:43:42,240
The way that we define a
function in Python is like so.

826
00:43:42,240 --> 00:43:47,100
Let's say I have a
function cube.

827
00:43:47,100 --> 00:43:48,920
It consists of a few parts.

828
00:43:48,920 --> 00:43:52,330
We've got the DEF keyword.

829
00:43:52,330 --> 00:43:54,170
We've got a name, cube.

830
00:43:54,170 --> 00:43:55,950
The name should be meaningful
for functions.

831
00:43:55,950 --> 00:43:59,780
Like variables, the name should
mean something So, this

832
00:43:59,780 --> 00:44:03,720
would be a bad name
for this function.

833
00:44:03,720 --> 00:44:05,465
You want it to be meaningful.

834
00:44:05,465 --> 00:44:07,520
It has a set of parameters.

835
00:44:07,520 --> 00:44:10,270
In this case, it only
has one parameter.

836
00:44:10,270 --> 00:44:16,720
This is what we pass to the
function when we call it.

837
00:44:16,720 --> 00:44:18,932
We'll talk about that
in another second.

838
00:44:18,932 --> 00:44:20,710
It has this string.

839
00:44:20,710 --> 00:44:23,990
This is called a doc string.

840
00:44:23,990 --> 00:44:26,940
It's the specification
for this function.

841
00:44:26,940 --> 00:44:31,280
When you write functions, it's
good to have this string here.

842
00:44:31,280 --> 00:44:33,770
What it allows you to do is
describe what the function

843
00:44:33,770 --> 00:44:39,330
does, what it expects for
input, and what it

844
00:44:39,330 --> 00:44:40,580
gives you as output.

845
00:44:40,580 --> 00:44:42,710

846
00:44:42,710 --> 00:44:45,140
In this case, it's
very simple.

847
00:44:45,140 --> 00:44:47,100
This is the body of
the function.

848
00:44:47,100 --> 00:44:52,030
Again we denote the block
by indenting.

849
00:44:52,030 --> 00:44:54,470
All it does is it takes a
number, which is passed into

850
00:44:54,470 --> 00:44:59,880
it and raises it to
the third power.

851
00:44:59,880 --> 00:45:03,620
This RETURN statement tells
Python to send that back to

852
00:45:03,620 --> 00:45:04,870
whoever called the function.

853
00:45:04,870 --> 00:45:07,980

854
00:45:07,980 --> 00:45:18,610
As an example if this working,
let's look at

855
00:45:18,610 --> 00:45:20,060
this line of code.

856
00:45:20,060 --> 00:45:22,140
What it's doing is--

857
00:45:22,140 --> 00:45:23,170
we've seen the print
statement, so we

858
00:45:23,170 --> 00:45:25,190
know what it does.

859
00:45:25,190 --> 00:45:31,110
It's going to name cube and
it's going to call it.

860
00:45:31,110 --> 00:45:33,820
Python knows it's calling it
because it's got the name of

861
00:45:33,820 --> 00:45:36,830
the function with the
input parameters.

862
00:45:36,830 --> 00:45:47,140
So, 3 is being passed to cube
to be, well, cubed.

863
00:45:47,140 --> 00:45:51,230
What's going on here is that
Python is breaking out of its

864
00:45:51,230 --> 00:45:58,550
normal flow of execution,
sending 3, calling it number

865
00:45:58,550 --> 00:46:01,290
in the function, and then
raising it to the third power.

866
00:46:01,290 --> 00:46:04,135
If we run this, we see 27.

867
00:46:04,135 --> 00:46:09,160

868
00:46:09,160 --> 00:46:15,720
We can pass it any number
that we want.

869
00:46:15,720 --> 00:46:19,596
Is anyone confused by this?

870
00:46:19,596 --> 00:46:21,255
AUDIENCE: The things you're
running between quotation

871
00:46:21,255 --> 00:46:23,870
marks, doesn't that kind of--

872
00:46:23,870 --> 00:46:25,860
PROFESSOR: They don't
do anything.

873
00:46:25,860 --> 00:46:30,340
The question was, this string
here between the quotation

874
00:46:30,340 --> 00:46:31,680
marks, this doesn't
do anything.

875
00:46:31,680 --> 00:46:32,750
No, this is a comment.

876
00:46:32,750 --> 00:46:35,770
This is so that you can tell
yourself, six months down the

877
00:46:35,770 --> 00:46:37,420
road, what you were thinking.

878
00:46:37,420 --> 00:46:39,730
Or so that you could tell
another programmer what this

879
00:46:39,730 --> 00:46:41,270
function does.

880
00:46:41,270 --> 00:46:44,950
It's a way of documenting
your code.

881
00:46:44,950 --> 00:46:46,180
AUDIENCE: So cube in this
case is something that

882
00:46:46,180 --> 00:46:48,400
is built to go around.

883
00:46:48,400 --> 00:46:48,760
PROFESSOR: Yeah.

884
00:46:48,760 --> 00:46:51,190
This is just a toy example.

885
00:46:51,190 --> 00:46:54,830
I wanted to keep it simple.

886
00:46:54,830 --> 00:46:58,240
I'm illustrating concepts.

887
00:46:58,240 --> 00:47:02,335
It wouldn't be too hard
just to do this.

888
00:47:02,335 --> 00:47:09,070

889
00:47:09,070 --> 00:47:10,540
I'm going to move on.

890
00:47:10,540 --> 00:47:11,790
Everyone's good with
functions?

891
00:47:11,790 --> 00:47:14,235

892
00:47:14,235 --> 00:47:15,485
AUDIENCE: [INAUDIBLE]

893
00:47:15,485 --> 00:47:20,103

894
00:47:20,103 --> 00:47:22,548
Can you say x equals number--

895
00:47:22,548 --> 00:47:27,438
can you keep the number, and
just keep the number, and just

896
00:47:27,438 --> 00:47:29,394
make it into a variable without
the RETURN function.

897
00:47:29,394 --> 00:47:31,928

898
00:47:31,928 --> 00:47:35,400
Do you have to use the RETURN
function on that?

899
00:47:35,400 --> 00:47:36,870
PROFESSOR: I was just
getting to that.

900
00:47:36,870 --> 00:47:39,670
The question is, do you have
to use a RETURN function.

901
00:47:39,670 --> 00:47:42,760
The answer is well, it depends
on what you want to do.

902
00:47:42,760 --> 00:47:49,840

903
00:47:49,840 --> 00:47:52,810
So, let's take a look
at a new function.

904
00:47:52,810 --> 00:47:56,660
Can someone tell me
what this does?

905
00:47:56,660 --> 00:47:58,816
First, what does the
function do?

906
00:47:58,816 --> 00:48:00,066
Or what is it supposed to do?

907
00:48:00,066 --> 00:48:02,788

908
00:48:02,788 --> 00:48:05,420
AUDIENCE: Takes the number
and doubles it.

909
00:48:05,420 --> 00:48:07,100
PROFESSOR: You got that by
reading the writing on the

910
00:48:07,100 --> 00:48:09,540
wall, right?

911
00:48:09,540 --> 00:48:12,910
Really, it's too easy.

912
00:48:12,910 --> 00:48:16,010
In the body of the function,
all it does is it creates a

913
00:48:16,010 --> 00:48:18,820
new variable, answer, and it
assigns number times 2 to it.

914
00:48:18,820 --> 00:48:21,740

915
00:48:21,740 --> 00:48:22,990
What's going to print
out here?

916
00:48:22,990 --> 00:48:27,450

917
00:48:27,450 --> 00:48:28,700
Why don't we run it and see?

918
00:48:28,700 --> 00:48:31,240

919
00:48:31,240 --> 00:48:33,680
That's not doing
what we wanted.

920
00:48:33,680 --> 00:48:38,750
When you don't have a RETURN
statement, Python returns

921
00:48:38,750 --> 00:48:41,730
implicitly none to whoever
calls the function.

922
00:48:41,730 --> 00:48:45,310

923
00:48:45,310 --> 00:48:45,390
Ok.

924
00:48:45,390 --> 00:48:47,660
In this case, this function
obviously doesn't have a

925
00:48:47,660 --> 00:48:52,180
RETURN statement Python
says, OK.

926
00:48:52,180 --> 00:48:53,660
I'm just going to return none.

927
00:48:53,660 --> 00:48:59,210
Whatever work it did in the
function is lost in this case.

928
00:48:59,210 --> 00:49:01,300
To get the right functionality,
we have to add

929
00:49:01,300 --> 00:49:02,550
a RETURN statement.

930
00:49:02,550 --> 00:49:06,600

931
00:49:06,600 --> 00:49:09,520
And it works.

932
00:49:09,520 --> 00:49:11,095
Was that what you
were getting at?

933
00:49:11,095 --> 00:49:12,345
OK.

934
00:49:12,345 --> 00:49:14,900

935
00:49:14,900 --> 00:49:15,640
Anyone confused?

936
00:49:15,640 --> 00:49:16,890
Can I move on?

937
00:49:16,890 --> 00:49:25,700

938
00:49:25,700 --> 00:49:27,530
Functions have something
called variable scope.

939
00:49:27,530 --> 00:49:31,630

940
00:49:31,630 --> 00:49:33,380
I apologize for the punning.

941
00:49:33,380 --> 00:49:35,790
I was getting tired
when I wrote this.

942
00:49:35,790 --> 00:49:38,740

943
00:49:38,740 --> 00:49:40,740
In this chunk of code,
I define a

944
00:49:40,740 --> 00:49:41,990
global variable, all_hope.

945
00:49:41,990 --> 00:49:44,890

946
00:49:44,890 --> 00:49:50,180
I also define a function that
takes a parameter, variables.

947
00:49:50,180 --> 00:49:52,840

948
00:49:52,840 --> 00:49:55,120
It says it steals all the
variables, but I don't know

949
00:49:55,120 --> 00:49:57,420
how it does that
in a computer.

950
00:49:57,420 --> 00:50:00,690
It doesn't return anything.

951
00:50:00,690 --> 00:50:02,970
In the body of the function,
I create another variable,

952
00:50:02,970 --> 00:50:08,800
called my_variable, and
I assign it a string.

953
00:50:08,800 --> 00:50:10,980
I'm not actually returning
anything right because I've

954
00:50:10,980 --> 00:50:12,050
said I'm not returning
anything.

955
00:50:12,050 --> 00:50:15,040
All this is doing is it's
just printing stuff out.

956
00:50:15,040 --> 00:50:19,610
It's printing out what the
parameter passed into it was.

957
00:50:19,610 --> 00:50:22,610
It's printing out variables.

958
00:50:22,610 --> 00:50:25,540
It's printing out all_hope,
which is a global variable

959
00:50:25,540 --> 00:50:27,270
that we define up here.

960
00:50:27,270 --> 00:50:31,450
It's printing out my_variable,
which is a local variable in

961
00:50:31,450 --> 00:50:32,700
the function.

962
00:50:32,700 --> 00:50:35,330

963
00:50:35,330 --> 00:50:40,440
Down here I'm defining a
variable, old_meme_is_old.

964
00:50:40,440 --> 00:50:41,690
I'm calling the function.

965
00:50:41,690 --> 00:50:45,680

966
00:50:45,680 --> 00:50:48,970
It does what we expect
it to do.

967
00:50:48,970 --> 00:50:52,770
What I want to illustrate,
though is what

968
00:50:52,770 --> 00:50:54,020
happens if I do this?

969
00:50:54,020 --> 00:51:03,010

970
00:51:03,010 --> 00:51:05,040
As you might expect,
it's going to give

971
00:51:05,040 --> 00:51:07,150
me an error, right?

972
00:51:07,150 --> 00:51:12,450
The reason is that my_variable
has local scope to this

973
00:51:12,450 --> 00:51:14,570
function, all
_your_vars_are_belong_to_us.

974
00:51:14,570 --> 00:51:20,900

975
00:51:20,900 --> 00:51:22,290
Is anyone confused by this?

976
00:51:22,290 --> 00:51:25,070
No one's confused by this?

977
00:51:25,070 --> 00:51:26,320
OK.

978
00:51:26,320 --> 00:51:29,910

979
00:51:29,910 --> 00:51:31,160
Let's try something else.

980
00:51:31,160 --> 00:51:59,960

981
00:51:59,960 --> 00:52:03,230
Let's not do that.

982
00:52:03,230 --> 00:52:13,700
If I run this code, we can tell
from the function that

983
00:52:13,700 --> 00:52:16,410
it's taking one parameter.

984
00:52:16,410 --> 00:52:18,440
It's incrementing
that parameter.

985
00:52:18,440 --> 00:52:20,460
It's incrementing this
global int that

986
00:52:20,460 --> 00:52:22,200
we've defined up here.

987
00:52:22,200 --> 00:52:25,090
It's returning the parameter
that it's just incremented.

988
00:52:25,090 --> 00:52:27,670

989
00:52:27,670 --> 00:52:31,660
Erase my corny humor.

990
00:52:31,660 --> 00:52:47,260

991
00:52:47,260 --> 00:52:51,210
The question now is, let's say
that I have a variable y, and

992
00:52:51,210 --> 00:52:52,610
I give it a value of 10.

993
00:52:52,610 --> 00:52:54,950
I'm being completely
arbitrary.

994
00:52:54,950 --> 00:53:01,671
If I call the variable, inc_it,
on y, first of all,

995
00:53:01,671 --> 00:53:02,921
what's going to print?

996
00:53:02,921 --> 00:53:07,500

997
00:53:07,500 --> 00:53:09,890
If I print out the value of
y, what's going to print?

998
00:53:09,890 --> 00:53:12,510

999
00:53:12,510 --> 00:53:13,760
We want to run it.

1000
00:53:13,760 --> 00:53:22,310

1001
00:53:22,310 --> 00:53:25,190
Uh-oh, I'm failing.

1002
00:53:25,190 --> 00:53:37,460

1003
00:53:37,460 --> 00:53:39,790
I'm stepping on myself here.

1004
00:53:39,790 --> 00:53:43,550
This is why you don't debug
code on the fly.

1005
00:53:43,550 --> 00:53:49,681
If I have a global variable and
I need to reference it, I

1006
00:53:49,681 --> 00:53:50,630
use a global keyword.

1007
00:53:50,630 --> 00:53:51,980
You should never have
to do this.

1008
00:53:51,980 --> 00:53:55,940

1009
00:53:55,940 --> 00:53:58,390
Ink_it is going to
return 11, right?

1010
00:53:58,390 --> 00:54:02,320
Because it's taken y, which
is 10, and it's called x

1011
00:54:02,320 --> 00:54:03,890
equal x plus 1.

1012
00:54:03,890 --> 00:54:05,671
Then it's returned this x.

1013
00:54:05,671 --> 00:54:09,640

1014
00:54:09,640 --> 00:54:15,490
If I look at what y is, after
I've run this, y is still 10.

1015
00:54:15,490 --> 00:54:22,150
This is because when we've
passed in x here and we've

1016
00:54:22,150 --> 00:54:25,440
called x equal x plus 1, it's
actually shadowing itself.

1017
00:54:25,440 --> 00:54:28,570
It's overriding what's in
the local parameter.

1018
00:54:28,570 --> 00:54:35,240
But it's not overriding the
actual variable, y.

1019
00:54:35,240 --> 00:54:40,110
We'll get more into
this later on.

1020
00:54:40,110 --> 00:54:42,500
The important thing to
understand in this case is

1021
00:54:42,500 --> 00:54:45,440
that the changes that you make
to this parameter stay within

1022
00:54:45,440 --> 00:54:47,760
the function.

1023
00:54:47,760 --> 00:54:48,350
We good?

1024
00:54:48,350 --> 00:54:49,310
All right.

1025
00:54:49,310 --> 00:54:56,330
I need to move pretty quickly
now to gotchas.

1026
00:54:56,330 --> 00:54:59,180

1027
00:54:59,180 --> 00:55:02,580
I guarantee you someone's going
to make this mistake.

1028
00:55:02,580 --> 00:55:03,830
Print is not RETURN.

1029
00:55:03,830 --> 00:55:09,190

1030
00:55:09,190 --> 00:55:12,230
When you call print
print_is_not_return, it's

1031
00:55:12,230 --> 00:55:14,570
going to call this function.

1032
00:55:14,570 --> 00:55:17,760
It will print out this
string, but it's not

1033
00:55:17,760 --> 00:55:19,700
returning the string.

1034
00:55:19,700 --> 00:55:21,040
What it's returning
is none, because

1035
00:55:21,040 --> 00:55:24,000
there's no return statement.

1036
00:55:24,000 --> 00:55:25,830
That's where this
none comes from.

1037
00:55:25,830 --> 00:55:29,150

1038
00:55:29,150 --> 00:55:32,060
RETURN is not print.

1039
00:55:32,060 --> 00:55:36,145
So, if I say print this return
value, it will print this; it

1040
00:55:36,145 --> 00:55:37,470
will return a string.

1041
00:55:37,470 --> 00:55:45,235
But if I just call this, it's
not going to print it again.

1042
00:55:45,235 --> 00:55:47,890

1043
00:55:47,890 --> 00:55:49,140
It's going to print nothing.

1044
00:55:49,140 --> 00:55:55,170

1045
00:55:55,170 --> 00:55:56,510
You'll just have to
make the mistake.

1046
00:55:56,510 --> 00:56:03,150

1047
00:56:03,150 --> 00:56:07,240
One thing to be careful
of in Python--

1048
00:56:07,240 --> 00:56:09,360
remember I said everything
is an object?

1049
00:56:09,360 --> 00:56:10,540
Functions are no different.

1050
00:56:10,540 --> 00:56:13,230
Functions are objects.

1051
00:56:13,230 --> 00:56:20,670
If you just reference the
function's name, cube, which

1052
00:56:20,670 --> 00:56:31,960
is not defined now, it's going
to print something out that

1053
00:56:31,960 --> 00:56:33,210
looks like that.

1054
00:56:33,210 --> 00:56:36,990

1055
00:56:36,990 --> 00:56:42,600
This is what the object
looks like to Python.

1056
00:56:42,600 --> 00:56:45,400
In order to call it, you have
to have the parentheses with

1057
00:56:45,400 --> 00:56:46,650
the parameters.

1058
00:56:46,650 --> 00:56:50,070

1059
00:56:50,070 --> 00:56:51,040
Python's not going
to complain.

1060
00:56:51,040 --> 00:56:52,980
Some programming languages
will complain.

1061
00:56:52,980 --> 00:56:54,530
Python won't.

1062
00:56:54,530 --> 00:56:56,660
It's possible when you're
running your code, if you're

1063
00:56:56,660 --> 00:56:59,700
trying to call a function and
you forget the parentheses,

1064
00:56:59,700 --> 00:57:02,700
and Python's just not
complaining, it will merrily

1065
00:57:02,700 --> 00:57:06,590
do what you tell it to do.

1066
00:57:06,590 --> 00:57:08,510
AUDIENCE: [INAUDIBLE]

1067
00:57:08,510 --> 00:57:10,840
PROFESSOR: What's that?

1068
00:57:10,840 --> 00:57:12,090
AUDIENCE: [INAUDIBLE]

1069
00:57:12,090 --> 00:57:16,600

1070
00:57:16,600 --> 00:57:19,580
PROFESSOR: I'm sorry,
can you speak up?

1071
00:57:19,580 --> 00:57:25,010
AUDIENCE: Print q open
parentheses [INAUDIBLE]

1072
00:57:25,010 --> 00:57:26,590
PROFESSOR: OK.

1073
00:57:26,590 --> 00:57:29,252
Is x defined?

1074
00:57:29,252 --> 00:57:30,502
AUDIENCE: [INAUDIBLE]

1075
00:57:30,502 --> 00:57:34,400

1076
00:57:34,400 --> 00:57:35,650
PROFESSOR: Yeah.

1077
00:57:35,650 --> 00:57:41,205
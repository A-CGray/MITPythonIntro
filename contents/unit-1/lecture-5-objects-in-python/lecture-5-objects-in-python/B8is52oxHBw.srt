1
00:00:00,000 --> 00:00:00,040

2
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

3
00:00:02,460 --> 00:00:03,870
Commons license.

4
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

5
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

6
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

7
00:00:13,460 --> 00:00:19,290
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:19,290 --> 00:00:21,421
ocw.mit.edu.

9
00:00:21,421 --> 00:00:24,970
PROFESSOR: Happy Valentine's
Day 11.

10
00:00:24,970 --> 00:00:26,850
Actually, maybe it's a
little smiley face

11
00:00:26,850 --> 00:00:28,530
combined with an 11.

12
00:00:28,530 --> 00:00:30,310
Did any of you leave
this here for me?

13
00:00:30,310 --> 00:00:33,480
Or am I just stroking
my ego and this was

14
00:00:33,480 --> 00:00:36,380
left for someone yesterday?

15
00:00:36,380 --> 00:00:40,050
Stroking my ego, all right.

16
00:00:40,050 --> 00:00:47,350
OK, last lecture, we looked at
a program for finding roots

17
00:00:47,350 --> 00:00:50,610
and put in a little debugging
statement that, along the way,

18
00:00:50,610 --> 00:00:54,960
printed various approximations
to the root.

19
00:00:54,960 --> 00:00:59,400
Now, suppose that instead of
printing things, we actually

20
00:00:59,400 --> 00:01:02,770
wanted to collect the
approximations.

21
00:01:02,770 --> 00:01:05,800
For example, to be able to go
back and look at them later

22
00:01:05,800 --> 00:01:09,820
and analyze them, do various
kinds of things.

23
00:01:09,820 --> 00:01:13,580
To do this, and this is the sort
of thing we do a lot, we

24
00:01:13,580 --> 00:01:17,660
need some data structures that
can be used for amassing

25
00:01:17,660 --> 00:01:20,560
collections of items.

26
00:01:20,560 --> 00:01:26,520
There are 3 data structures
in Python that are used to

27
00:01:26,520 --> 00:01:28,150
collect items.

28
00:01:28,150 --> 00:01:30,130
I'm going to try and cover
all of them today.

29
00:01:30,130 --> 00:01:33,050

30
00:01:33,050 --> 00:01:38,306
Tuples, lists, and
dictionaries.

31
00:01:38,306 --> 00:01:49,270

32
00:01:49,270 --> 00:01:52,870
We'll start with tuples
and lists.

33
00:01:52,870 --> 00:02:02,610
And what they have in common is
they are ordered sequences

34
00:02:02,610 --> 00:02:03,860
of objects.

35
00:02:03,860 --> 00:02:11,840

36
00:02:11,840 --> 00:02:14,750
So the key notion here
is they're ordered.

37
00:02:14,750 --> 00:02:18,400
It makes sense to talk about the
first object, the second

38
00:02:18,400 --> 00:02:21,660
object, the last object,
et cetera.

39
00:02:21,660 --> 00:02:25,380
When we get to dictionaries, or
dicts as they're spelled in

40
00:02:25,380 --> 00:02:29,200
Python, we'll see that
they're not ordered.

41
00:02:29,200 --> 00:02:31,030
All right, let's look
at tuples first.

42
00:02:31,030 --> 00:02:32,280
They're the simplest.

43
00:02:32,280 --> 00:02:34,540

44
00:02:34,540 --> 00:02:45,700
So if we look at it, there's
a very simple

45
00:02:45,700 --> 00:02:47,500
example at the top.

46
00:02:47,500 --> 00:02:50,150
I have this tuple called test.

47
00:02:50,150 --> 00:02:52,220
And I just said that's
the sequence of

48
00:02:52,220 --> 00:02:56,210
ints 1, 2, 3, 4, 5.

49
00:02:56,210 --> 00:02:58,670
I can then index into it.

50
00:02:58,670 --> 00:03:01,110
For example, look at
the first element,

51
00:03:01,110 --> 00:03:04,540
which is the 0th element.

52
00:03:04,540 --> 00:03:07,940
Or I could look at
the next element.

53
00:03:07,940 --> 00:03:08,850
And we can print them.

54
00:03:08,850 --> 00:03:10,100
So let's just do that.

55
00:03:10,100 --> 00:03:13,030

56
00:03:13,030 --> 00:03:18,940
And you can see it prints 1
and 2, not surprisingly.

57
00:03:18,940 --> 00:03:20,760
I can print the whole
thing if I want.

58
00:03:20,760 --> 00:03:25,330

59
00:03:25,330 --> 00:03:30,950
That lets me look at
the entire tuple.

60
00:03:30,950 --> 00:03:32,495
I can also look at this.

61
00:03:32,495 --> 00:03:38,660

62
00:03:38,660 --> 00:03:42,300
And that gives me the last
element without my having to

63
00:03:42,300 --> 00:03:46,010
know what the last element is.

64
00:03:46,010 --> 00:03:47,910
I can ask about the
length of a tuple.

65
00:03:47,910 --> 00:03:53,120

66
00:03:53,120 --> 00:03:54,370
And it tells me it's five.

67
00:03:54,370 --> 00:03:57,820

68
00:03:57,820 --> 00:03:59,880
Similarly, I could write
something like this.

69
00:03:59,880 --> 00:04:04,800

70
00:04:04,800 --> 00:04:06,050
Print test.

71
00:04:06,050 --> 00:04:15,500

72
00:04:15,500 --> 00:04:16,990
Why was that out of range?

73
00:04:16,990 --> 00:04:21,757

74
00:04:21,757 --> 00:04:22,743
Yeah?

75
00:04:22,743 --> 00:04:24,495
AUDIENCE: Because you're
indexing from 0?

76
00:04:24,495 --> 00:04:26,510
PROFESSOR: Because I'm
indexing from 0.

77
00:04:26,510 --> 00:04:29,780
So that's why I have this
more convenient way of

78
00:04:29,780 --> 00:04:31,780
writing minus 1.

79
00:04:31,780 --> 00:04:34,160
Otherwise, I'd have to
do len minus one.

80
00:04:34,160 --> 00:04:37,170
Good grab.

81
00:04:37,170 --> 00:04:42,320
OK, let's look at a little
example of how we might use

82
00:04:42,320 --> 00:04:43,570
this sort of thing.

83
00:04:43,570 --> 00:04:52,270

84
00:04:52,270 --> 00:04:55,310
So here, I've just written a
little piece of code that

85
00:04:55,310 --> 00:04:56,560
finds divisors.

86
00:04:56,560 --> 00:05:03,000

87
00:05:03,000 --> 00:05:07,040
Going to find all of the divisor
of 100, collect them

88
00:05:07,040 --> 00:05:09,990
into a tuple.

89
00:05:09,990 --> 00:05:23,930
Notice this kind of funny piece
of syntax here, i comma.

90
00:05:23,930 --> 00:05:28,170
I need to do that to say it's
a tuple of length one.

91
00:05:28,170 --> 00:05:31,290

92
00:05:31,290 --> 00:05:36,870
Why can't I just write open
paren, i, comma, open paren?

93
00:05:36,870 --> 00:05:40,640
Because that would just take
the expression, i, and

94
00:05:40,640 --> 00:05:44,800
parenthesize it as we often use
parentheses for grouping

95
00:05:44,800 --> 00:05:47,470
when we write things.

96
00:05:47,470 --> 00:05:51,790
So by inserting this comma, I
say, I don't just mean the--

97
00:05:51,790 --> 00:05:54,510
in this case-- say
the number i.

98
00:05:54,510 --> 00:05:57,950
I mean the tuple
of length one.

99
00:05:57,950 --> 00:06:02,130
So it's sort of a special case
piece of syntax that you need

100
00:06:02,130 --> 00:06:04,050
for tuples of length one.

101
00:06:04,050 --> 00:06:06,490
Then, I can print
the divisors.

102
00:06:06,490 --> 00:06:07,740
So let's run that.

103
00:06:07,740 --> 00:06:11,800

104
00:06:11,800 --> 00:06:14,340
And it now prints the
tuple for me.

105
00:06:14,340 --> 00:06:15,370
So I've run through.

106
00:06:15,370 --> 00:06:16,860
I've computed all
the divisors.

107
00:06:16,860 --> 00:06:18,110
And I've collected them.

108
00:06:18,110 --> 00:06:21,890

109
00:06:21,890 --> 00:06:26,200
Nothing very interesting,
but kind of useful.

110
00:06:26,200 --> 00:06:27,660
We can also--

111
00:06:27,660 --> 00:06:31,420
I've shown you how to select
elements of tuples.

112
00:06:31,420 --> 00:06:35,670
I can also, if I choose,
get what are

113
00:06:35,670 --> 00:06:37,210
called slices of tuples.

114
00:06:37,210 --> 00:06:44,370

115
00:06:44,370 --> 00:06:51,100
So a slice gives me a range of
values, or in this case, a

116
00:06:51,100 --> 00:06:57,100
subsequence of the tuple.

117
00:06:57,100 --> 00:06:59,400
As we'll see, we can
also slice lists.

118
00:06:59,400 --> 00:07:11,540

119
00:07:11,540 --> 00:07:12,370
So let's see.

120
00:07:12,370 --> 00:07:14,425
We have a tuple called
divisors here.

121
00:07:14,425 --> 00:07:19,640

122
00:07:19,640 --> 00:07:21,620
Yeah, OK, I'll save
the source.

123
00:07:21,620 --> 00:07:22,870
Oh, come on!

124
00:07:22,870 --> 00:07:33,010

125
00:07:33,010 --> 00:07:35,660
So if I wanted to do--

126
00:07:35,660 --> 00:07:36,210
what did I call it?

127
00:07:36,210 --> 00:07:37,460
I called it divisors.

128
00:07:37,460 --> 00:07:40,040

129
00:07:40,040 --> 00:07:44,760
So I can do something
like divisors 1:3.

130
00:07:44,760 --> 00:07:48,380

131
00:07:48,380 --> 00:07:53,680
And you'll note that gives me
those two elements at the

132
00:07:53,680 --> 00:07:56,620
appropriate places.

133
00:07:56,620 --> 00:08:00,320
And so it's a very convenient
way to take pieces of it.

134
00:08:00,320 --> 00:08:04,280

135
00:08:04,280 --> 00:08:08,710
All right, any questions
about tuples?

136
00:08:08,710 --> 00:08:10,400
Not very deep.

137
00:08:10,400 --> 00:08:17,600
Lists are, I think, more useful
than tuples and also,

138
00:08:17,600 --> 00:08:20,850
alas, more complicated.

139
00:08:20,850 --> 00:08:25,440
And they're complicated because
the big difference is

140
00:08:25,440 --> 00:08:32,679
that tuples are immutable.

141
00:08:32,679 --> 00:08:37,840
And by that, I mean once you've
created a tuple, you

142
00:08:37,840 --> 00:08:41,409
cannot change its value.

143
00:08:41,409 --> 00:08:44,070
You can create a new tuple.

144
00:08:44,070 --> 00:08:48,140
but you can't change the
value of the old tuple.

145
00:08:48,140 --> 00:08:54,920
In contrast, lists
are mutable.

146
00:08:54,920 --> 00:08:59,650
Once you've created a list, you
can actually change it.

147
00:08:59,650 --> 00:09:04,340
It's the first mutable type
we've looked at because you'll

148
00:09:04,340 --> 00:09:08,570
recall assignment didn't
actually change

149
00:09:08,570 --> 00:09:10,550
the value of an object.

150
00:09:10,550 --> 00:09:16,780
It just changed the object to
which an identifier was bound.

151
00:09:16,780 --> 00:09:21,470
Mutability is the first time
we've seen a way to actually

152
00:09:21,470 --> 00:09:24,520
change the value of
an object itself.

153
00:09:24,520 --> 00:09:27,380

154
00:09:27,380 --> 00:09:34,050
And that's, as we'll see, both
a powerful concept and an

155
00:09:34,050 --> 00:09:38,660
opportunity to mess yourself
up by committing serious

156
00:09:38,660 --> 00:09:39,910
programming blunders.

157
00:09:39,910 --> 00:09:42,470

158
00:09:42,470 --> 00:09:48,530
All right, so let's look at an
example here, first of many

159
00:09:48,530 --> 00:09:49,780
we'll be looking at.

160
00:09:49,780 --> 00:09:53,490

161
00:09:53,490 --> 00:09:56,620
So first, we won't worry too
much about the mutability.

162
00:09:56,620 --> 00:10:02,190

163
00:10:02,190 --> 00:10:09,250
So here, I'm creating a list
called techs, which happens to

164
00:10:09,250 --> 00:10:12,320
be, in this case, a
list of strings.

165
00:10:12,320 --> 00:10:14,990
Lists need not be homogeneous.

166
00:10:14,990 --> 00:10:18,420
As we'll see, you can mix
strings, and floats, and ints.

167
00:10:18,420 --> 00:10:22,860
And most interestingly, you
can have lists of list.

168
00:10:22,860 --> 00:10:24,870
And then, another list
called ivies.

169
00:10:24,870 --> 00:10:27,590

170
00:10:27,590 --> 00:10:31,390
And then, I'm going to say I'm
going to have these univs, yet

171
00:10:31,390 --> 00:10:32,170
another list.

172
00:10:32,170 --> 00:10:34,350
This list empty, containing
no elements.

173
00:10:34,350 --> 00:10:36,960

174
00:10:36,960 --> 00:10:43,380
Then, I'm going to append
techs to ivies.

175
00:10:43,380 --> 00:10:45,020
Notice this syntax--

176
00:10:45,020 --> 00:10:46,270
univs.append.

177
00:10:46,270 --> 00:10:49,300

178
00:10:49,300 --> 00:10:57,250
What that means here is
that append is what

179
00:10:57,250 --> 00:10:59,085
Python calls a method.

180
00:10:59,085 --> 00:11:04,610

181
00:11:04,610 --> 00:11:09,260
As we'll see when we get to
classes, methods play a very

182
00:11:09,260 --> 00:11:12,430
important role in Python.

183
00:11:12,430 --> 00:11:17,220
But to a first approximation,
it's quite safe to think of a

184
00:11:17,220 --> 00:11:21,600
method as an alternative syntax
for writing function.

185
00:11:21,600 --> 00:11:24,240

186
00:11:24,240 --> 00:11:32,620
So instead of writing something
like append a list

187
00:11:32,620 --> 00:11:46,140
and an element, I write
l.append the element.

188
00:11:46,140 --> 00:11:50,990
And just think of this l over
here as a fancy way of

189
00:11:50,990 --> 00:11:55,170
denoting the first argument to
the function append, the first

190
00:11:55,170 --> 00:11:57,020
actual parameter.

191
00:11:57,020 --> 00:12:02,210
When we get to classes in a few
weeks, we'll see why it's

192
00:12:02,210 --> 00:12:06,170
highly useful to have this
specialized syntax.

193
00:12:06,170 --> 00:12:10,520
But for now, just think of it as
a piece of syntactic sugar,

194
00:12:10,520 --> 00:12:11,770
if you will.

195
00:12:11,770 --> 00:12:13,910

196
00:12:13,910 --> 00:12:19,320
The thing I want you to think
about, though, is this is not

197
00:12:19,320 --> 00:12:23,010
equivalent to assigning
something to l.

198
00:12:23,010 --> 00:12:25,615
This actually mutates
the list.

199
00:12:25,615 --> 00:12:35,340

200
00:12:35,340 --> 00:12:38,060
And we say it has
a side effect.

201
00:12:38,060 --> 00:12:44,400

202
00:12:44,400 --> 00:12:47,550
Up till now, since we've only
been dealing with immutable

203
00:12:47,550 --> 00:12:54,365
types, every function we've
looked at, its job was to take

204
00:12:54,365 --> 00:12:59,330
in a bunch of values, do some
computation, return a value.

205
00:12:59,330 --> 00:13:01,600
It didn't change anything.

206
00:13:01,600 --> 00:13:04,650
And then, if we wanted to take
advantage of what the function

207
00:13:04,650 --> 00:13:08,590
did, we had to assign the value
it returned to some

208
00:13:08,590 --> 00:13:11,010
variable, and then we
could manipulate it.

209
00:13:11,010 --> 00:13:13,330
Or we could print the
value it returned.

210
00:13:13,330 --> 00:13:16,990
We had to do something with
the value it returned.

211
00:13:16,990 --> 00:13:21,120
Here, we invoke append.

212
00:13:21,120 --> 00:13:25,920
And rather than worrying about
what it returns, we're

213
00:13:25,920 --> 00:13:29,740
invoking it for the purpose
of its side effect--

214
00:13:29,740 --> 00:13:35,460
the modification it performs
on the list.

215
00:13:35,460 --> 00:13:37,570
So let's look at what we
get when we run this.

216
00:13:37,570 --> 00:13:44,000

217
00:13:44,000 --> 00:13:47,610
So you'll notice what
univs is now.

218
00:13:47,610 --> 00:13:52,250
It's a list of length one.

219
00:13:52,250 --> 00:13:57,890
And the one element in it is
itself a list because I have

220
00:13:57,890 --> 00:14:02,820
appended a list to the end
of the empty list--

221
00:14:02,820 --> 00:14:08,340
not the elements of the list,
but the list itself, OK?

222
00:14:08,340 --> 00:14:12,200
So it's important to notice the
difference between a list

223
00:14:12,200 --> 00:14:18,170
that contained the elements MIT
and Cal Tech, and a list

224
00:14:18,170 --> 00:14:20,850
that contained a list
which contains the

225
00:14:20,850 --> 00:14:23,215
elements MIT and Cal Tech.

226
00:14:23,215 --> 00:14:30,900

227
00:14:30,900 --> 00:14:32,294
Yes?

228
00:14:32,294 --> 00:14:36,760
AUDIENCE: Previously, you added
two tuples together.

229
00:14:36,760 --> 00:14:41,470
And that's not like
appending, right?

230
00:14:41,470 --> 00:14:45,770
PROFESSOR: Because when I
concatenated two tuples, in

231
00:14:45,770 --> 00:14:48,670
order to do something useful
with that value, I had to

232
00:14:48,670 --> 00:14:50,620
assign it to something.

233
00:14:50,620 --> 00:14:53,830
It did not modify anything.

234
00:14:53,830 --> 00:14:56,800
It produced a new tuple
which was the value

235
00:14:56,800 --> 00:14:59,040
of appending them.

236
00:14:59,040 --> 00:15:01,100
And then, it assigned
it to a new tuple.

237
00:15:01,100 --> 00:15:05,850
So it's quite different from
append, which is actually

238
00:15:05,850 --> 00:15:08,650
having a side effect
on the list.

239
00:15:08,650 --> 00:15:13,290
Does not produce a new list,
it modifies the old list.

240
00:15:13,290 --> 00:15:19,530
So we can look at this, draw
a little picture here.

241
00:15:19,530 --> 00:15:20,780
So we had techs.

242
00:15:20,780 --> 00:15:25,190

243
00:15:25,190 --> 00:15:31,000
And that pointed to a list with
two elements in it, which

244
00:15:31,000 --> 00:15:33,990
I'll abbreviated as
MIT and Cal Tech.

245
00:15:33,990 --> 00:15:35,625
Both of these elements
were strings.

246
00:15:35,625 --> 00:15:40,190

247
00:15:40,190 --> 00:15:44,285
Then, I created a new
list called univs.

248
00:15:44,285 --> 00:15:47,450

249
00:15:47,450 --> 00:15:54,860
And that was initially bound to
the empty list, a list with

250
00:15:54,860 --> 00:15:56,110
no elements in it.

251
00:15:56,110 --> 00:15:58,420

252
00:15:58,420 --> 00:16:01,010
I then did an append.

253
00:16:01,010 --> 00:16:05,220
And the effect of the
append was to modify

254
00:16:05,220 --> 00:16:07,340
univs so that it pointed--

255
00:16:07,340 --> 00:16:10,520

256
00:16:10,520 --> 00:16:12,280
now, I had one element.

257
00:16:12,280 --> 00:16:16,430
And the element it was
was this list.

258
00:16:16,430 --> 00:16:19,160
Notice it didn't
copy this list.

259
00:16:19,160 --> 00:16:22,720
It actually included
the list itself.

260
00:16:22,720 --> 00:16:26,490

261
00:16:26,490 --> 00:16:29,150
So let's look at the
ramifications of

262
00:16:29,150 --> 00:16:30,400
doing it that way.

263
00:16:30,400 --> 00:16:38,960

264
00:16:38,960 --> 00:16:40,210
Whoops.

265
00:16:40,210 --> 00:16:43,950

266
00:16:43,950 --> 00:16:46,810
So what I'm going to do
now is append another

267
00:16:46,810 --> 00:16:49,770
element called ivies.

268
00:16:49,770 --> 00:16:52,820
I'm going to then print it.

269
00:16:52,820 --> 00:16:56,470
And then, for e in univs-- so
here's kind of a nice thing

270
00:16:56,470 --> 00:16:57,720
you can do with lists.

271
00:16:57,720 --> 00:17:01,860

272
00:17:01,860 --> 00:17:05,670
You can iterate over the
elements in the list.

273
00:17:05,670 --> 00:17:08,849
So you might think that the way
to do that is, well, I'll

274
00:17:08,849 --> 00:17:13,780
go for i index in range
0 to length of list.

275
00:17:13,780 --> 00:17:15,450
That would be equivalent.

276
00:17:15,450 --> 00:17:18,349
But it's, in fact, much easier
to just write this way--

277
00:17:18,349 --> 00:17:20,500
for e in univs.

278
00:17:20,500 --> 00:17:23,890
That will do something to every
element of the list.

279
00:17:23,890 --> 00:17:26,400
I'm going to print what
the element is.

280
00:17:26,400 --> 00:17:27,650
So let's look at that.

281
00:17:27,650 --> 00:17:36,370

282
00:17:36,370 --> 00:17:43,550
So now, I have a list, as we
see here, of length two.

283
00:17:43,550 --> 00:17:45,660
It contains two lists.

284
00:17:45,660 --> 00:17:49,930
And if I print the elements, I
print each of those lists.

285
00:17:49,930 --> 00:17:51,795
Nothing very magical there.

286
00:17:51,795 --> 00:17:56,190

287
00:17:56,190 --> 00:18:02,520
Now, suppose I wanted
it flattened.

288
00:18:02,520 --> 00:18:04,800
You asked the question about
the tuples where I did

289
00:18:04,800 --> 00:18:06,150
concatenation.

290
00:18:06,150 --> 00:18:07,905
Well, I can do the
same thing here.

291
00:18:07,905 --> 00:18:11,650

292
00:18:11,650 --> 00:18:16,050
I'll let flat equal
techs plus ivies.

293
00:18:16,050 --> 00:18:17,300
And then, I'll print flat.

294
00:18:17,300 --> 00:18:23,620

295
00:18:23,620 --> 00:18:29,110
And you'll note here what
concatenation does is it just

296
00:18:29,110 --> 00:18:34,180
takes the elements of the list
and creates a new list and

297
00:18:34,180 --> 00:18:35,430
appends it.

298
00:18:35,430 --> 00:18:37,690

299
00:18:37,690 --> 00:18:39,900
Not append it-- in this
case, it assigns it to

300
00:18:39,900 --> 00:18:42,650
flat, excuse me.

301
00:18:42,650 --> 00:18:44,970
So that's convenient.

302
00:18:44,970 --> 00:18:49,410
Poor old plus is overloaded
with yet another meaning.

303
00:18:49,410 --> 00:18:51,430
All right, let's keep
on trucking.

304
00:18:51,430 --> 00:19:06,460

305
00:19:06,460 --> 00:19:08,300
I, of course, can
do this myself.

306
00:19:08,300 --> 00:19:11,010
So here, I've got another
list called artSchools.

307
00:19:11,010 --> 00:19:13,630
It includes RISD and Harvard.

308
00:19:13,630 --> 00:19:18,310
For u2 in artSchools, if u2 in
flat, I'm going to remove it.

309
00:19:18,310 --> 00:19:24,190

310
00:19:24,190 --> 00:19:26,680
All right, so again, I'm going
to iterate over everything in

311
00:19:26,680 --> 00:19:27,930
artSchools.

312
00:19:27,930 --> 00:19:29,560

313
00:19:29,560 --> 00:19:31,045
What's this going to
do, do you think?

314
00:19:31,045 --> 00:19:35,410

315
00:19:35,410 --> 00:19:37,840
What will I get when
I print it here?

316
00:19:37,840 --> 00:19:40,970

317
00:19:40,970 --> 00:19:42,180
No new concepts here.

318
00:19:42,180 --> 00:19:45,680
This is all stuff we've seen.

319
00:19:45,680 --> 00:19:46,540
Somebody up there?

320
00:19:46,540 --> 00:19:47,922
Yeah.

321
00:19:47,922 --> 00:19:49,275
AUDIENCE: Flat without
Harvard in it?

322
00:19:49,275 --> 00:19:51,710
PROFESSOR: Yes.

323
00:19:51,710 --> 00:19:54,160
The correct answer was flat
without Harvard in it.

324
00:19:54,160 --> 00:19:57,630

325
00:19:57,630 --> 00:20:01,920
Wow, almost a good catch.

326
00:20:01,920 --> 00:20:03,370
Just almost there.

327
00:20:03,370 --> 00:20:07,310
All right, so let's confirm.

328
00:20:07,310 --> 00:20:08,220
Yes, we'll save it.

329
00:20:08,220 --> 00:20:09,470
Thank you.

330
00:20:09,470 --> 00:20:13,500

331
00:20:13,500 --> 00:20:16,715
All right, so we've now removed
the art school.

332
00:20:16,715 --> 00:20:21,640

333
00:20:21,640 --> 00:20:24,620
All right, we'll look
at one more thing.

334
00:20:24,620 --> 00:20:26,790
Actually, we'll look at far
more than one more thing.

335
00:20:26,790 --> 00:20:30,235
But we'll look at one more
thing for the moment.

336
00:20:30,235 --> 00:20:37,420

337
00:20:37,420 --> 00:20:39,790
So I'm going to invoke
another method.

338
00:20:39,790 --> 00:20:42,020
This is a built-in method
of Python that

339
00:20:42,020 --> 00:20:46,490
works on sequence types.

340
00:20:46,490 --> 00:20:49,330
And it's called sort.

341
00:20:49,330 --> 00:20:52,175
So you can do-- this will have
a side effect on flat.

342
00:20:52,175 --> 00:20:55,220

343
00:20:55,220 --> 00:20:59,440
And it will, as you might guess,
put them in order.

344
00:20:59,440 --> 00:21:01,642
So let's run that.

345
00:21:01,642 --> 00:21:03,480
Actually, we'll comment this
out for the moment.

346
00:21:03,480 --> 00:21:11,440

347
00:21:11,440 --> 00:21:13,600
So you'll now note that
it's put them in

348
00:21:13,600 --> 00:21:14,890
alphabetical order.

349
00:21:14,890 --> 00:21:18,670

350
00:21:18,670 --> 00:21:21,020
This is something, again, that
you'll find convenient

351
00:21:21,020 --> 00:21:24,170
throughout the term, the ability
to have the side

352
00:21:24,170 --> 00:21:25,770
effect of sorting a list.

353
00:21:25,770 --> 00:21:35,320

354
00:21:35,320 --> 00:21:43,475
Now, I'm going to assign
something to flat sub 1.

355
00:21:43,475 --> 00:21:46,510

356
00:21:46,510 --> 00:21:51,010
So let's think about what this
is going to be doing.

357
00:21:51,010 --> 00:21:55,840
It's going to replace
the first element of

358
00:21:55,840 --> 00:21:58,155
flat by a new value.

359
00:21:58,155 --> 00:22:01,770

360
00:22:01,770 --> 00:22:07,740
So it's having, again, a
side effect on flat.

361
00:22:07,740 --> 00:22:10,430
So you have to be a little bit
careful as you think about

362
00:22:10,430 --> 00:22:14,580
this, that I've written
something that looks like a

363
00:22:14,580 --> 00:22:17,370
conventional assignment
statement.

364
00:22:17,370 --> 00:22:21,190
But in fact, flat sub 1
is not an identifier.

365
00:22:21,190 --> 00:22:23,800

366
00:22:23,800 --> 00:22:29,780
So this is not binding the name,
flat sub 1, To UMass.

367
00:22:29,780 --> 00:22:34,730
It's actually modifying the
object that is the first

368
00:22:34,730 --> 00:22:36,072
element of flat.

369
00:22:36,072 --> 00:22:41,740

370
00:22:41,740 --> 00:22:44,800
AUDIENCE: So would an identifier
just be a name,

371
00:22:44,800 --> 00:22:47,178
flat, for example?

372
00:22:47,178 --> 00:22:49,160
PROFESSOR: Well, I
think the way--

373
00:22:49,160 --> 00:22:55,160
the question is, would the
identifier just be "flat?" No.

374
00:22:55,160 --> 00:22:58,450
Don't think of this as
an assignment at all.

375
00:22:58,450 --> 00:23:02,410
Because remember, what an
assignment does is swing one

376
00:23:02,410 --> 00:23:06,190
of these pointers to point
to a different object.

377
00:23:06,190 --> 00:23:08,170
We'll see an example of that.

378
00:23:08,170 --> 00:23:13,010
Whereas here, I'm actually
modifying a piece of the

379
00:23:13,010 --> 00:23:18,490
object that the identifier
points to.

380
00:23:18,490 --> 00:23:23,230
So it's not an assignment in
the sense of a re-binding.

381
00:23:23,230 --> 00:23:25,560
It's actually having
a side effect of

382
00:23:25,560 --> 00:23:26,810
modifying the object.

383
00:23:26,810 --> 00:23:32,590

384
00:23:32,590 --> 00:23:33,320
Let's just run it.

385
00:23:33,320 --> 00:23:36,000
And then, I'll be happy
with the question.

386
00:23:36,000 --> 00:23:42,110
So here, you'll see I changed
flat sub 1 to now be UMass.

387
00:23:42,110 --> 00:23:44,684
Yeah, question?

388
00:23:44,684 --> 00:23:48,596
AUDIENCE: As you've drawn on
the blackboard here, you've

389
00:23:48,596 --> 00:23:52,060
drawn an arrow to the actual
object that's techs.

390
00:23:52,060 --> 00:23:54,340
So if we change techs,
will we change univs?

391
00:23:54,340 --> 00:23:55,570
PROFESSOR: Yes.

392
00:23:55,570 --> 00:24:00,140
The question was if we change
techs, will we change univs?

393
00:24:00,140 --> 00:24:03,670
Now, in some sense, that's
a philosophical question.

394
00:24:03,670 --> 00:24:06,530
From the philosophical
point of view, maybe,

395
00:24:06,530 --> 00:24:07,410
you could say no.

396
00:24:07,410 --> 00:24:10,290
Univs is still the
same object.

397
00:24:10,290 --> 00:24:12,670
So the binding has
not been changed.

398
00:24:12,670 --> 00:24:18,490
But the object to which it has
been bound is now different.

399
00:24:18,490 --> 00:24:23,220
Same object, but it has a
new value, all right?

400
00:24:23,220 --> 00:24:25,320
So this is the key thing
to keep in mind.

401
00:24:25,320 --> 00:24:32,050
Assignment has to do with the
binding of names to objects.

402
00:24:32,050 --> 00:24:38,930
Mutation has to do with changing
the value of objects.

403
00:24:38,930 --> 00:24:41,870
We'll see that pretty
graphically in the next

404
00:24:41,870 --> 00:24:46,170
example that I wanted to
work my way through.

405
00:24:46,170 --> 00:24:50,220
So I'm going to work through
a dull example.

406
00:24:50,220 --> 00:24:51,770
But I think it illustrates
the points.

407
00:24:51,770 --> 00:25:02,360

408
00:25:02,360 --> 00:25:05,240
And I do, by the way, very much
appreciate the questions,

409
00:25:05,240 --> 00:25:09,440
even if I forget to throw you
candy in return for asking.

410
00:25:09,440 --> 00:25:10,720
But it's good.

411
00:25:10,720 --> 00:25:13,695
If you have questions,
please do ask them.

412
00:25:13,695 --> 00:25:15,660
And I'll try and remember
to feed you.

413
00:25:15,660 --> 00:25:25,020

414
00:25:25,020 --> 00:25:28,776
So let's work through what
this code is going to do.

415
00:25:28,776 --> 00:25:32,680
So first, I'm going to
have the list L1.

416
00:25:32,680 --> 00:25:46,460

417
00:25:46,460 --> 00:25:50,020
So the first thing, I'm going to
create an object which is a

418
00:25:50,020 --> 00:25:53,630
list of length one containing
the integer 2.

419
00:25:53,630 --> 00:25:59,480
So L1 will be bound to the
list of length one

420
00:25:59,480 --> 00:26:00,920
containing the int 2.

421
00:26:00,920 --> 00:26:04,250

422
00:26:04,250 --> 00:26:12,550
I'm then going to create another
list, L2, which is

423
00:26:12,550 --> 00:26:15,660
going to be of length two.

424
00:26:15,660 --> 00:26:19,290
And the first element
will be L1.

425
00:26:19,290 --> 00:26:21,535
And the second element
will be L1.

426
00:26:21,535 --> 00:26:29,150

427
00:26:29,150 --> 00:26:32,510
So what will happen
if I print L2?

428
00:26:32,510 --> 00:26:33,760
What will I get?

429
00:26:33,760 --> 00:26:37,090

430
00:26:37,090 --> 00:26:40,600
I'll get list two, comma,
list two, right?

431
00:26:40,600 --> 00:26:41,850
We can look at it.

432
00:26:41,850 --> 00:26:48,720

433
00:26:48,720 --> 00:26:50,000
If I print L2, excuse me.

434
00:26:50,000 --> 00:26:59,000

435
00:26:59,000 --> 00:27:04,120
All right, just what we
would have expected.

436
00:27:04,120 --> 00:27:11,135
Now, I'm going to change the
0th value of L1 to be 3.

437
00:27:11,135 --> 00:27:14,370

438
00:27:14,370 --> 00:27:16,120
So I'm going to mutate L1.

439
00:27:16,120 --> 00:27:22,660

440
00:27:22,660 --> 00:27:38,970
Now, if I print L2, I will get
a different value, 3, 3.

441
00:27:38,970 --> 00:27:40,220
Not surprising.

442
00:27:40,220 --> 00:27:48,550

443
00:27:48,550 --> 00:27:54,890
It's something to keep in mind
that can be useful, but can

444
00:27:54,890 --> 00:27:57,210
also be confusing.

445
00:27:57,210 --> 00:28:01,300
Because if I'm looking at my
code, it doesn't look like I

446
00:28:01,300 --> 00:28:07,390
changed L2 when I have
a side effect on L1.

447
00:28:07,390 --> 00:28:10,740
And so it can be mystifying when
you're trying to debug.

448
00:28:10,740 --> 00:28:11,740
You print L2.

449
00:28:11,740 --> 00:28:13,330
You do a bunch of--

450
00:28:13,330 --> 00:28:15,360
execute a bunch of statements,
none of which

451
00:28:15,360 --> 00:28:18,080
apparently deals with L2.

452
00:28:18,080 --> 00:28:22,260
Then, you print L2 again and
get a different value.

453
00:28:22,260 --> 00:28:25,930
This is both the beauty and
the peril of mutation.

454
00:28:25,930 --> 00:28:30,170

455
00:28:30,170 --> 00:28:31,420
Now, let's see what this does.

456
00:28:31,420 --> 00:28:35,950

457
00:28:35,950 --> 00:28:45,830
So here, I've now mutated L2 so
that its first element is

458
00:28:45,830 --> 00:28:52,820
no longer the list, L1, but
is now the string a.

459
00:28:52,820 --> 00:29:07,330

460
00:29:07,330 --> 00:29:09,690
And we'll just do a bunch of
these all at once here.

461
00:29:09,690 --> 00:29:15,390

462
00:29:15,390 --> 00:29:25,040
Now, I'm going to change
L1 to be 2, length one.

463
00:29:25,040 --> 00:29:27,860
So what do you think will
happen, by the way, if, after

464
00:29:27,860 --> 00:29:31,840
this, I print L2?

465
00:29:31,840 --> 00:29:45,790

466
00:29:45,790 --> 00:29:47,040
Whoops.

467
00:29:47,040 --> 00:29:50,030

468
00:29:50,030 --> 00:29:51,670
What do you think is going
to get printed here?

469
00:29:51,670 --> 00:29:58,770

470
00:29:58,770 --> 00:29:59,550
This is important.

471
00:29:59,550 --> 00:30:00,800
You need to figure this out.

472
00:30:00,800 --> 00:30:05,630

473
00:30:05,630 --> 00:30:07,380
What's going to get
printed here?

474
00:30:07,380 --> 00:30:08,590
A volunteer, please.

475
00:30:08,590 --> 00:30:09,946
Yes?

476
00:30:09,946 --> 00:30:13,074
AUDIENCE: it's going to print
"a" in the first slot and then

477
00:30:13,074 --> 00:30:16,448
L1 in the second slot.

478
00:30:16,448 --> 00:30:17,412
PROFESSOR: Well--

479
00:30:17,412 --> 00:30:19,340
AUDIENCE: So it's "a"
and then "2."

480
00:30:19,340 --> 00:30:24,040
PROFESSOR: "a" and then
"2" is one conjecture.

481
00:30:24,040 --> 00:30:25,290
Let's find out.

482
00:30:25,290 --> 00:30:33,090

483
00:30:33,090 --> 00:30:38,340
"a" and then "3." Why?

484
00:30:38,340 --> 00:30:45,530
Because what happened here is,
when I did the assignment to

485
00:30:45,530 --> 00:30:54,740
L1, what that effectively did
was swing this pointer to

486
00:30:54,740 --> 00:31:00,900
point to the new list containing
the element 2, but

487
00:31:00,900 --> 00:31:03,010
had no effect on this object.

488
00:31:03,010 --> 00:31:07,170

489
00:31:07,170 --> 00:31:10,150
I was changing the binding
of the identifier.

490
00:31:10,150 --> 00:31:14,050
I was not mutating
this object.

491
00:31:14,050 --> 00:31:19,590
And so this element still points
to the same list, which

492
00:31:19,590 --> 00:31:22,300
was not mutated.

493
00:31:22,300 --> 00:31:25,290
That makes sense now?

494
00:31:25,290 --> 00:31:27,590
So you have to get your
head around the way

495
00:31:27,590 --> 00:31:28,840
all this stuff works.

496
00:31:28,840 --> 00:31:33,810

497
00:31:33,810 --> 00:31:37,610
Anybody have a question about
why this is what it did?

498
00:31:37,610 --> 00:31:43,260

499
00:31:43,260 --> 00:31:47,615
All right, if not, we'll
just roar right along.

500
00:31:47,615 --> 00:31:56,840

501
00:31:56,840 --> 00:32:02,790
So now, we can do
various things.

502
00:32:02,790 --> 00:32:04,040
And we'll get some stuff.

503
00:32:04,040 --> 00:32:12,640

504
00:32:12,640 --> 00:32:14,365
All right, moving right along.

505
00:32:14,365 --> 00:32:17,870

506
00:32:17,870 --> 00:32:21,690
Here's an interesting little
program not in your hand out.

507
00:32:21,690 --> 00:32:29,220

508
00:32:29,220 --> 00:32:31,035
Let me get rid of
all this cruft.

509
00:32:31,035 --> 00:32:40,170

510
00:32:40,170 --> 00:32:42,680
So here's a function,
copylist.

511
00:32:42,680 --> 00:32:47,170
It takes a source list and
a destination list.

512
00:32:47,170 --> 00:32:50,960
And for e in the source list, it
appends it to whatever the

513
00:32:50,960 --> 00:32:52,820
destination list used to be.

514
00:32:52,820 --> 00:32:58,120

515
00:32:58,120 --> 00:33:00,660
And then, I'm just putting in
a little print statement so

516
00:33:00,660 --> 00:33:05,340
we'll be able to see as it
runs what it's doing.

517
00:33:05,340 --> 00:33:08,670
So I'm going to say L1 is
equal to the empty list.

518
00:33:08,670 --> 00:33:11,900
L2 is 1, 2, 3.

519
00:33:11,900 --> 00:33:15,530
And I'm going to copylist
L2 to L1.

520
00:33:15,530 --> 00:33:18,270
Print L1 and L2.

521
00:33:18,270 --> 00:33:20,245
So what am I going to get when
I print those things?

522
00:33:20,245 --> 00:33:23,490

523
00:33:23,490 --> 00:33:24,740
This is the easy question.

524
00:33:24,740 --> 00:33:28,730

525
00:33:28,730 --> 00:33:30,790
Don't tell me I have you
so intimidated that

526
00:33:30,790 --> 00:33:31,530
you think I'm playing.

527
00:33:31,530 --> 00:33:33,570
This is not a trick question.

528
00:33:33,570 --> 00:33:34,050
Pardon?

529
00:33:34,050 --> 00:33:36,080
AUDIENCE: 1, 2, 3 for
both of them?

530
00:33:36,080 --> 00:33:38,110
PROFESSOR: 1, 2, 3
for both of them.

531
00:33:38,110 --> 00:33:39,920
Who said that?

532
00:33:39,920 --> 00:33:41,170
Raise your hand.

533
00:33:41,170 --> 00:33:43,080

534
00:33:43,080 --> 00:33:44,000
Someone back--

535
00:33:44,000 --> 00:33:46,210
oh, good grief, all the
way in the back.

536
00:33:46,210 --> 00:33:48,720
All right.

537
00:33:48,720 --> 00:33:52,420
Oh no, not even close!

538
00:33:52,420 --> 00:33:56,410
Off by a row, and about
four people, too.

539
00:33:56,410 --> 00:33:57,740
OK.

540
00:33:57,740 --> 00:33:58,990
so let's try it.

541
00:33:58,990 --> 00:34:03,980

542
00:34:03,980 --> 00:34:07,340
1, 2, 3, 1, 2, 3.

543
00:34:07,340 --> 00:34:08,974
So exactly as predicted.

544
00:34:08,974 --> 00:34:14,610

545
00:34:14,610 --> 00:34:17,320
Now comes the trick question.

546
00:34:17,320 --> 00:34:21,699

547
00:34:21,699 --> 00:34:23,000
What is this going to do?

548
00:34:23,000 --> 00:34:26,400

549
00:34:26,400 --> 00:34:27,650
Pardon?

550
00:34:27,650 --> 00:34:38,239

551
00:34:38,239 --> 00:34:40,190
Well, we'll print L1 here.

552
00:34:40,190 --> 00:34:44,750

553
00:34:44,750 --> 00:34:46,199
What do you think it'll
do when it gets

554
00:34:46,199 --> 00:34:47,449
to that print statement?

555
00:34:47,449 --> 00:34:55,630

556
00:34:55,630 --> 00:34:57,160
Will it get to that
print statement?

557
00:34:57,160 --> 00:34:59,490
Let me ask that question.

558
00:34:59,490 --> 00:35:00,740
Will it ever get there?

559
00:35:00,740 --> 00:35:08,905

560
00:35:08,905 --> 00:35:09,880
AUDIENCE: No.

561
00:35:09,880 --> 00:35:10,960
PROFESSOR: No.

562
00:35:10,960 --> 00:35:12,450
Bingo.

563
00:35:12,450 --> 00:35:13,700
Let's run it.

564
00:35:13,700 --> 00:35:20,600

565
00:35:20,600 --> 00:35:25,215
And you'll see LDest just gets
longer and longer and longer.

566
00:35:25,215 --> 00:35:28,040

567
00:35:28,040 --> 00:35:29,290
Why is that happening?

568
00:35:29,290 --> 00:35:32,490

569
00:35:32,490 --> 00:35:39,030
Because what it's attempting to
do is look at LSource and

570
00:35:39,030 --> 00:35:43,600
copy the remaining elements
of LSource to LDest.

571
00:35:43,600 --> 00:35:48,540
But every time I go through the
loop, what we have is a

572
00:35:48,540 --> 00:36:01,580
situation where the formal
LSource and LDest are now

573
00:36:01,580 --> 00:36:03,840
pointing to the same object.

574
00:36:03,840 --> 00:36:09,260

575
00:36:09,260 --> 00:36:13,340
So every time I modify LDest,
I am modifying the object to

576
00:36:13,340 --> 00:36:16,360
which LSource points to.

577
00:36:16,360 --> 00:36:18,660
And I keep finding yet another
thing to copy.

578
00:36:18,660 --> 00:36:21,830

579
00:36:21,830 --> 00:36:29,130
This is an example of what's
called an alias, one object

580
00:36:29,130 --> 00:36:33,815
with two names, or in general
multiple names.

581
00:36:33,815 --> 00:36:52,090

582
00:36:52,090 --> 00:36:56,420
When you have immutable
objects, aliasing

583
00:36:56,420 --> 00:36:59,260
is perfectly harmless.

584
00:36:59,260 --> 00:37:05,070
If you have 58 different names
for the object 3, it doesn't

585
00:37:05,070 --> 00:37:08,580
matter because you can never
change what 3 means.

586
00:37:08,580 --> 00:37:11,310

587
00:37:11,310 --> 00:37:14,780
Here, where you have multiple
names for the same mutable

588
00:37:14,780 --> 00:37:21,790
object, you can get massive
confusion when you modify it

589
00:37:21,790 --> 00:37:26,360
through one name and then
forget that it's being

590
00:37:26,360 --> 00:37:27,610
accessed through another.

591
00:37:27,610 --> 00:37:30,030

592
00:37:30,030 --> 00:37:32,590
So it's something
to worry about.

593
00:37:32,590 --> 00:37:37,820

594
00:37:37,820 --> 00:37:41,020
As with tuples, you
can slice lists.

595
00:37:41,020 --> 00:37:43,640
You can index into lists.

596
00:37:43,640 --> 00:37:45,410
You can concatenate lists.

597
00:37:45,410 --> 00:37:47,850
You can do all the
usual things.

598
00:37:47,850 --> 00:37:49,980
I'm not going to list all
of the operators.

599
00:37:49,980 --> 00:37:52,390
And there are a lot of
very nice operators.

600
00:37:52,390 --> 00:37:56,860
But we'll post readings where
you can find what operators

601
00:37:56,860 --> 00:37:58,190
are available.

602
00:37:58,190 --> 00:38:03,360
I now want to move on to the
third built-in type that

603
00:38:03,360 --> 00:38:06,330
collects values, and that's
a dictionary.

604
00:38:06,330 --> 00:38:10,120

605
00:38:10,120 --> 00:38:17,880
A dictionary differs from
a list in two ways.

606
00:38:17,880 --> 00:38:21,800
One, the elements
are not ordered.

607
00:38:21,800 --> 00:38:28,796
And two, more profoundly, the
indices need not be integers.

608
00:38:28,796 --> 00:38:40,640

609
00:38:40,640 --> 00:38:42,460
And they're not called
indices.

610
00:38:42,460 --> 00:38:43,710
They're called keys.

611
00:38:43,710 --> 00:38:52,370

612
00:38:52,370 --> 00:38:57,245
They can be any immutable
type.

613
00:38:57,245 --> 00:39:06,740

614
00:39:06,740 --> 00:39:08,790
So we'll look at a simple
example first.

615
00:39:08,790 --> 00:39:25,990

616
00:39:25,990 --> 00:39:29,860
So here, I'm creating
a new dict.

617
00:39:29,860 --> 00:39:34,290
We use set braces rather than
square braces to remind

618
00:39:34,290 --> 00:39:39,010
ourselves that the elements
are not ordered.

619
00:39:39,010 --> 00:39:44,100
And I'm saying the first
key is the number 1.

620
00:39:44,100 --> 00:39:52,640
And that's bound to the string
object "1, 1." And then the

621
00:39:52,640 --> 00:39:58,140
second key is the string object
deux, which is bound to

622
00:39:58,140 --> 00:40:01,100
the string object 2.

623
00:40:01,100 --> 00:40:04,210
And the third one is the string
object pi which is

624
00:40:04,210 --> 00:40:11,670
bound to the float 3.14159.

625
00:40:11,670 --> 00:40:16,280
Now I can then index into it.

626
00:40:16,280 --> 00:40:22,870
So for example, if I choose to,
I can write something like

627
00:40:22,870 --> 00:40:27,700
print d sub pi.

628
00:40:27,700 --> 00:40:32,010

629
00:40:32,010 --> 00:40:34,970
I'll just stop it here with my
old trick of asserting false.

630
00:40:34,970 --> 00:40:40,230

631
00:40:40,230 --> 00:40:43,440
And you'll see it will
print the value with

632
00:40:43,440 --> 00:40:46,040
which the key is bound--

633
00:40:46,040 --> 00:40:47,290
to which the key is bound.

634
00:40:47,290 --> 00:40:51,600

635
00:40:51,600 --> 00:41:07,935
So what we have here is a dict
is a set of key value pairs.

636
00:41:07,935 --> 00:41:15,410

637
00:41:15,410 --> 00:41:19,620
And I can access it by
looking at the keys.

638
00:41:19,620 --> 00:41:27,730

639
00:41:27,730 --> 00:41:31,300
I can do an assignment,
d1 equals d, just

640
00:41:31,300 --> 00:41:32,340
as I can with lists.

641
00:41:32,340 --> 00:41:35,100
And now, I remember this
is a real assignment.

642
00:41:35,100 --> 00:41:39,990
So now, I have an alias,
two identifiers

643
00:41:39,990 --> 00:41:42,420
pointing to the same dict.

644
00:41:42,420 --> 00:41:49,340
I can then print d1 sub 1,
either print it or I could

645
00:41:49,340 --> 00:41:51,060
assign to it.

646
00:41:51,060 --> 00:41:52,250
So let's do that.

647
00:41:52,250 --> 00:42:00,770
First, we'll print it just
to show what we get.

648
00:42:00,770 --> 00:42:05,620
Then, I'm going to do an
assignment, saying, OK, I want

649
00:42:05,620 --> 00:42:11,940
to now change the binding in
d of the key one to be uno

650
00:42:11,940 --> 00:42:14,040
rather than one.

651
00:42:14,040 --> 00:42:15,480
And we'll get something
different.

652
00:42:15,480 --> 00:42:16,730
Let's just run this.

653
00:42:16,730 --> 00:42:23,340

654
00:42:23,340 --> 00:42:27,340
So you'll note, as we would have
guessed, with mutability,

655
00:42:27,340 --> 00:42:28,590
we see it showing up.

656
00:42:28,590 --> 00:42:35,570

657
00:42:35,570 --> 00:42:41,290
So far, just like lists, the
difference being we have key

658
00:42:41,290 --> 00:42:45,530
value pairs rather than you
could think of a list as being

659
00:42:45,530 --> 00:42:47,330
int value pairs.

660
00:42:47,330 --> 00:42:49,950
The indices of a list
are always ints.

661
00:42:49,950 --> 00:42:54,120
Associated with each of those
ints, we have a value.

662
00:42:54,120 --> 00:42:59,810
Let's look at a more fun example
showing what we can do

663
00:42:59,810 --> 00:43:02,360
with dictionaries.

664
00:43:02,360 --> 00:43:09,130
So here, I have a very simple
dictionary called EtoF, for

665
00:43:09,130 --> 00:43:11,810
English to French.

666
00:43:11,810 --> 00:43:13,610
And we can do some
things with it.

667
00:43:13,610 --> 00:43:29,670

668
00:43:29,670 --> 00:43:31,980
So I can print it.

669
00:43:31,980 --> 00:43:33,420
And that's kind of
interesting.

670
00:43:33,420 --> 00:43:35,160
Let's see what we get
when we print it.

671
00:43:35,160 --> 00:43:49,770

672
00:43:49,770 --> 00:43:50,840
So it's printing it.

673
00:43:50,840 --> 00:43:54,020
And you'll notice the order in
which it's printed, the key

674
00:43:54,020 --> 00:43:59,590
value pairs, is not the order
in which I typed them.

675
00:43:59,590 --> 00:44:07,950

676
00:44:07,950 --> 00:44:09,510
That's OK.

677
00:44:09,510 --> 00:44:14,710
The order in which it prints
them is not defined by Python.

678
00:44:14,710 --> 00:44:17,860
So there's no way to
predict the order.

679
00:44:17,860 --> 00:44:22,110
And that makes sense because, by
specification, dictionaries

680
00:44:22,110 --> 00:44:23,250
are unordered.

681
00:44:23,250 --> 00:44:24,730
They're sets, not sequences.

682
00:44:24,730 --> 00:44:33,970

683
00:44:33,970 --> 00:44:41,980
I can print keys, EtoF
keys, open, close.

684
00:44:41,980 --> 00:44:47,850
Keys is a method on dicts
that returns the keys.

685
00:44:47,850 --> 00:44:50,660
And then, just for fun, I'm
going to try to print

686
00:44:50,660 --> 00:44:53,600
EtoF.keys without
the open, close.

687
00:44:53,600 --> 00:45:01,640

688
00:45:01,640 --> 00:45:05,030
So you'll see when I first
printed it with the open,

689
00:45:05,030 --> 00:45:11,380
closed, I got all of the keys
in an order that was not

690
00:45:11,380 --> 00:45:13,330
necessarily predictable.

691
00:45:13,330 --> 00:45:15,720
Certainly not the order
in which I typed them.

692
00:45:15,720 --> 00:45:16,670
But that's nice.

693
00:45:16,670 --> 00:45:21,310
I now have this sequence
of keys that I

694
00:45:21,310 --> 00:45:24,370
could do things with.

695
00:45:24,370 --> 00:45:27,500
When I typed it without the
open, close, and I wanted you

696
00:45:27,500 --> 00:45:33,610
to see this, it just says it's
a method, a built-in method.

697
00:45:33,610 --> 00:45:37,380
It does not execute
the method, right?

698
00:45:37,380 --> 00:45:39,350
That's fine.

699
00:45:39,350 --> 00:45:43,960
But again, you have to be
careful that you'll find this

700
00:45:43,960 --> 00:45:46,060
happening when you write code.

701
00:45:46,060 --> 00:45:49,250
You'll forget to write
the open, close.

702
00:45:49,250 --> 00:45:51,460
And you'll wonder why your
program isn't doing what you

703
00:45:51,460 --> 00:45:53,690
expect it to do.

704
00:45:53,690 --> 00:45:56,440
Remember, it's not saying
that the method,

705
00:45:56,440 --> 00:45:58,560
keys, has no argument.

706
00:45:58,560 --> 00:46:00,450
It has one argument.

707
00:46:00,450 --> 00:46:03,000
In this case, EtoF.

708
00:46:03,000 --> 00:46:07,000
And the open, close is basically
saying, all right,

709
00:46:07,000 --> 00:46:12,110
call the method rather than
the method itself.

710
00:46:12,110 --> 00:46:13,780
Again, this will be
very important

711
00:46:13,780 --> 00:46:19,790
when we get to classes.

712
00:46:19,790 --> 00:46:22,160
Let's get rid of some of these
print statements now.

713
00:46:22,160 --> 00:46:36,570

714
00:46:36,570 --> 00:46:40,460
Suppose I want to delete
something.

715
00:46:40,460 --> 00:46:47,840

716
00:46:47,840 --> 00:46:56,150
I can delete something, so
delete EtoF sub 1 del is a

717
00:46:56,150 --> 00:47:00,460
command, much like print,
that says remove

718
00:47:00,460 --> 00:47:02,140
something from EtoF.

719
00:47:02,140 --> 00:47:05,100

720
00:47:05,100 --> 00:47:06,350
So I can do that.

721
00:47:06,350 --> 00:47:11,020

722
00:47:11,020 --> 00:47:13,640
And now, something
has disappeared.

723
00:47:13,640 --> 00:47:18,910
The key value pair where
the key is one is gone.

724
00:47:18,910 --> 00:47:20,770
So that's how I remove things.

725
00:47:20,770 --> 00:47:22,150
AUDIENCE: Question.

726
00:47:22,150 --> 00:47:23,026
PROFESSOR: Yes?

727
00:47:23,026 --> 00:47:25,822
AUDIENCE: Are the keys of
dictionaries mutable?

728
00:47:25,822 --> 00:47:29,340
PROFESSOR: The keys have
to be immutable.

729
00:47:29,340 --> 00:47:32,000
You cannot use a mutable
type for a key.

730
00:47:32,000 --> 00:47:34,910

731
00:47:34,910 --> 00:47:39,060
We'll see the reason for that in
a couple of lectures when I

732
00:47:39,060 --> 00:47:43,680
talk about how dictionaries
are implemented in Python.

733
00:47:43,680 --> 00:47:46,990
They use a very clever technique
called hashing which

734
00:47:46,990 --> 00:47:49,880
would not work if the
keys were mutable.

735
00:47:49,880 --> 00:47:52,480

736
00:47:52,480 --> 00:47:55,740
So in order to get an efficient
implementation of

737
00:47:55,740 --> 00:48:00,540
dictionary look-up, we need
to have immutable keys.

738
00:48:00,540 --> 00:48:01,790
And so that's required.

739
00:48:01,790 --> 00:48:14,830

740
00:48:14,830 --> 00:48:16,080
Let's look at another example.

741
00:48:16,080 --> 00:48:19,260

742
00:48:19,260 --> 00:48:23,500
So here, I'm again setting
a dictionary.

743
00:48:23,500 --> 00:48:27,190
And now, what I'm going to show
you is that I can iterate

744
00:48:27,190 --> 00:48:31,785
through the keys and
print the values.

745
00:48:31,785 --> 00:48:34,950

746
00:48:34,950 --> 00:48:38,715
For key in d1.keys, nothing
very fancy here.

747
00:48:38,715 --> 00:48:46,290

748
00:48:46,290 --> 00:48:47,540
OK?

749
00:48:47,540 --> 00:48:49,700

750
00:48:49,700 --> 00:48:56,560
one equals uno, pi equals
3.1459, and deux equals 2.

751
00:48:56,560 --> 00:48:59,480
All right?

752
00:48:59,480 --> 00:49:03,010
So nothing very dramatic
happening here.

753
00:49:03,010 --> 00:49:06,920
Finally, just to illustrate
why this sort of thing is

754
00:49:06,920 --> 00:49:09,270
particularly useful.

755
00:49:09,270 --> 00:49:12,240
And in fact, you'll find it
quite useful in the upcoming

756
00:49:12,240 --> 00:49:13,490
problem set.

757
00:49:13,490 --> 00:49:17,240

758
00:49:17,240 --> 00:49:19,930
I'm going to do some
translations.

759
00:49:19,930 --> 00:49:23,900
This, by the way, is not the
way Google Translate works.

760
00:49:23,900 --> 00:49:25,150
It's a bit more sophisticated.

761
00:49:25,150 --> 00:49:35,410

762
00:49:35,410 --> 00:49:39,860
So I'm going to have two
functions, translateword,

763
00:49:39,860 --> 00:49:44,020
which, if it finds the word in
the dictionary, returns the

764
00:49:44,020 --> 00:49:46,480
value associated with the key.

765
00:49:46,480 --> 00:49:50,050
So note, if word in dictionary
says is there a key whose

766
00:49:50,050 --> 00:49:52,140
value is word?

767
00:49:52,140 --> 00:49:55,940
If so, return the value
associated with that key.

768
00:49:55,940 --> 00:49:58,440
Otherwise, don't even try
and translate it.

769
00:49:58,440 --> 00:50:01,660
Just leave it the way it was.

770
00:50:01,660 --> 00:50:07,670
And then, translatesentence will
set the translation equal

771
00:50:07,670 --> 00:50:11,530
to the empty string
and wordequals

772
00:50:11,530 --> 00:50:13,810
to the empty string.

773
00:50:13,810 --> 00:50:16,550
Then, it'll just collect all the
characters until it finds

774
00:50:16,550 --> 00:50:20,080
a blank, translate
the word using

775
00:50:20,080 --> 00:50:23,060
translateword, and append it.

776
00:50:23,060 --> 00:50:25,630
And when it's done,
it will print it.

777
00:50:25,630 --> 00:50:30,355
So we can now do these
translations quite simply.

778
00:50:30,355 --> 00:50:35,980

779
00:50:35,980 --> 00:50:37,270
What could be easier?

780
00:50:37,270 --> 00:50:39,940
You never again have to learn
a foreign language.

781
00:50:39,940 --> 00:50:43,300
Just use Python to do the
translations for you.

782
00:50:43,300 --> 00:50:45,120
All right, that's
it for today.

783
00:50:45,120 --> 00:50:48,590

784
00:50:48,590 --> 00:50:51,520
Remember, there is a problem set
you should be working on

785
00:50:51,520 --> 00:50:53,960
and another one that
will be posted.

786
00:50:53,960 --> 00:50:55,210
Take care.

787
00:50:55,210 --> 00:50:58,068
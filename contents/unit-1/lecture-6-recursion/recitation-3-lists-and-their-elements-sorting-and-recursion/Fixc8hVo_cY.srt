1
00:00:00,000 --> 00:00:00,530

2
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

3
00:00:02,960 --> 00:00:04,370
Commons license.

4
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

5
00:00:07,410 --> 00:00:11,060
offer high quality educational
resources for free.

6
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

7
00:00:13,960 --> 00:00:19,790
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:19,790 --> 00:00:21,040
ocw.mit.edu.

9
00:00:21,040 --> 00:00:23,050

10
00:00:23,050 --> 00:00:25,840
PROFESSOR: So let's start.

11
00:00:25,840 --> 00:00:28,980
I mean for the first question
you can answer what is tuple.

12
00:00:28,980 --> 00:00:30,870
You can go to that later.

13
00:00:30,870 --> 00:00:32,520
Can a tuple contain a list?

14
00:00:32,520 --> 00:00:35,280

15
00:00:35,280 --> 00:00:36,730
What do you think?

16
00:00:36,730 --> 00:00:38,960
Can a tuple contain a list?

17
00:00:38,960 --> 00:00:39,820
AUDIENCE: Yes.

18
00:00:39,820 --> 00:00:41,620
PROFESSOR: Yes, it can.

19
00:00:41,620 --> 00:00:43,790
So we'll go through the
examples later.

20
00:00:43,790 --> 00:00:48,890
And let's see this
first example.

21
00:00:48,890 --> 00:00:50,305
We have two tuples.

22
00:00:50,305 --> 00:00:53,500
The tuple B contains tuple
A, as well as a list.

23
00:00:53,500 --> 00:00:56,640

24
00:00:56,640 --> 00:00:57,890
So it can't populate.

25
00:00:57,890 --> 00:01:00,120

26
00:01:00,120 --> 00:01:01,630
Let's bring those lists, too.

27
00:01:01,630 --> 00:01:07,540

28
00:01:07,540 --> 00:01:14,840
So for the first example we try
to access the elements 0

29
00:01:14,840 --> 00:01:22,730
and 2 of the tuple A. And
let me use minus 1 to

30
00:01:22,730 --> 00:01:24,450
access which element?

31
00:01:24,450 --> 00:01:26,715
AUDIENCE: [INAUDIBLE]

32
00:01:26,715 --> 00:01:28,080
PROFESSOR: OK.

33
00:01:28,080 --> 00:01:30,150
And 0 is the first element,
of course.

34
00:01:30,150 --> 00:01:32,830
And remember now we
are using 0, 1.

35
00:01:32,830 --> 00:01:37,260

36
00:01:37,260 --> 00:01:39,970
OK, what is tuple B?

37
00:01:39,970 --> 00:01:42,750
It's a two-dimensional tuple.

38
00:01:42,750 --> 00:01:43,630
AUDIENCE: [INAUDIBLE]

39
00:01:43,630 --> 00:01:44,600
PROFESSOR: Yeah, exactly.

40
00:01:44,600 --> 00:01:46,860
It has a list and
a tuple inside.

41
00:01:46,860 --> 00:01:50,640
So the first element is
a tuple, and the last

42
00:01:50,640 --> 00:01:51,920
element is the list.

43
00:01:51,920 --> 00:01:54,720
So now it's sort of like
two-dimensional.

44
00:01:54,720 --> 00:01:59,960
But if you look at the first
element of it, the MIT word,

45
00:01:59,960 --> 00:02:02,420
that doesn't have
any dimension.

46
00:02:02,420 --> 00:02:04,600
Does it?

47
00:02:04,600 --> 00:02:05,320
It's a string.

48
00:02:05,320 --> 00:02:07,650
So you can again access,
but not this way.

49
00:02:07,650 --> 00:02:08,900
But still you can access.

50
00:02:08,900 --> 00:02:12,330

51
00:02:12,330 --> 00:02:18,360
And we are using this notation
to access a portion of the

52
00:02:18,360 --> 00:02:21,870
list, a part of the tuple,
actually, here.

53
00:02:21,870 --> 00:02:23,770
It's called slicing.

54
00:02:23,770 --> 00:02:27,240
So here 0 to 1 gives
you which element?

55
00:02:27,240 --> 00:02:29,760

56
00:02:29,760 --> 00:02:30,960
Just one element right?

57
00:02:30,960 --> 00:02:32,210
It's the first element.

58
00:02:32,210 --> 00:02:35,140

59
00:02:35,140 --> 00:02:40,790
0 to 2 gives you 1 and 2 OK?

60
00:02:40,790 --> 00:02:45,780
This is an interesting
usage of the slicing.

61
00:02:45,780 --> 00:02:48,695
This is used to access
the whole tuple.

62
00:02:48,695 --> 00:02:50,720
Now you might wonder
why we need them.

63
00:02:50,720 --> 00:02:52,186
We could just--

64
00:02:52,186 --> 00:02:54,920
the handouts are here.

65
00:02:54,920 --> 00:03:00,100
So why we need to copy or why
we need to access the list

66
00:03:00,100 --> 00:03:03,810
through the column operator
like this?

67
00:03:03,810 --> 00:03:04,690
We'll look at that later.

68
00:03:04,690 --> 00:03:09,090
It's very essential when
we have lists.

69
00:03:09,090 --> 00:03:12,610
For the timing it's OK when
tuples are immutable.

70
00:03:12,610 --> 00:03:15,840
So it doesn't have
a special usage.

71
00:03:15,840 --> 00:03:18,310
But later on we'll
be using it.

72
00:03:18,310 --> 00:03:20,650
Then if you look at this
part, this is the

73
00:03:20,650 --> 00:03:22,500
most interesting part.

74
00:03:22,500 --> 00:03:23,850
How do iterate through
a tuple?

75
00:03:23,850 --> 00:03:26,490

76
00:03:26,490 --> 00:03:30,770
You use a FOR loop and you call
like item in tuple, the

77
00:03:30,770 --> 00:03:33,290
element in tuple.

78
00:03:33,290 --> 00:03:37,510
The element is initialized with
every element when it

79
00:03:37,510 --> 00:03:38,990
goes through iteration.

80
00:03:38,990 --> 00:03:44,380
At every iteration it will
be instantiated with the

81
00:03:44,380 --> 00:03:46,580
corresponding element
in the tuple.

82
00:03:46,580 --> 00:03:48,315
But you're using the
same name anyway.

83
00:03:48,315 --> 00:03:49,565
It's item.

84
00:03:49,565 --> 00:03:51,450

85
00:03:51,450 --> 00:03:54,105
This is equivalent to accessing
the tuple like this.

86
00:03:54,105 --> 00:03:57,760

87
00:03:57,760 --> 00:04:00,650
Going one-by-one in the range
and accessing their

88
00:04:00,650 --> 00:04:02,330
corresponding element
in the tuple.

89
00:04:02,330 --> 00:04:05,630
So this is the simpler
way to access that.

90
00:04:05,630 --> 00:04:07,205
Do you have any questions
in that part?

91
00:04:07,205 --> 00:04:12,940

92
00:04:12,940 --> 00:04:14,900
Yeah?

93
00:04:14,900 --> 00:04:17,595
AUDIENCE: For that part, don't,
usually if you have a

94
00:04:17,595 --> 00:04:19,310
range you have to [INAUDIBLE]

95
00:04:19,310 --> 00:04:22,750
name because is not--

96
00:04:22,750 --> 00:04:24,530
PROFESSOR: OK, that's correct.

97
00:04:24,530 --> 00:04:25,610
.

98
00:04:25,610 --> 00:04:27,000
OK.

99
00:04:27,000 --> 00:04:30,040
Suppose a tuple has 3 elements,
or for example in

100
00:04:30,040 --> 00:04:33,130
this case tuple A, how many
elements are in the tuple A?

101
00:04:33,130 --> 00:04:34,250
3 elements.

102
00:04:34,250 --> 00:04:36,265
So what would be the
length of tuple A?

103
00:04:36,265 --> 00:04:36,630
AUDIENCE: 3.

104
00:04:36,630 --> 00:04:37,330
PROFESSOR: 3.

105
00:04:37,330 --> 00:04:39,650
But what would be the range?

106
00:04:39,650 --> 00:04:41,350
0, 1, 2, right?

107
00:04:41,350 --> 00:04:44,470
So you have to type 0 to 3.

108
00:04:44,470 --> 00:04:47,180
So that's why I put that, OK?

109
00:04:47,180 --> 00:04:50,678
That is 3, OK?

110
00:04:50,678 --> 00:04:51,176
PROFESSOR: You.

111
00:04:51,176 --> 00:04:54,247
AUDIENCE: So you just say a
range like the tuple is, it

112
00:04:54,247 --> 00:04:55,170
seems like the first one--

113
00:04:55,170 --> 00:04:57,264
PROFESSOR: First the 0 if you
don't specify it the same way.

114
00:04:57,264 --> 00:05:08,200

115
00:05:08,200 --> 00:05:08,880
OK.

116
00:05:08,880 --> 00:05:10,370
Now let's go through the list.

117
00:05:10,370 --> 00:05:18,730

118
00:05:18,730 --> 00:05:22,620
So if you go through the
questions, what is the

119
00:05:22,620 --> 00:05:24,330
difference between a
list and a tuple?

120
00:05:24,330 --> 00:05:27,990

121
00:05:27,990 --> 00:05:30,293
What is the difference between
a list and a tuple?

122
00:05:30,293 --> 00:05:31,682
Anyone?

123
00:05:31,682 --> 00:05:33,534
Yeah?

124
00:05:33,534 --> 00:05:34,923
AUDIENCE: Tuples
are immutable.

125
00:05:34,923 --> 00:05:35,390
PROFESSOR: OK.

126
00:05:35,390 --> 00:05:36,450
Lists are mutable.

127
00:05:36,450 --> 00:05:41,190
And because it's mutable it
takes special functions to

128
00:05:41,190 --> 00:05:44,470
access the elements,
add elements, and

129
00:05:44,470 --> 00:05:46,220
modify the list itself.

130
00:05:46,220 --> 00:05:49,210

131
00:05:49,210 --> 00:05:51,535
How would you add an
element to a list?

132
00:05:51,535 --> 00:05:54,370

133
00:05:54,370 --> 00:06:05,920
Suppose you have list A. How
would you add 3 to this list?

134
00:06:05,920 --> 00:06:10,600

135
00:06:10,600 --> 00:06:12,472
AUDIENCE: [INAUDIBLE]

136
00:06:12,472 --> 00:06:12,950
PROFESSOR: OK.

137
00:06:12,950 --> 00:06:14,200
Let's start our print.

138
00:06:14,200 --> 00:06:20,978

139
00:06:20,978 --> 00:06:22,120
OK.

140
00:06:22,120 --> 00:06:24,505
That's good.

141
00:06:24,505 --> 00:06:25,755
OK?

142
00:06:25,755 --> 00:06:30,950

143
00:06:30,950 --> 00:06:33,810
How would you remove
the element from

144
00:06:33,810 --> 00:06:34,830
the top of the list?

145
00:06:34,830 --> 00:06:36,480
Or the last element, how
would you remove

146
00:06:36,480 --> 00:06:38,720
this 3 from the list?

147
00:06:38,720 --> 00:06:42,129

148
00:06:42,129 --> 00:06:43,379
AUDIENCE: [INAUDIBLE]

149
00:06:43,379 --> 00:06:50,900

150
00:06:50,900 --> 00:06:52,260
PROFESSOR: This one?

151
00:06:52,260 --> 00:06:53,510
Let's see.

152
00:06:53,510 --> 00:07:00,598

153
00:07:00,598 --> 00:07:04,950
You know how to check
the specification

154
00:07:04,950 --> 00:07:07,270
of a function, right?

155
00:07:07,270 --> 00:07:08,520
Sorry.

156
00:07:08,520 --> 00:07:15,620

157
00:07:15,620 --> 00:07:17,430
So it's not the right
function, right?

158
00:07:17,430 --> 00:07:19,930
Because it says it removes
the first occurrence of a

159
00:07:19,930 --> 00:07:23,380
particular value you are parsing
to that function.

160
00:07:23,380 --> 00:07:25,100
OK, there's another function.

161
00:07:25,100 --> 00:07:26,700
It's called list.pop.

162
00:07:26,700 --> 00:07:30,860

163
00:07:30,860 --> 00:07:34,060
That removes the last inserted
value, so it

164
00:07:34,060 --> 00:07:37,300
pops from the top.

165
00:07:37,300 --> 00:07:40,430
So remove can be used to remove
a particular element.

166
00:07:40,430 --> 00:07:42,890
So here suppose we
want to remove 1.

167
00:07:42,890 --> 00:07:46,340
So we could say list
A, remove 1.

168
00:07:46,340 --> 00:07:50,116

169
00:07:50,116 --> 00:07:51,060
OK.

170
00:07:51,060 --> 00:07:53,200
So in this example,
actually, I have

171
00:07:53,200 --> 00:07:56,150
commented out this line.

172
00:07:56,150 --> 00:07:58,260
This will be an error
if I execute.

173
00:07:58,260 --> 00:07:59,510
Why?

174
00:07:59,510 --> 00:08:04,480

175
00:08:04,480 --> 00:08:06,280
Why will it give you an error?

176
00:08:06,280 --> 00:08:09,105

177
00:08:09,105 --> 00:08:10,480
AUDIENCE: [INAUDIBLE]

178
00:08:10,480 --> 00:08:11,875
PROFESSOR: It doesn't exit.

179
00:08:11,875 --> 00:08:14,110
Great.

180
00:08:14,110 --> 00:08:17,520
So the problem here is we can't
access an element in the

181
00:08:17,520 --> 00:08:20,610
list unless we explicitly
assign

182
00:08:20,610 --> 00:08:23,450
something or create something.

183
00:08:23,450 --> 00:08:28,720
But suppose we want to pass
a list of 10 elements to a

184
00:08:28,720 --> 00:08:31,770
program so that it can assign
values on the fly.

185
00:08:31,770 --> 00:08:33,490
And it can modify.

186
00:08:33,490 --> 00:08:34,299
OK?

187
00:08:34,299 --> 00:08:38,133
So how would you pass an empty
list of 10 elements?

188
00:08:38,133 --> 00:08:41,235

189
00:08:41,235 --> 00:08:42,179
OK.

190
00:08:42,179 --> 00:08:44,800
The problem is if you're passing
something like this,

191
00:08:44,800 --> 00:08:50,850
you need to know how this list
should be instantiated.

192
00:08:50,850 --> 00:08:54,080
So you should know what
are the initial

193
00:08:54,080 --> 00:08:57,090
values of these elements.

194
00:08:57,090 --> 00:09:01,610
Suppose you want to create
a list of ten 0's.

195
00:09:01,610 --> 00:09:03,670
Then the easiest way to
create the list is--

196
00:09:03,670 --> 00:09:09,070

197
00:09:09,070 --> 00:09:12,220
So you would create a list
with ten elements.

198
00:09:12,220 --> 00:09:15,670
But If you don't want to waste
memory, or if you don't want

199
00:09:15,670 --> 00:09:18,790
to keep anything particular,
you could do

200
00:09:18,790 --> 00:09:20,040
something like this.

201
00:09:20,040 --> 00:09:24,730

202
00:09:24,730 --> 00:09:29,210
Now this will create a
list of empty list.

203
00:09:29,210 --> 00:09:32,490
And there'll be ten
such empty lists.

204
00:09:32,490 --> 00:09:34,390
OK?

205
00:09:34,390 --> 00:09:37,090
And you could pass this list to
a program so that it will

206
00:09:37,090 --> 00:09:38,340
assign the elements.

207
00:09:38,340 --> 00:09:40,930

208
00:09:40,930 --> 00:09:41,760
OK?

209
00:09:41,760 --> 00:09:45,900
You can iterate to the
list the same way.

210
00:09:45,900 --> 00:09:48,010
But lists are interesting.

211
00:09:48,010 --> 00:09:48,440
Why?

212
00:09:48,440 --> 00:09:49,870
They are mutable.

213
00:09:49,870 --> 00:09:53,370
So they can be actually used
to create interesting

214
00:09:53,370 --> 00:09:54,870
mathematical objects.

215
00:09:54,870 --> 00:09:58,070
For example, like matrix.

216
00:09:58,070 --> 00:10:00,330
So how would you create
a matrix using lists?

217
00:10:00,330 --> 00:10:03,230

218
00:10:03,230 --> 00:10:04,390
Any ideas?

219
00:10:04,390 --> 00:10:06,610
How would you create,
say a 2 by 2 matrix?

220
00:10:06,610 --> 00:10:11,280

221
00:10:11,280 --> 00:10:17,160
If you consider this example,
this creates a matrix 4 by 2.

222
00:10:17,160 --> 00:10:20,370

223
00:10:20,370 --> 00:10:23,495
So that would be like 4
rows and 2 columns.

224
00:10:23,495 --> 00:10:26,790

225
00:10:26,790 --> 00:10:31,310
But how can you go and
access the inner

226
00:10:31,310 --> 00:10:33,870
element or inner matrix?

227
00:10:33,870 --> 00:10:37,070
So if you suppose you want
access 2, 3, that is the third

228
00:10:37,070 --> 00:10:39,570
row, then how would
you access?

229
00:10:39,570 --> 00:10:42,870

230
00:10:42,870 --> 00:10:45,220
How would you call M?

231
00:10:45,220 --> 00:10:48,391

232
00:10:48,391 --> 00:10:48,850
AUDIENCE: M3?

233
00:10:48,850 --> 00:10:50,700
PROFESSOR: M3.

234
00:10:50,700 --> 00:10:53,200
M3 gives you 2, 3.

235
00:10:53,200 --> 00:10:58,190
Suppose you want to access
the 3 and the 2, 3.

236
00:10:58,190 --> 00:10:58,650
Then we--

237
00:10:58,650 --> 00:10:59,570
[INTERPOSING VOICES]

238
00:10:59,570 --> 00:11:01,508
PROFESSOR: Sorry.

239
00:11:01,508 --> 00:11:04,610
AUDIENCE: Why does a 3
give you [INAUDIBLE]?

240
00:11:04,610 --> 00:11:06,270
PROFESSOR: Oh, sorry.

241
00:11:06,270 --> 00:11:07,520
My bad.

242
00:11:07,520 --> 00:11:11,440

243
00:11:11,440 --> 00:11:11,920
Yeah.

244
00:11:11,920 --> 00:11:12,400
OK.

245
00:11:12,400 --> 00:11:13,920
This is computer science,
not maths.

246
00:11:13,920 --> 00:11:17,240

247
00:11:17,240 --> 00:11:19,040
You got it right, why
it's not 3, it's 2?

248
00:11:19,040 --> 00:11:19,496
AUDIENCE: Yeah.

249
00:11:19,496 --> 00:11:21,320
I thought you were talking
about 3 and 4.

250
00:11:21,320 --> 00:11:21,652
PROFESSOR: OK.

251
00:11:21,652 --> 00:11:22,430
That's fine.

252
00:11:22,430 --> 00:11:25,520
So I'm asking now how
would you access the

253
00:11:25,520 --> 00:11:29,482
3 in the 2, 3 box?

254
00:11:29,482 --> 00:11:33,258
AUDIENCE: So I need to do
another parentheses?

255
00:11:33,258 --> 00:11:33,730
PROFESSOR: Not a bracket.

256
00:11:33,730 --> 00:11:34,202
AUDIENCE: OK.

257
00:11:34,202 --> 00:11:35,620
PROFESSOR: OK.

258
00:11:35,620 --> 00:11:38,390
That is all.

259
00:11:38,390 --> 00:11:42,290
So you can access matrices
like this.

260
00:11:42,290 --> 00:11:45,454

261
00:11:45,454 --> 00:11:45,910
OK.

262
00:11:45,910 --> 00:11:47,765
Great.

263
00:11:47,765 --> 00:11:49,015
We are on time.

264
00:11:49,015 --> 00:11:59,870

265
00:11:59,870 --> 00:12:02,990
So this actually gives you
a summary of functions.

266
00:12:02,990 --> 00:12:05,170
Associated functions.

267
00:12:05,170 --> 00:12:07,930
For example the pop I
explained earlier.

268
00:12:07,930 --> 00:12:10,810
Remove removes a particular
element.

269
00:12:10,810 --> 00:12:14,080
Extent, that's interesting.

270
00:12:14,080 --> 00:12:17,640
Can you tell me what
it does here, the

271
00:12:17,640 --> 00:12:19,590
method extent on list?

272
00:12:19,590 --> 00:12:36,880

273
00:12:36,880 --> 00:12:38,757
What does that method take?

274
00:12:38,757 --> 00:12:42,030

275
00:12:42,030 --> 00:12:44,640
It takes another list.

276
00:12:44,640 --> 00:12:49,660
So which means it's going to
merge the list you are passing

277
00:12:49,660 --> 00:12:52,460
with the list you're calling
the method on, that is

278
00:12:52,460 --> 00:12:54,000
[UNINTELLIGIBLE].

279
00:12:54,000 --> 00:12:56,430
So it's going to combine
those lists.

280
00:12:56,430 --> 00:12:57,680
Let's see.

281
00:12:57,680 --> 00:13:04,440

282
00:13:04,440 --> 00:13:06,705
So this corresponds to this.

283
00:13:06,705 --> 00:13:09,590

284
00:13:09,590 --> 00:13:10,965
So two lists are combined.

285
00:13:10,965 --> 00:13:13,720

286
00:13:13,720 --> 00:13:16,300
So this method is actually
useful, right, because you

287
00:13:16,300 --> 00:13:17,750
don't have to write yourself.

288
00:13:17,750 --> 00:13:19,580
Most of things you
can easily do.

289
00:13:19,580 --> 00:13:23,965
Now the question is, why tuple
didn't have these methods?

290
00:13:23,965 --> 00:13:26,640

291
00:13:26,640 --> 00:13:27,890
Why?

292
00:13:27,890 --> 00:13:30,040

293
00:13:30,040 --> 00:13:33,946
Why we didn't have these
methods for tuples?

294
00:13:33,946 --> 00:13:34,850
AUDIENCE: [INAUDIBLE]

295
00:13:34,850 --> 00:13:35,680
PROFESSOR: They're immutable.

296
00:13:35,680 --> 00:13:37,160
So you can't extent, you
can't [UNINTELLIGIBLE].

297
00:13:37,160 --> 00:13:39,360
So even if you extent,
what would happen?

298
00:13:39,360 --> 00:13:41,861
It's going to create
a new tuple.

299
00:13:41,861 --> 00:13:43,520
Actually, you can do that.

300
00:13:43,520 --> 00:13:44,420
But like this.

301
00:13:44,420 --> 00:13:50,860
For example, you have tuple
A which is 1, 2.

302
00:13:50,860 --> 00:13:54,470
And suppose you have
tuple B --

303
00:13:54,470 --> 00:13:55,960
3, 4.

304
00:13:55,960 --> 00:13:58,610
If you want to combine them,
how would you do it?

305
00:13:58,610 --> 00:14:01,440

306
00:14:01,440 --> 00:14:07,500
Tuple A plus tuple B. OK?

307
00:14:07,500 --> 00:14:09,150
That concatenates.

308
00:14:09,150 --> 00:14:13,256
This operator is all
loaded for tuples.

309
00:14:13,256 --> 00:14:14,506
OK?

310
00:14:14,506 --> 00:14:20,680

311
00:14:20,680 --> 00:14:24,810
So lists are mutable so you can
do all of these things.

312
00:14:24,810 --> 00:14:26,380
Let's look at a few other
examples, too.

313
00:14:26,380 --> 00:14:51,590

314
00:14:51,590 --> 00:14:52,840
OK.

315
00:14:52,840 --> 00:14:55,230

316
00:14:55,230 --> 00:14:58,100
There's an interesting
part here.

317
00:14:58,100 --> 00:14:59,310
Lists are mutable.

318
00:14:59,310 --> 00:15:00,950
That we understand.

319
00:15:00,950 --> 00:15:08,970
But how these lists are actually
stored in the memory,

320
00:15:08,970 --> 00:15:14,360
For example, suppose you
have a list lst,

321
00:15:14,360 --> 00:15:17,103
sorry, 0, 1, apple.

322
00:15:17,103 --> 00:15:21,180

323
00:15:21,180 --> 00:15:22,920
How do you think it's stored
in the memory?

324
00:15:22,920 --> 00:15:27,080

325
00:15:27,080 --> 00:15:28,965
So you have 3 elements.

326
00:15:28,965 --> 00:15:31,770
But these elements are actually
not stored in the

327
00:15:31,770 --> 00:15:34,570
list itself.

328
00:15:34,570 --> 00:15:36,560
They actually in the memory.

329
00:15:36,560 --> 00:15:37,810
0, 1, apple.

330
00:15:37,810 --> 00:15:40,920

331
00:15:40,920 --> 00:15:44,260
But you have the pointers
to those lists.

332
00:15:44,260 --> 00:15:48,000
Sorry, to those elements.

333
00:15:48,000 --> 00:15:53,480
So actually you can modify these
values without changing

334
00:15:53,480 --> 00:15:57,625
the list itself, because the
list actually points to this

335
00:15:57,625 --> 00:16:00,970
part, the container.

336
00:16:00,970 --> 00:16:06,220
So in this example you have list
A and B. But the list B

337
00:16:06,220 --> 00:16:09,780
actually contains list A. OK?

338
00:16:09,780 --> 00:16:15,340
Since list A is mutable you
can go and change it.

339
00:16:15,340 --> 00:16:18,970
So here first you print list A
and B, but you're going to

340
00:16:18,970 --> 00:16:21,020
change list A's 0th element.

341
00:16:21,020 --> 00:16:24,800

342
00:16:24,800 --> 00:16:30,290
After changing the element
the list A becomes first.

343
00:16:30,290 --> 00:16:34,730
Its first element
changed to 88.

344
00:16:34,730 --> 00:16:35,980
OK.

345
00:16:35,980 --> 00:16:37,890

346
00:16:37,890 --> 00:16:40,480
Fine.

347
00:16:40,480 --> 00:16:42,420
What do you think the
list B would be?

348
00:16:42,420 --> 00:16:48,252

349
00:16:48,252 --> 00:16:49,502
OK, let's print.

350
00:16:49,502 --> 00:16:55,270

351
00:16:55,270 --> 00:16:58,900
It contains the 88, right,
the modified value.

352
00:16:58,900 --> 00:17:00,150
Why?

353
00:17:00,150 --> 00:17:02,540

354
00:17:02,540 --> 00:17:12,280
Because list B actually had a
pointer to list A. Which again

355
00:17:12,280 --> 00:17:14,859
had pointers to other
elements.

356
00:17:14,859 --> 00:17:18,410
And we modified this
value to 88.

357
00:17:18,410 --> 00:17:22,339
So you're still accessing
list B. OK?

358
00:17:22,339 --> 00:17:26,170
The pointers are not changed.

359
00:17:26,170 --> 00:17:28,890
That we can see here, in
the second example,

360
00:17:28,890 --> 00:17:31,230
the problem of aliasing.

361
00:17:31,230 --> 00:17:37,270
So we have list X. And we call
it by list Y as well.

362
00:17:37,270 --> 00:17:42,110
And we are now changing
the list Y. Sorry.

363
00:17:42,110 --> 00:17:45,850
We are changing the list X. But
it's going to affect list

364
00:17:45,850 --> 00:17:51,740
X as well as list Y. See?

365
00:17:51,740 --> 00:17:54,360
Because it's just a reference.

366
00:17:54,360 --> 00:17:57,170
The actual object is this.

367
00:17:57,170 --> 00:17:59,000
You can call it by two
different names.

368
00:17:59,000 --> 00:17:59,570
It doesn't matter.

369
00:17:59,570 --> 00:18:00,820
But the actual object is here.

370
00:18:00,820 --> 00:18:05,150

371
00:18:05,150 --> 00:18:07,315
That's where we need
this operator.

372
00:18:07,315 --> 00:18:10,970

373
00:18:10,970 --> 00:18:15,640
So if you just point, OK, for
example we had list X, if you

374
00:18:15,640 --> 00:18:20,000
just assign list Y to list X,
it's not going to copy the

375
00:18:20,000 --> 00:18:23,170
elements, just going to
copy the reference.

376
00:18:23,170 --> 00:18:29,250
Which means list X and list Y,
both would be pointing to the

377
00:18:29,250 --> 00:18:32,420
same object.

378
00:18:32,420 --> 00:18:39,370
If you want to copy these
elements and put in a new one,

379
00:18:39,370 --> 00:18:45,300
say, list Z, then we need to
copy one-by-one every element.

380
00:18:45,300 --> 00:18:49,690
For that we can use
this operator.

381
00:18:49,690 --> 00:18:50,940
It's called full slicing.

382
00:18:50,940 --> 00:18:53,700

383
00:18:53,700 --> 00:18:55,860
It's not going to
modify elements.

384
00:18:55,860 --> 00:18:58,955
It's going to copy the whole
list of elements.

385
00:18:58,955 --> 00:19:15,360

386
00:19:15,360 --> 00:19:24,700
And in the same line, just
another small example that

387
00:19:24,700 --> 00:19:28,640
tells you how to cast a
list into tuple, and

388
00:19:28,640 --> 00:19:29,890
a tuple into list.

389
00:19:29,890 --> 00:19:45,370

390
00:19:45,370 --> 00:19:49,120
So you had a tuple, one for
apple [UNINTELLIGIBLE]

391
00:19:49,120 --> 00:19:51,170
and you cast into list.

392
00:19:51,170 --> 00:19:52,515
Now the type is list.

393
00:19:52,515 --> 00:19:55,330

394
00:19:55,330 --> 00:19:57,150
It's a very simple operation.

395
00:19:57,150 --> 00:20:00,250
Can you do that yourself?

396
00:20:00,250 --> 00:20:03,470
How would you do it if you want
to write a function to

397
00:20:03,470 --> 00:20:07,420
cast, how would you do that?

398
00:20:07,420 --> 00:20:11,810
You go through element by
element and add it to a tuple.

399
00:20:11,810 --> 00:20:14,790
And then concatentae
two tuples.

400
00:20:14,790 --> 00:20:17,350
Right?

401
00:20:17,350 --> 00:20:19,350
So I guess you can write
probably as a

402
00:20:19,350 --> 00:20:21,340
homework, try that.

403
00:20:21,340 --> 00:20:26,380
Try how to convert a list to
a tuple without explicitly

404
00:20:26,380 --> 00:20:29,385
calling the casting function.

405
00:20:29,385 --> 00:20:30,780
OK.

406
00:20:30,780 --> 00:20:33,540
Similarly you can convert
a tuple back into list.

407
00:20:33,540 --> 00:20:36,640

408
00:20:36,640 --> 00:20:38,490
So it's pretty straightforward.

409
00:20:38,490 --> 00:20:40,530
And suppose you're getting
an input from

410
00:20:40,530 --> 00:20:42,020
the user as a tuple.

411
00:20:42,020 --> 00:20:43,970
then suppose you want
to make it a list.

412
00:20:43,970 --> 00:20:45,350
You don't have to write
your function.

413
00:20:45,350 --> 00:20:48,940
You can just call this
casting operator.

414
00:20:48,940 --> 00:20:51,130
So it'll be--

415
00:20:51,130 --> 00:20:53,690
it will save some time.

416
00:20:53,690 --> 00:20:53,980
OK.

417
00:20:53,980 --> 00:20:56,470
Great.

418
00:20:56,470 --> 00:20:57,960
Let's go to our dictionaries
now.

419
00:20:57,960 --> 00:21:05,930

420
00:21:05,930 --> 00:21:10,030
So we have a third data
type, dictionaries.

421
00:21:10,030 --> 00:21:11,280
Oh, you didn't get
the second one?

422
00:21:11,280 --> 00:21:18,490

423
00:21:18,490 --> 00:21:21,740
So we have another data
type, dictionaries.

424
00:21:21,740 --> 00:21:24,210
And why do we need dictionaries

425
00:21:24,210 --> 00:21:26,050
in the first place?

426
00:21:26,050 --> 00:21:28,010
Do we need another data type?

427
00:21:28,010 --> 00:21:32,320
Can we just get away with
tuple and list?

428
00:21:32,320 --> 00:21:33,120
Yes.

429
00:21:33,120 --> 00:21:38,520
Because you can actually make
a dictionary out of lists.

430
00:21:38,520 --> 00:21:43,400
And Professor Grimson went
through that in the lecture.

431
00:21:43,400 --> 00:21:45,960
If you want, you can come and
ask in the office hours.

432
00:21:45,960 --> 00:21:49,440
But first try whether you
can do it yourself.

433
00:21:49,440 --> 00:21:55,520
But the problem is, actually not
just the dictionaries, but

434
00:21:55,520 --> 00:21:58,370
the high-level data structures
are actually available in

435
00:21:58,370 --> 00:22:03,420
Python as building data
structures or as classes.

436
00:22:03,420 --> 00:22:07,310
Just because they will have
these methods on these data

437
00:22:07,310 --> 00:22:08,980
structures implemented.

438
00:22:08,980 --> 00:22:11,180
So it would say some
time for us.

439
00:22:11,180 --> 00:22:15,720
Plus those methods are
guaranteed to be state of art.

440
00:22:15,720 --> 00:22:18,747
For example, if you want to go
through all the lists, then

441
00:22:18,747 --> 00:22:23,200
the search function or the
lookup function that you write

442
00:22:23,200 --> 00:22:25,760
may not be that efficient,
right?

443
00:22:25,760 --> 00:22:28,040
But they might use those
efficient algorithms in the

444
00:22:28,040 --> 00:22:29,290
standard implementation.

445
00:22:29,290 --> 00:22:32,660
So it's why you should
always look for the

446
00:22:32,660 --> 00:22:34,420
standard data types.

447
00:22:34,420 --> 00:22:36,880
If you can't you can
write yourself one.

448
00:22:36,880 --> 00:22:40,510
But it's good to use the
available data types so that

449
00:22:40,510 --> 00:22:44,270
they would have this efficient
method implemented.

450
00:22:44,270 --> 00:22:45,910
OK.

451
00:22:45,910 --> 00:22:54,310
So in this dictionary,
we have two elements.

452
00:22:54,310 --> 00:22:57,520
One is key, one is value.

453
00:22:57,520 --> 00:22:58,980
OK?

454
00:22:58,980 --> 00:23:02,130
So these keys actually have
a special property.

455
00:23:02,130 --> 00:23:04,650
What is that?

456
00:23:04,650 --> 00:23:12,360
The keys should be an
immutable object.

457
00:23:12,360 --> 00:23:15,930
So you can actually have
a tuple as a key.

458
00:23:15,930 --> 00:23:20,310
You can have a string as a key,
but not a list as a key.

459
00:23:20,310 --> 00:23:25,270
So you need an immutable
object for the keys.

460
00:23:25,270 --> 00:23:27,685
What about the values?

461
00:23:27,685 --> 00:23:30,040
They can be anything.

462
00:23:30,040 --> 00:23:33,230
Values can be even
a dictionary.

463
00:23:33,230 --> 00:23:34,935
It can be a list.

464
00:23:34,935 --> 00:23:36,950
But the keys must be mutable.

465
00:23:36,950 --> 00:23:40,160

466
00:23:40,160 --> 00:23:42,110
Do these keys need
to be unique?

467
00:23:42,110 --> 00:23:47,400

468
00:23:47,400 --> 00:23:49,370
Yes.

469
00:23:49,370 --> 00:23:51,264
No?

470
00:23:51,264 --> 00:23:52,760
OK.

471
00:23:52,760 --> 00:23:54,010
The problem is this.

472
00:23:54,010 --> 00:23:56,610

473
00:23:56,610 --> 00:24:00,430
Dictionaries have the same
type, I mean structure.

474
00:24:00,430 --> 00:24:05,340

475
00:24:05,340 --> 00:24:08,320
This is a key.

476
00:24:08,320 --> 00:24:11,690
And this key points to a
place in the memory.

477
00:24:11,690 --> 00:24:16,060
Suppose you call it key A. OK?

478
00:24:16,060 --> 00:24:20,770
If you assign another value to
key A, that will actually

479
00:24:20,770 --> 00:24:23,890
replace the content in
the memory, right?

480
00:24:23,890 --> 00:24:27,560
So that's why keys are going
to be unique, It's by

481
00:24:27,560 --> 00:24:31,850
construction, by the
construction of the dictionary

482
00:24:31,850 --> 00:24:34,540
the keys are going
to be unique.

483
00:24:34,540 --> 00:24:37,370
Because if you want to assign
something different, you have

484
00:24:37,370 --> 00:24:41,040
to call it by a different key,
call it by a different name.

485
00:24:41,040 --> 00:24:47,240
Say key B.

486
00:24:47,240 --> 00:24:48,490
What about the values.

487
00:24:48,490 --> 00:24:50,600

488
00:24:50,600 --> 00:24:52,037
Do they need to be unique?

489
00:24:52,037 --> 00:24:54,030
No, of course.

490
00:24:54,030 --> 00:24:57,450
Otherwise no use of key, and no
use of dictionaries, right?

491
00:24:57,450 --> 00:25:02,010
What is the order of the items
stored in the dictionary?

492
00:25:02,010 --> 00:25:05,460
Can you give a guarantee
like in lists?

493
00:25:05,460 --> 00:25:09,490
In lists items are stored from
zero to the left, right?

494
00:25:09,490 --> 00:25:11,670
Length minus 1, actually.

495
00:25:11,670 --> 00:25:13,410
What about dictionaries?

496
00:25:13,410 --> 00:25:16,280
Surely can't guarantee
the order, but you

497
00:25:16,280 --> 00:25:18,192
can modify the order.

498
00:25:18,192 --> 00:25:19,330
OK.

499
00:25:19,330 --> 00:25:23,800
So the thing is first, if you
look at this example, first we

500
00:25:23,800 --> 00:25:27,990
have the staff dictionary.

501
00:25:27,990 --> 00:25:33,040
And when I pin the length
it gives me 3, fine.

502
00:25:33,040 --> 00:25:34,820
Then I'm doing three things.

503
00:25:34,820 --> 00:25:42,540
First I change the address
by calling its key.

504
00:25:42,540 --> 00:25:44,590
And dictionaries are
mutable so you can

505
00:25:44,590 --> 00:25:45,840
change their values.

506
00:25:45,840 --> 00:25:48,220

507
00:25:48,220 --> 00:25:50,950
Then also we are adding
a new element.

508
00:25:50,950 --> 00:25:52,190
Fine.

509
00:25:52,190 --> 00:25:54,840
If you wanted a new element you
call it by the key that

510
00:25:54,840 --> 00:25:56,130
you already assigned.

511
00:25:56,130 --> 00:26:00,000
If the key already exists you
will just modify the value.

512
00:26:00,000 --> 00:26:04,160
Otherwise it will create a new
key and add that value.

513
00:26:04,160 --> 00:26:07,080
You can also check whether this
particular element is in

514
00:26:07,080 --> 00:26:09,120
the dictionary.

515
00:26:09,120 --> 00:26:11,320
But this must be the key.

516
00:26:11,320 --> 00:26:12,660
Whatever you are calling
here should be the

517
00:26:12,660 --> 00:26:13,820
key, not the value.

518
00:26:13,820 --> 00:26:15,550
It won't search for the value.

519
00:26:15,550 --> 00:26:17,070
It will search only for the
key, [UNINTELLIGIBLE]

520
00:26:17,070 --> 00:26:19,705
for that particular key because
you access the values

521
00:26:19,705 --> 00:26:20,955
through keys.

522
00:26:20,955 --> 00:26:23,080

523
00:26:23,080 --> 00:26:25,920
Again here if it is not
in the list, actually

524
00:26:25,920 --> 00:26:29,410
I'm adding an element--

525
00:26:29,410 --> 00:26:30,660
OK.

526
00:26:30,660 --> 00:26:35,680

527
00:26:35,680 --> 00:26:36,020
OK.

528
00:26:36,020 --> 00:26:42,660
To compare in the list, suppose
I have a list 0, 1, 2.

529
00:26:42,660 --> 00:26:45,460

530
00:26:45,460 --> 00:26:48,750
If I want to check whether
1 is in the

531
00:26:48,750 --> 00:26:50,310
list, how would I check?

532
00:26:50,310 --> 00:26:53,050

533
00:26:53,050 --> 00:26:55,370
Do you have to go through
element by element?

534
00:26:55,370 --> 00:26:57,850
No, there's a shortcut.

535
00:26:57,850 --> 00:27:05,340
If 1 in list, right?

536
00:27:05,340 --> 00:27:08,530
If I want to check whether 1 is
not in the list, if I want

537
00:27:08,530 --> 00:27:16,240
to negate this, I would write
it 1 not in list.

538
00:27:16,240 --> 00:27:17,380
We just ignore the words.

539
00:27:17,380 --> 00:27:19,898
It's pretty much like English.

540
00:27:19,898 --> 00:27:20,730
OK?

541
00:27:20,730 --> 00:27:22,660
We just remove the words.

542
00:27:22,660 --> 00:27:24,360
OK.

543
00:27:24,360 --> 00:27:29,360
In the dictionary we do the
same thing through keys.

544
00:27:29,360 --> 00:27:35,530
If key A and, OK I'll
call it, say, D1.

545
00:27:35,530 --> 00:27:41,402

546
00:27:41,402 --> 00:27:42,340
OK?

547
00:27:42,340 --> 00:27:46,260
And you actually call or you'd
search for the key,

548
00:27:46,260 --> 00:27:47,510
not the other way.

549
00:27:47,510 --> 00:27:58,550

550
00:27:58,550 --> 00:27:59,560
OK.

551
00:27:59,560 --> 00:28:03,140
There is an interesting
part here.

552
00:28:03,140 --> 00:28:04,890
If you want to modify
the order--

553
00:28:04,890 --> 00:28:08,420
actually I tell you that the
order C earlier, we couldn't

554
00:28:08,420 --> 00:28:11,950
guarantee the order, right?

555
00:28:11,950 --> 00:28:15,860
It was not the order we typed
because it starts at

556
00:28:15,860 --> 00:28:17,800
[UNINTELLIGIBLE]

557
00:28:17,800 --> 00:28:20,530
because we added at the
end actually, right?

558
00:28:20,530 --> 00:28:22,640
So actually you can't
guarantee the order.

559
00:28:22,640 --> 00:28:25,370
But we can sort it.

560
00:28:25,370 --> 00:28:27,420
But how do you sort it?

561
00:28:27,420 --> 00:28:32,280
We call the keys and
we sort the keys.

562
00:28:32,280 --> 00:28:36,020
Because remember,
every values--

563
00:28:36,020 --> 00:28:38,180
if you want to access a
particular value, you access

564
00:28:38,180 --> 00:28:39,750
it through key.

565
00:28:39,750 --> 00:28:42,730
Actually, if you call the
dictionary, it doesn't know

566
00:28:42,730 --> 00:28:44,280
where these values are.

567
00:28:44,280 --> 00:28:47,460
Just you have to go to the
key to access the value.

568
00:28:47,460 --> 00:28:50,910
So if you want to do something
in the dictionary itself, you

569
00:28:50,910 --> 00:28:53,340
can do that only on keys.

570
00:28:53,340 --> 00:28:54,670
So if you want to sort
the dictionary,

571
00:28:54,670 --> 00:28:56,520
you sort it by keys.

572
00:28:56,520 --> 00:29:01,400
So you call the keys method
for the dictionary--

573
00:29:01,400 --> 00:29:06,450
so it returns the list of
keys and you sort them.

574
00:29:06,450 --> 00:29:09,070

575
00:29:09,070 --> 00:29:10,690
This is called chaining
methods.

576
00:29:10,690 --> 00:29:13,160
So I have chained the methods.

577
00:29:13,160 --> 00:29:15,350
I would have like two
methods, right?

578
00:29:15,350 --> 00:29:17,100
I call the keys.

579
00:29:17,100 --> 00:29:20,900
This first part actually returns
to this top key.

580
00:29:20,900 --> 00:29:22,830
Then you sort them.

581
00:29:22,830 --> 00:29:23,851
Yes?

582
00:29:23,851 --> 00:29:27,080
AUDIENCE: It doesn't look like
they're in alphabetical order?

583
00:29:27,080 --> 00:29:27,705
PROFESSOR: Oh, on this?

584
00:29:27,705 --> 00:29:28,955
Sorry.

585
00:29:28,955 --> 00:29:32,600

586
00:29:32,600 --> 00:29:33,850
Let's see.

587
00:29:33,850 --> 00:29:40,670

588
00:29:40,670 --> 00:29:41,150
OK.

589
00:29:41,150 --> 00:29:42,400
Let's see.

590
00:29:42,400 --> 00:29:55,550

591
00:29:55,550 --> 00:29:56,800
Ooops.

592
00:29:56,800 --> 00:30:03,370

593
00:30:03,370 --> 00:30:03,950
OK.

594
00:30:03,950 --> 00:30:05,200
Now they're sorted.

595
00:30:05,200 --> 00:30:07,730

596
00:30:07,730 --> 00:30:09,190
OK.

597
00:30:09,190 --> 00:30:12,160
What was the problem?

598
00:30:12,160 --> 00:30:14,160
What was the problem there?

599
00:30:14,160 --> 00:30:16,030
Why it wasn't sorted?

600
00:30:16,030 --> 00:30:17,790
AUDIENCE: You have to
do it in two lines.

601
00:30:17,790 --> 00:30:18,240
PROFESSOR: Sorry?

602
00:30:18,240 --> 00:30:21,802
AUDIENCE: You have to call up
the keys and then sort it in a

603
00:30:21,802 --> 00:30:24,300
separate line?

604
00:30:24,300 --> 00:30:25,810
PROFESSOR: OK.

605
00:30:25,810 --> 00:30:29,830
The problem is in the logic.

606
00:30:29,830 --> 00:30:32,560
Actually, when you call this
function, method, you're

607
00:30:32,560 --> 00:30:35,650
actually sorting the keys
returned by this method.

608
00:30:35,650 --> 00:30:40,290
You're not actually going to
sort of the dictionary itself.

609
00:30:40,290 --> 00:30:44,820
You're sorting only the list
that was returned, right?

610
00:30:44,820 --> 00:30:47,230
The list of keys.

611
00:30:47,230 --> 00:30:53,200
Although the dictionary is
mutable, it wasn't sorted.

612
00:30:53,200 --> 00:30:54,720
Do you see the problem?

613
00:30:54,720 --> 00:30:59,230
So that's why when they called
keys equal to staff.keys I'm

614
00:30:59,230 --> 00:31:02,190
getting a list of keys.

615
00:31:02,190 --> 00:31:05,000
Then I'm sorting that list.

616
00:31:05,000 --> 00:31:08,180
And I'm printing that list.

617
00:31:08,180 --> 00:31:12,820
But if you want to go in a
particular order, if you want

618
00:31:12,820 --> 00:31:15,230
to access the dictionary in a
particular order, what could

619
00:31:15,230 --> 00:31:24,380
you do is you could do something
like keys is equal

620
00:31:24,380 --> 00:31:25,630
to staff.keys.

621
00:31:25,630 --> 00:31:28,280

622
00:31:28,280 --> 00:31:29,530
Then you can store keys.

623
00:31:29,530 --> 00:31:34,430

624
00:31:34,430 --> 00:31:40,880
Then for k in keys you can go
and iterate now, right?

625
00:31:40,880 --> 00:31:47,560
So you can say print
k and staff k.

626
00:31:47,560 --> 00:31:49,500
OK?

627
00:31:49,500 --> 00:31:51,770
So you can do this.

628
00:31:51,770 --> 00:31:56,770
But actually, Python provides a
way to iterate what keys and

629
00:31:56,770 --> 00:31:58,020
value pairs.

630
00:31:58,020 --> 00:32:00,540

631
00:32:00,540 --> 00:32:07,660
That you do by calling
both elements?

632
00:32:07,660 --> 00:32:09,730
All the method items.

633
00:32:09,730 --> 00:32:16,040
The items return a list
of key-value pairs.

634
00:32:16,040 --> 00:32:19,650

635
00:32:19,650 --> 00:32:27,530
If you call D1.items you get
a list of key-value pairs.

636
00:32:27,530 --> 00:32:35,250

637
00:32:35,250 --> 00:32:38,210
You see that?

638
00:32:38,210 --> 00:32:42,740
And we are going to iterate
through individual elements.

639
00:32:42,740 --> 00:32:46,190
So first we start with this
and then second this.

640
00:32:46,190 --> 00:32:49,560
So that's a simpler way to
access every elements in the

641
00:32:49,560 --> 00:32:51,448
dictionary.

642
00:32:51,448 --> 00:32:52,698
Great.

643
00:32:52,698 --> 00:32:59,384

644
00:32:59,384 --> 00:33:02,360
OK.

645
00:33:02,360 --> 00:33:04,680
Now we have an interesting
part, recursion.

646
00:33:04,680 --> 00:33:13,780

647
00:33:13,780 --> 00:33:17,040
What's the principle
behind recursion?

648
00:33:17,040 --> 00:33:18,290
Anyone?

649
00:33:18,290 --> 00:33:21,140

650
00:33:21,140 --> 00:33:22,390
What's the idea of recursion?

651
00:33:22,390 --> 00:33:25,320

652
00:33:25,320 --> 00:33:25,720
Yes?

653
00:33:25,720 --> 00:33:28,929
AUDIENCE: The cause itself
is [INAUDIBLE]

654
00:33:28,929 --> 00:33:29,875
base case.

655
00:33:29,875 --> 00:33:32,240
And it saves a lot of money.

656
00:33:32,240 --> 00:33:35,160
PROFESSOR: Yes.

657
00:33:35,160 --> 00:33:38,890
The idea of recursion is, if
you have a problem, try to

658
00:33:38,890 --> 00:33:41,170
express the problem
in a simpler

659
00:33:41,170 --> 00:33:43,090
version of the same problem.

660
00:33:43,090 --> 00:33:47,260
So if you want to find factorial
n, try to express it

661
00:33:47,260 --> 00:33:49,530
in terms of factorial
n minus 1.

662
00:33:49,530 --> 00:33:52,940
So you could keep on doing
this till you come to

663
00:33:52,940 --> 00:33:56,828
factorial 1 for which you know
the explicit answer.

664
00:33:56,828 --> 00:33:57,700
Right?

665
00:33:57,700 --> 00:34:02,000
So you try to express the
problem in its simpler form.

666
00:34:02,000 --> 00:34:05,340
It would be useful
in many cases.

667
00:34:05,340 --> 00:34:09,060
Actually, in your next piece
you do have the problem.

668
00:34:09,060 --> 00:34:12,540
But be mindful.

669
00:34:12,540 --> 00:34:14,000
What's --

670
00:34:14,000 --> 00:34:19,000
what makes it possible for
you to use the recursion?

671
00:34:19,000 --> 00:34:21,840
Only if you can express in terms
of the simpler version.

672
00:34:21,840 --> 00:34:23,860
Otherwise you can't.

673
00:34:23,860 --> 00:34:26,600
This is probably quite like the
induction you might have

674
00:34:26,600 --> 00:34:28,010
studied, mathematical
induction.

675
00:34:28,010 --> 00:34:29,870
I don't know whether you studied
it in high school, but

676
00:34:29,870 --> 00:34:32,170
it's quite like that.

677
00:34:32,170 --> 00:34:34,889
OK.

678
00:34:34,889 --> 00:34:38,389
So there are two parts
in recursion.

679
00:34:38,389 --> 00:34:39,925
The first one is
the base case.

680
00:34:39,925 --> 00:34:43,340

681
00:34:43,340 --> 00:34:53,310
So for a factorial problem we
can express the factorial, say

682
00:34:53,310 --> 00:35:01,530
nth factorial, as any n in
to n minus 1 factorial.

683
00:35:01,530 --> 00:35:03,660
OK?

684
00:35:03,660 --> 00:35:07,050
So this would be our
recursive case.

685
00:35:07,050 --> 00:35:08,740
So what is a recursive case?

686
00:35:08,740 --> 00:35:14,880

687
00:35:14,880 --> 00:35:23,330
Suppose we want to define a
function factorial A. OK?

688
00:35:23,330 --> 00:35:26,042
So what will be our
recursive case?

689
00:35:26,042 --> 00:35:27,292
AUDIENCE: A is greater than 0?

690
00:35:27,292 --> 00:35:29,270

691
00:35:29,270 --> 00:35:30,750
PROFESSOR: I'm asking the
recursive function.

692
00:35:30,750 --> 00:35:32,682
What would be that?

693
00:35:32,682 --> 00:35:33,932
AUDIENCE: [INAUDIBLE]

694
00:35:33,932 --> 00:35:37,300

695
00:35:37,300 --> 00:35:38,550
PROFESSOR: n into 2.

696
00:35:38,550 --> 00:35:42,350

697
00:35:42,350 --> 00:35:45,690
Factorial n minus 1 right?

698
00:35:45,690 --> 00:35:46,950
And you just return this.

699
00:35:46,950 --> 00:35:50,120

700
00:35:50,120 --> 00:35:51,370
What would be your base case?

701
00:35:51,370 --> 00:35:56,460

702
00:35:56,460 --> 00:36:01,070
If n is equal to 0, we know
factorial 0 is 1, right?

703
00:36:01,070 --> 00:36:06,260

704
00:36:06,260 --> 00:36:12,090
What is factorial of 1?

705
00:36:12,090 --> 00:36:15,750

706
00:36:15,750 --> 00:36:17,000
1.

707
00:36:17,000 --> 00:36:25,420

708
00:36:25,420 --> 00:36:27,910
OK?

709
00:36:27,910 --> 00:36:30,020
But why in this program
we didn't have

710
00:36:30,020 --> 00:36:31,270
that particular line.

711
00:36:31,270 --> 00:36:34,010

712
00:36:34,010 --> 00:36:37,340
Why we didn't have n equals 1?

713
00:36:37,340 --> 00:36:38,595
Why we didn't have that?

714
00:36:38,595 --> 00:36:42,960

715
00:36:42,960 --> 00:36:45,385
AUDIENCE: Because it
always goes to 0?

716
00:36:45,385 --> 00:36:47,100
PROFESSOR: It always
goes 0, right?

717
00:36:47,100 --> 00:36:51,000
Because you can express 1 in
terms of 0 as well, right?

718
00:36:51,000 --> 00:36:53,320
So you don't need to actually
write this explicitly.

719
00:36:53,320 --> 00:36:54,840
Why?

720
00:36:54,840 --> 00:36:57,780
Because your recursive function
only depends on its

721
00:36:57,780 --> 00:36:59,360
previous value.

722
00:36:59,360 --> 00:37:03,760
So you need only one value in
advance Which means you need

723
00:37:03,760 --> 00:37:05,200
only one value for
your base case.

724
00:37:05,200 --> 00:37:08,830

725
00:37:08,830 --> 00:37:12,140
So you can understand
this program, right?

726
00:37:12,140 --> 00:37:13,550
I'm not going to go
through that.

727
00:37:13,550 --> 00:37:16,040
But anyway when you write
a program always

728
00:37:16,040 --> 00:37:17,760
check its base case.

729
00:37:17,760 --> 00:37:21,470
So you have to start with
factorial 0 for this case.

730
00:37:21,470 --> 00:37:21,920
OK?

731
00:37:21,920 --> 00:37:23,140
And check one by one.

732
00:37:23,140 --> 00:37:24,790
Then you would know whether
the program is running

733
00:37:24,790 --> 00:37:26,100
correctly or not.

734
00:37:26,100 --> 00:37:27,985
So always start with
a simpler case.

735
00:37:27,985 --> 00:37:31,130

736
00:37:31,130 --> 00:37:32,910
But remember in Fibonacci
series.

737
00:37:32,910 --> 00:37:36,531

738
00:37:36,531 --> 00:37:40,220
OK. for Fibonacci series
can you give me

739
00:37:40,220 --> 00:37:41,470
the recursive function.?

740
00:37:41,470 --> 00:37:44,270

741
00:37:44,270 --> 00:37:44,540
Yes.

742
00:37:44,540 --> 00:37:46,650
What is Fibonacci series?

743
00:37:46,650 --> 00:37:47,900
AUDIENCE: [INAUDIBLE]

744
00:37:47,900 --> 00:37:50,150

745
00:37:50,150 --> 00:37:50,650
PROFESSOR: OK.

746
00:37:50,650 --> 00:37:51,150
Yeah.

747
00:37:51,150 --> 00:37:52,650
That's great.

748
00:37:52,650 --> 00:38:00,020
So return say F of n minus
1 plus F of n minus 2.

749
00:38:00,020 --> 00:38:01,610
What is the Fibonacci series?

750
00:38:01,610 --> 00:38:03,920
You start from 0, you
add these elements.

751
00:38:03,920 --> 00:38:04,740
So 1.

752
00:38:04,740 --> 00:38:06,710
You add last two elements, 2.

753
00:38:06,710 --> 00:38:08,200
You add last two elements, 3.

754
00:38:08,200 --> 00:38:09,450
You add last two elements, 5.

755
00:38:09,450 --> 00:38:13,030

756
00:38:13,030 --> 00:38:14,600
So you add last two elements.

757
00:38:14,600 --> 00:38:19,080
So if you want to find F of n,
you return F of n minus 1 and

758
00:38:19,080 --> 00:38:21,410
plus F of n minus 2.

759
00:38:21,410 --> 00:38:26,880
But here since you have two
elements, or you need to

760
00:38:26,880 --> 00:38:30,450
access two previous elements,
you need to define you base

761
00:38:30,450 --> 00:38:31,700
case accordingly.

762
00:38:31,700 --> 00:38:33,640

763
00:38:33,640 --> 00:38:40,820
So for your base case,
F of 0, is what?

764
00:38:40,820 --> 00:38:43,526

765
00:38:43,526 --> 00:38:45,800
Actually, that depends
on whether you

766
00:38:45,800 --> 00:38:48,135
start here or here.

767
00:38:48,135 --> 00:38:49,385
OK?

768
00:38:49,385 --> 00:38:51,860

769
00:38:51,860 --> 00:38:53,110
You could do this.

770
00:38:53,110 --> 00:38:59,970

771
00:38:59,970 --> 00:39:03,940
I'll go through an interesting
recursive example.

772
00:39:03,940 --> 00:39:29,350

773
00:39:29,350 --> 00:39:30,040
OK.

774
00:39:30,040 --> 00:39:32,810
It's called a recursive
exponentiation.

775
00:39:32,810 --> 00:39:37,720
So I actually you can do an
exponentiation through

776
00:39:37,720 --> 00:39:39,940
recursive multiplication.

777
00:39:39,940 --> 00:39:43,800
Suppose you want to find 3
to the power, say, of 10.

778
00:39:43,800 --> 00:39:49,546

779
00:39:49,546 --> 00:39:50,880
Then how would you do that?

780
00:39:50,880 --> 00:39:53,970

781
00:39:53,970 --> 00:39:58,300
You start by expressing
it in terms of its

782
00:39:58,300 --> 00:39:59,800
simpler version, right?

783
00:39:59,800 --> 00:40:02,630
So it will be 3 into
3 to the power 9.

784
00:40:02,630 --> 00:40:05,280
Sorry, 3 to the power 9.

785
00:40:05,280 --> 00:40:06,530
OK?

786
00:40:06,530 --> 00:40:11,230

787
00:40:11,230 --> 00:40:17,240
So if you want to find that
nth power of number M, you

788
00:40:17,240 --> 00:40:24,490
would say M into M to
the power n minus 1.

789
00:40:24,490 --> 00:40:26,460
So now you have your
recursive case.

790
00:40:26,460 --> 00:40:29,160

791
00:40:29,160 --> 00:40:30,410
What is the base case?

792
00:40:30,410 --> 00:40:34,060

793
00:40:34,060 --> 00:40:36,890
AUDIENCE: [INAUDIBLE]

794
00:40:36,890 --> 00:40:38,775
PROFESSOR: Yes, if
n is equal to 0.

795
00:40:38,775 --> 00:40:41,720

796
00:40:41,720 --> 00:40:48,260
In Python you would test this
by two equal signs.

797
00:40:48,260 --> 00:40:51,694
If n is equal to 0, then what?

798
00:40:51,694 --> 00:40:52,560
AUDIENCE: Return 1.

799
00:40:52,560 --> 00:40:53,810
PROFESSOR: Return 1.

800
00:40:53,810 --> 00:40:57,574

801
00:40:57,574 --> 00:40:59,480
OK?

802
00:40:59,480 --> 00:41:03,492
Why we have only one
base case here?

803
00:41:03,492 --> 00:41:05,250
AUDIENCE: [INAUDIBLE]

804
00:41:05,250 --> 00:41:05,596
PROFESSOR: Sorry?

805
00:41:05,596 --> 00:41:07,340
AUDIENCE: [INAUDIBLE]

806
00:41:07,340 --> 00:41:07,810
PROFESSOR: Yes.

807
00:41:07,810 --> 00:41:09,660
And because you're accessing
only one

808
00:41:09,660 --> 00:41:11,350
previous series, right?

809
00:41:11,350 --> 00:41:12,600
Fibonacci series.

810
00:41:12,600 --> 00:41:14,880

811
00:41:14,880 --> 00:41:18,180
Similarly, if you want to
multiply something--

812
00:41:18,180 --> 00:41:22,670
OK, here what we did is we
replaced this operator by

813
00:41:22,670 --> 00:41:26,280
recursively using
this operator.

814
00:41:26,280 --> 00:41:28,700
OK?

815
00:41:28,700 --> 00:41:33,120
Can you do the multiplication
by recursive addition?

816
00:41:33,120 --> 00:41:38,360
So can you replace this operator
by this operator?

817
00:41:38,360 --> 00:41:39,360
Yes.

818
00:41:39,360 --> 00:41:45,020
So how would you do this, for
example say 3 into 5?

819
00:41:45,020 --> 00:41:46,270
So how would you do it here?

820
00:41:46,270 --> 00:41:49,470

821
00:41:49,470 --> 00:41:49,970
Tell me.

822
00:41:49,970 --> 00:41:51,220
What would this?

823
00:41:51,220 --> 00:41:55,960

824
00:41:55,960 --> 00:41:58,790
AUDIENCE: 3 plus 3 times 4.

825
00:41:58,790 --> 00:41:59,220
PROFESSOR: 3 plus?

826
00:41:59,220 --> 00:42:00,510
AUDIENCE: 3 times 4.

827
00:42:00,510 --> 00:42:02,230
PROFESSOR: 3 times 4.

828
00:42:02,230 --> 00:42:03,480
Here?

829
00:42:03,480 --> 00:42:11,630

830
00:42:11,630 --> 00:42:13,549
Come on, it's simple, right?

831
00:42:13,549 --> 00:42:14,910
AUDIENCE: [INAUDIBLE]

832
00:42:14,910 --> 00:42:17,154
PROFESSOR: I'm insulting you.

833
00:42:17,154 --> 00:42:18,630
OK.

834
00:42:18,630 --> 00:42:20,230
What's the base case?

835
00:42:20,230 --> 00:42:22,090
That is interesting.

836
00:42:22,090 --> 00:42:25,550
What is the base case
if n is equal to 0?

837
00:42:25,550 --> 00:42:32,438

838
00:42:32,438 --> 00:42:35,882
AUDIENCE: [INAUDIBLE]

839
00:42:35,882 --> 00:42:37,850
PROFESSOR: OK.

840
00:42:37,850 --> 00:42:40,210
If n is equal to 0, that is 0.

841
00:42:40,210 --> 00:42:41,250
But that's fine.

842
00:42:41,250 --> 00:42:42,500
But there's another problem.

843
00:42:42,500 --> 00:42:49,010

844
00:42:49,010 --> 00:42:52,930
The problem is you don't know
whether these values are

845
00:42:52,930 --> 00:42:54,620
positive or negative.

846
00:42:54,620 --> 00:42:57,600
So you can't just keep
on adding like this.

847
00:42:57,600 --> 00:42:58,850
This will work if
it's positive.

848
00:42:58,850 --> 00:43:01,350

849
00:43:01,350 --> 00:43:03,860
But if it's negative, actually
you have to check.

850
00:43:03,860 --> 00:43:07,390
Which is sort of tricky
if you want to use the

851
00:43:07,390 --> 00:43:08,770
same recursive function.

852
00:43:08,770 --> 00:43:14,030
Otherwise you could have
an if condition here.

853
00:43:14,030 --> 00:43:17,120
If say n is greater
than 0, do this.

854
00:43:17,120 --> 00:43:19,690

855
00:43:19,690 --> 00:43:25,010
Else-if you multiply n by minus
1 you negate that so it

856
00:43:25,010 --> 00:43:26,080
becomes positive.

857
00:43:26,080 --> 00:43:30,910
And do it the same way and
then that's the answer.

858
00:43:30,910 --> 00:43:32,370
So you could do that.

859
00:43:32,370 --> 00:43:36,780
But if you want to do it in the
same recursive case, then

860
00:43:36,780 --> 00:43:37,940
you had to follow this.

861
00:43:37,940 --> 00:43:39,420
If you have any questions,
come to the

862
00:43:39,420 --> 00:43:42,730
office hours on that.

863
00:43:42,730 --> 00:43:46,175
The final question is, final
example is, the Hanoi example.

864
00:43:46,175 --> 00:43:49,640

865
00:43:49,640 --> 00:43:50,490
OK.

866
00:43:50,490 --> 00:43:51,740
This is very interesting.

867
00:43:51,740 --> 00:43:57,890

868
00:43:57,890 --> 00:44:04,520
So here we have three towers;
source, target, and buffer.

869
00:44:04,520 --> 00:44:07,580

870
00:44:07,580 --> 00:44:10,350
Suppose you have three disks.

871
00:44:10,350 --> 00:44:13,420
You want to move them from
source to target.

872
00:44:13,420 --> 00:44:16,200
And you can always have a
smaller disk on top of a

873
00:44:16,200 --> 00:44:18,250
bigger disk.

874
00:44:18,250 --> 00:44:19,670
Then how would you move?

875
00:44:19,670 --> 00:44:20,470
OK?

876
00:44:20,470 --> 00:44:25,010
So can you express this problem
in a simpler version?

877
00:44:25,010 --> 00:44:26,880
So now we have three disks.

878
00:44:26,880 --> 00:44:29,110
You want to move
them to target.

879
00:44:29,110 --> 00:44:31,710
So can you express it in
a simpler version?

880
00:44:31,710 --> 00:44:34,320

881
00:44:34,320 --> 00:44:37,090
Come on.

882
00:44:37,090 --> 00:44:40,380
Just in plain English,
how would you do it?

883
00:44:40,380 --> 00:44:42,550
Without looking at
the program.

884
00:44:42,550 --> 00:44:43,950
Because Python is very robust.

885
00:44:43,950 --> 00:44:47,010
So if you read the program
you get it in English.

886
00:44:47,010 --> 00:44:49,776

887
00:44:49,776 --> 00:44:53,890
So any ideas?

888
00:44:53,890 --> 00:44:55,210
OK.

889
00:44:55,210 --> 00:44:57,860
We have to here move the last
disk to target, right?

890
00:44:57,860 --> 00:44:59,750
But that's the hardest part.

891
00:44:59,750 --> 00:45:02,720
So before doing that you have
to move this somewhere else.

892
00:45:02,720 --> 00:45:04,120
So let's move it to buffer.

893
00:45:04,120 --> 00:45:07,960

894
00:45:07,960 --> 00:45:10,360
Done.

895
00:45:10,360 --> 00:45:13,600
How would you move this?

896
00:45:13,600 --> 00:45:16,496
Now you can move it to target.

897
00:45:16,496 --> 00:45:18,230
OK.

898
00:45:18,230 --> 00:45:20,634
Now what would you do?

899
00:45:20,634 --> 00:45:21,884
AUDIENCE: [INAUDIBLE]

900
00:45:21,884 --> 00:45:25,394

901
00:45:25,394 --> 00:45:25,880
PROFESSOR: OK.

902
00:45:25,880 --> 00:45:26,460
Sorry.

903
00:45:26,460 --> 00:45:27,870
Yeah, OK?

904
00:45:27,870 --> 00:45:28,250
No.

905
00:45:28,250 --> 00:45:29,317
What would you do?

906
00:45:29,317 --> 00:45:30,780
AUDIENCE: [INAUDIBLE]

907
00:45:30,780 --> 00:45:35,270
PROFESSOR: You can only move
this to the buffer, right?

908
00:45:35,270 --> 00:45:36,330
AUDIENCE: [INAUDIBLE]

909
00:45:36,330 --> 00:45:36,360
[?

910
00:45:36,360 --> 00:45:37,610
PROFESSOR: Not the target.

911
00:45:37,610 --> 00:45:39,820

912
00:45:39,820 --> 00:45:40,920
OK.

913
00:45:40,920 --> 00:45:42,170
So we made some mistake
earlier.

914
00:45:42,170 --> 00:45:44,888

915
00:45:44,888 --> 00:45:46,250
Remember?

916
00:45:46,250 --> 00:45:49,300
The problem is because we didn't
think recursively.

917
00:45:49,300 --> 00:45:53,720

918
00:45:53,720 --> 00:45:55,080
OK.

919
00:45:55,080 --> 00:45:56,330
Let's think recursively.

920
00:45:56,330 --> 00:46:01,350

921
00:46:01,350 --> 00:46:03,751
Source, target, buffer.

922
00:46:03,751 --> 00:46:05,540
Sorry.

923
00:46:05,540 --> 00:46:07,200
Suppose we have only one disk.

924
00:46:07,200 --> 00:46:10,360

925
00:46:10,360 --> 00:46:13,630
Then you can simply
move to target.

926
00:46:13,630 --> 00:46:14,570
OK?

927
00:46:14,570 --> 00:46:17,450
So a condition is if there's
only one disk, just move it to

928
00:46:17,450 --> 00:46:18,700
the target.

929
00:46:18,700 --> 00:46:21,350

930
00:46:21,350 --> 00:46:27,960
So if n is equal to 1
we always move from

931
00:46:27,960 --> 00:46:30,745
move source to target.

932
00:46:30,745 --> 00:46:33,350

933
00:46:33,350 --> 00:46:34,760
OK?

934
00:46:34,760 --> 00:46:36,010
Suppose you have two.

935
00:46:36,010 --> 00:46:41,330

936
00:46:41,330 --> 00:46:44,410
Then what would you do?

937
00:46:44,410 --> 00:46:45,870
You move the top
one to buffer.

938
00:46:45,870 --> 00:46:50,970

939
00:46:50,970 --> 00:46:52,610
OK?

940
00:46:52,610 --> 00:46:56,870
So move source to buffer.

941
00:46:56,870 --> 00:47:02,560

942
00:47:02,560 --> 00:47:05,135
Then you move the next disk
from source to target.

943
00:47:05,135 --> 00:47:07,990

944
00:47:07,990 --> 00:47:11,720
So now it's source to target.

945
00:47:11,720 --> 00:47:15,660

946
00:47:15,660 --> 00:47:19,480
And finally you move
it from the buffer.

947
00:47:19,480 --> 00:47:20,730
All right?

948
00:47:20,730 --> 00:47:24,130

949
00:47:24,130 --> 00:47:28,590
Now we have a very nice
recursive case.

950
00:47:28,590 --> 00:47:34,400
If you have two, we move from
source to buffer, then source

951
00:47:34,400 --> 00:47:36,660
to target, then from
buffer to target.

952
00:47:36,660 --> 00:47:39,360

953
00:47:39,360 --> 00:47:45,600
So if you look at this example
I'm checking if

954
00:47:45,600 --> 00:47:48,060
n is equal to 1.

955
00:47:48,060 --> 00:47:53,180
If it is 1, just I'm moving
from source to target.

956
00:47:53,180 --> 00:47:55,920
If it is greater than
n, what would I do?

957
00:47:55,920 --> 00:47:58,150
And that first assert statement
is just there to

958
00:47:58,150 --> 00:47:59,460
make sure that n is
greater than 0.

959
00:47:59,460 --> 00:48:01,690
Otherwise it's meaningless,
right?

960
00:48:01,690 --> 00:48:02,830
You need to have this.

961
00:48:02,830 --> 00:48:05,660
You can't have negative this.

962
00:48:05,660 --> 00:48:12,630
So what would be the next
step if you have

963
00:48:12,630 --> 00:48:13,760
more than one disk?

964
00:48:13,760 --> 00:48:14,980
Suppose you have two disks.

965
00:48:14,980 --> 00:48:16,810
Then what would you do?

966
00:48:16,810 --> 00:48:19,590
You move the top disk
or whatever on

967
00:48:19,590 --> 00:48:22,320
the top to the buffer.

968
00:48:22,320 --> 00:48:26,270
For this simple example
it was just one disk.

969
00:48:26,270 --> 00:48:30,120
But suppose you had more disks
on top of the last disk?

970
00:48:30,120 --> 00:48:32,280
So you would have moved
all of them to buffer.

971
00:48:32,280 --> 00:48:33,760
You don't have to worry
how you move it.

972
00:48:33,760 --> 00:48:36,050
But you have to move
it anyway.

973
00:48:36,050 --> 00:48:39,830
After moving that, you can
leisurely move this big disk

974
00:48:39,830 --> 00:48:42,420
to the top, to the target.

975
00:48:42,420 --> 00:48:43,420
OK?

976
00:48:43,420 --> 00:48:48,510
Finally, you bring back all
of them here, right?

977
00:48:48,510 --> 00:48:52,340
For you first operation, for
your first operation, from

978
00:48:52,340 --> 00:48:54,890
source to target, you have
to move all of them, the

979
00:48:54,890 --> 00:48:56,150
[UNINTELLIGIBLE].

980
00:48:56,150 --> 00:48:57,910
You could have used target
as your buffer.

981
00:48:57,910 --> 00:49:00,622

982
00:49:00,622 --> 00:49:01,530
OK?

983
00:49:01,530 --> 00:49:10,450
So that's why in this line I'm
using source as source.

984
00:49:10,450 --> 00:49:14,030
But the second argument, which
should have been the target,

985
00:49:14,030 --> 00:49:17,580
is now buffer because my current
target is buffer for

986
00:49:17,580 --> 00:49:20,480
the top n minus 1 disk.

987
00:49:20,480 --> 00:49:23,500
But my buffer is
now the target.

988
00:49:23,500 --> 00:49:23,550
OK.

989
00:49:23,550 --> 00:49:28,240
Because I can use the target
as buffer for the movement.

990
00:49:28,240 --> 00:49:33,204
Then I moved from source to the
target, the last big disk.

991
00:49:33,204 --> 00:49:34,090
OK?

992
00:49:34,090 --> 00:49:36,210
For that I can use buffer
as my buffer.

993
00:49:36,210 --> 00:49:39,290

994
00:49:39,290 --> 00:49:43,170
Then finally I bring back from
buffer to target using source

995
00:49:43,170 --> 00:49:44,420
as my buffer.

996
00:49:44,420 --> 00:49:47,478

997
00:49:47,478 --> 00:49:48,850
OK?

998
00:49:48,850 --> 00:49:52,240
So the thing is if you want to
have a recursive problem you

999
00:49:52,240 --> 00:49:54,110
can do it in two ways.

1000
00:49:54,110 --> 00:49:59,830
One thing, you can start
thinking how to express this

1001
00:49:59,830 --> 00:50:02,500
problem in its simpler version
like how you thought about the

1002
00:50:02,500 --> 00:50:04,430
Fibonacci series,
for instance.

1003
00:50:04,430 --> 00:50:08,700
Or else, you can start from
its base case, the most

1004
00:50:08,700 --> 00:50:10,310
fundamental situation.

1005
00:50:10,310 --> 00:50:12,810
So here it's n equal to
1, but this doesn't

1006
00:50:12,810 --> 00:50:14,350
give you enough context.

1007
00:50:14,350 --> 00:50:17,100
So you go to the next level, n
is equal to 2, and you have

1008
00:50:17,100 --> 00:50:18,720
the answer.

1009
00:50:18,720 --> 00:50:19,970
Right?

1010
00:50:19,970 --> 00:50:22,463
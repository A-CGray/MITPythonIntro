1
00:00:00,000 --> 00:00:00,040

2
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

3
00:00:02,460 --> 00:00:03,870
Commons license.

4
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

5
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

6
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

7
00:00:13,460 --> 00:00:18,440
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:18,440 --> 00:00:19,690
ocw.mit.edu.

9
00:00:19,690 --> 00:00:22,800

10
00:00:22,800 --> 00:00:23,940
PROFESSOR: Good morning.

11
00:00:23,940 --> 00:00:25,400
AUDIENCE: Good morning.

12
00:00:25,400 --> 00:00:27,280
PROFESSOR: Thank you.

13
00:00:27,280 --> 00:00:28,440
OK.

14
00:00:28,440 --> 00:00:32,960
So we're about to launch into
learning some basic elements

15
00:00:32,960 --> 00:00:35,430
of Python today.

16
00:00:35,430 --> 00:00:39,220
The elements I'm going to talk
about are common to every

17
00:00:39,220 --> 00:00:44,030
programming language that I
know, at least in concept, and

18
00:00:44,030 --> 00:00:46,950
of course slightly different
in detail.

19
00:00:46,950 --> 00:00:49,560
But as I said last time,
everything you're going to

20
00:00:49,560 --> 00:00:53,125
learn about Python should
be readily transferable.

21
00:00:53,125 --> 00:00:55,720

22
00:00:55,720 --> 00:01:03,390
I'll be using, for all of the
examples I present, something

23
00:01:03,390 --> 00:01:07,810
called an integrated development
environment, and

24
00:01:07,810 --> 00:01:13,775
in particular, one that's built
for Python called IDLE.

25
00:01:13,775 --> 00:01:22,030

26
00:01:22,030 --> 00:01:25,185
Usually we talk about these
things as IDEs.

27
00:01:25,185 --> 00:01:39,010

28
00:01:39,010 --> 00:01:45,160
I'm told, I don't know if it's
true, that the IDE for Python

29
00:01:45,160 --> 00:01:51,500
is called IDLE after Eric Idle
of Monty Python, which was

30
00:01:51,500 --> 00:01:53,800
also, I'm told, the inspiration
for the name of

31
00:01:53,800 --> 00:01:55,050
the programming language.

32
00:01:55,050 --> 00:01:57,960

33
00:01:57,960 --> 00:02:00,860
So what is an integrated
programming environment?

34
00:02:00,860 --> 00:02:10,259
In this case, it includes a
specialized text editor that

35
00:02:10,259 --> 00:02:15,760
provides highlighting,
auto-completion, smart indent,

36
00:02:15,760 --> 00:02:19,020
and you'll see shortly why all
that's very important, and a

37
00:02:19,020 --> 00:02:23,220
few other amenities that make it
easier to use this to type

38
00:02:23,220 --> 00:02:28,690
Python than typing it into
a generic text editor.

39
00:02:28,690 --> 00:02:35,150
It includes something called
a shell, which is the

40
00:02:35,150 --> 00:02:39,245
environment that actually
interprets the Python code.

41
00:02:39,245 --> 00:02:42,000

42
00:02:42,000 --> 00:02:46,950
And the nice thing about it
is it includes syntax

43
00:02:46,950 --> 00:02:48,200
highlighting.

44
00:02:48,200 --> 00:02:50,150

45
00:02:50,150 --> 00:02:54,300
So the shell gives you some
information about the syntax,

46
00:02:54,300 --> 00:02:58,650
as does the text editor
of course.

47
00:02:58,650 --> 00:03:01,950
And finally, it includes
an integrated debugger.

48
00:03:01,950 --> 00:03:05,640

49
00:03:05,640 --> 00:03:08,470
This could be useful in the
unlikely event that your

50
00:03:08,470 --> 00:03:12,940
programs have errors when
you write them.

51
00:03:12,940 --> 00:03:16,860
Though truth be told, I've been
programming in Python for

52
00:03:16,860 --> 00:03:20,760
years and I don't know that I've
ever used the debugger.

53
00:03:20,760 --> 00:03:23,200
It's not that I don't make
mistakes, it's just that I'm

54
00:03:23,200 --> 00:03:26,660
kind of a Luddite, and I
typically use print statements

55
00:03:26,660 --> 00:03:28,430
for debugging.

56
00:03:28,430 --> 00:03:31,800
And in fact, almost every
programmer that I know, when

57
00:03:31,800 --> 00:03:35,280
push comes to shove, ends up
using print statements.

58
00:03:35,280 --> 00:03:40,800
But the debugger is there,
should you care to take a try.

59
00:03:40,800 --> 00:03:41,690
All right.

60
00:03:41,690 --> 00:03:46,940
So you'll see on the screen
here an IDLE shell.

61
00:03:46,940 --> 00:03:50,800
In the shell, we can
type things.

62
00:03:50,800 --> 00:03:53,100
What are we going to type?

63
00:03:53,100 --> 00:03:58,681
Well the first thing to
understand is that at the core

64
00:03:58,681 --> 00:04:02,970
of Python, and probably the
most important thing to

65
00:04:02,970 --> 00:04:06,235
understand, are something
called objects.

66
00:04:06,235 --> 00:04:10,380

67
00:04:10,380 --> 00:04:14,990
Everything in Python
is an object.

68
00:04:14,990 --> 00:04:18,579
So every kind of entity that you
can create in Python is an

69
00:04:18,579 --> 00:04:24,040
object, and in fact, Python
code itself is an object.

70
00:04:24,040 --> 00:04:26,830
You'll remember, we talked about
stored program computers

71
00:04:26,830 --> 00:04:31,480
last time, and the concept that
a program is data, just

72
00:04:31,480 --> 00:04:35,020
like a number is data.

73
00:04:35,020 --> 00:04:46,250
Each object has a type that
tells us the kind of object it

74
00:04:46,250 --> 00:04:52,910
is, and in particular, what
we can do with it.

75
00:04:52,910 --> 00:04:58,020
And then there's a built-in
function, called type, that

76
00:04:58,020 --> 00:05:00,370
can be used to find out
the type of an object.

77
00:05:00,370 --> 00:05:04,520

78
00:05:04,520 --> 00:05:09,510
As we'll see, there are two
fundamental kinds of types.

79
00:05:09,510 --> 00:05:13,500

80
00:05:13,500 --> 00:05:16,640
Scalar and non-scalar.

81
00:05:16,640 --> 00:05:21,070

82
00:05:21,070 --> 00:05:25,330
We'll start with talking
about scalar types.

83
00:05:25,330 --> 00:05:29,030
And the key thing to think about
there is that they are

84
00:05:29,030 --> 00:05:30,280
indivisible.

85
00:05:30,280 --> 00:05:33,660

86
00:05:33,660 --> 00:05:37,300
Think of them as the atoms of
the programming language.

87
00:05:37,300 --> 00:05:40,100
Now, I know that some of you
have studied physics and know

88
00:05:40,100 --> 00:05:44,210
that atoms are in principle
divisible, but of course, only

89
00:05:44,210 --> 00:05:48,020
at great expense and with
serious consequences.

90
00:05:48,020 --> 00:05:49,500
And we've seen the
same thing here.

91
00:05:49,500 --> 00:05:54,390
You can, if you're desperate,
chop up these scalar types,

92
00:05:54,390 --> 00:06:00,030
but it almost always leads
to something bad.

93
00:06:00,030 --> 00:06:00,380
All right.

94
00:06:00,380 --> 00:06:02,230
Well let's look at some.

95
00:06:02,230 --> 00:06:07,890
Well, the first one you'll see
is used to represent integers,

96
00:06:07,890 --> 00:06:10,100
and that's called int.

97
00:06:10,100 --> 00:06:14,140
For every type, or every
built-in type, there's the

98
00:06:14,140 --> 00:06:17,110
notion of a literal, which
is how we type it.

99
00:06:17,110 --> 00:06:24,470
So for example, we can type 3,
and that will now tell us it

100
00:06:24,470 --> 00:06:27,400
is the value 3.

101
00:06:27,400 --> 00:06:29,430
You'll note it's typed
it in blue.

102
00:06:29,430 --> 00:06:32,660
And I can ask what
the type of 3 is.

103
00:06:32,660 --> 00:06:35,940
So you'll notice as I type
things into the shell, it's

104
00:06:35,940 --> 00:06:38,660
using colors to give
me a hint.

105
00:06:38,660 --> 00:06:42,850
So it's this fuchsia color for
the word type, telling me

106
00:06:42,850 --> 00:06:46,320
that's a built-in function.

107
00:06:46,320 --> 00:06:50,370
And now if I ask it, it will
tell me that the type of the

108
00:06:50,370 --> 00:06:54,930
literal 3 is "int".

109
00:06:54,930 --> 00:06:57,930
So it's an integer.

110
00:06:57,930 --> 00:07:00,410
And I can use other
sorts of things.

111
00:07:00,410 --> 00:07:06,430

112
00:07:06,430 --> 00:07:06,900
All right.

113
00:07:06,900 --> 00:07:10,930
There's also a type float.

114
00:07:10,930 --> 00:07:14,130
So those correspond to
the real numbers.

115
00:07:14,130 --> 00:07:18,470
So I can do something
like that.

116
00:07:18,470 --> 00:07:22,170
And we'll talk about this in a
second, but you'll notice if I

117
00:07:22,170 --> 00:07:26,210
do type of 3.2, it tells
me it's a float.

118
00:07:26,210 --> 00:07:31,980
And for that matter, I can do
type of 3.0, and it will tell

119
00:07:31,980 --> 00:07:35,060
me it's a float.

120
00:07:35,060 --> 00:07:37,996
So there's a difference
between 3 and 3.0.

121
00:07:37,996 --> 00:07:41,940
One is an int, and
one is a float.

122
00:07:41,940 --> 00:07:46,630
Now you'll notice something
kind of weird here.

123
00:07:46,630 --> 00:07:51,940
When the interpreter printed
back the value of the literal

124
00:07:51,940 --> 00:07:57,590
3.2, it gave me 3.2 and a bunch
of zeroes, and then this

125
00:07:57,590 --> 00:08:01,580
funny 2 standing at the end.

126
00:08:01,580 --> 00:08:06,040
In a few lectures, I'll explain
why it does this, but

127
00:08:06,040 --> 00:08:11,620
for now, you should just take
this as a warning that floats

128
00:08:11,620 --> 00:08:15,650
are not the same thing
as real numbers.

129
00:08:15,650 --> 00:08:18,490
You learned about reals,
presumably in middle school or

130
00:08:18,490 --> 00:08:21,390
high school.

131
00:08:21,390 --> 00:08:25,180
Floats are a computer
scientist's approximation to

132
00:08:25,180 --> 00:08:28,990
reals, but they're not
quite the same.

133
00:08:28,990 --> 00:08:32,780
The good news is almost all the
time, you can pretend that

134
00:08:32,780 --> 00:08:36,580
a floating point number is a
real, but as we'll see in a

135
00:08:36,580 --> 00:08:41,039
few lectures, every once in a
while it can really sit up and

136
00:08:41,039 --> 00:08:43,520
bite you, if you believe that.

137
00:08:43,520 --> 00:08:46,010
But for now, we'll just pretend
that they're reals.

138
00:08:46,010 --> 00:08:51,660

139
00:08:51,660 --> 00:08:55,030
There's Booleans, a nice scalar
type of which there are

140
00:08:55,030 --> 00:08:56,280
only two values.

141
00:08:56,280 --> 00:08:59,960

142
00:08:59,960 --> 00:09:03,200
One of them is true, and what
do you think the other

143
00:09:03,200 --> 00:09:04,895
Boolean value is?

144
00:09:04,895 --> 00:09:06,200
AUDIENCE: False?

145
00:09:06,200 --> 00:09:07,230
PROFESSOR: Thank you.

146
00:09:07,230 --> 00:09:08,570
So somebody said false.

147
00:09:08,570 --> 00:09:12,000
I have no idea who, but
whoever it is, there's

148
00:09:12,000 --> 00:09:14,300
probably some candy to be had.

149
00:09:14,300 --> 00:09:16,940
Oh, I managed to find the one
place in the room where there

150
00:09:16,940 --> 00:09:18,520
was an empty.

151
00:09:18,520 --> 00:09:21,220
I'm hoping that people will now
scramble and fight for it,

152
00:09:21,220 --> 00:09:25,070
like a foul ball at
a baseball game.

153
00:09:25,070 --> 00:09:27,320
No, people are too
polite thus far.

154
00:09:27,320 --> 00:09:28,520
All right.

155
00:09:28,520 --> 00:09:31,840
So we have true and false
as the type Booleans.

156
00:09:31,840 --> 00:09:33,870
And then we can do operations
on them.

157
00:09:33,870 --> 00:09:42,650
So for example, true and false
is false, as you might guess.

158
00:09:42,650 --> 00:09:49,650
Finally, there's this funny
value, none, which doesn't

159
00:09:49,650 --> 00:09:51,620
print anything when I type it.

160
00:09:51,620 --> 00:09:56,150
And if I look at the type
of none, we'll see

161
00:09:56,150 --> 00:09:59,130
it's the none type.

162
00:09:59,130 --> 00:10:01,070
Not very interesting.

163
00:10:01,070 --> 00:10:05,000
Fundamentally, as we'll see,
that gets used when you want

164
00:10:05,000 --> 00:10:06,700
to put in something temporary.

165
00:10:06,700 --> 00:10:09,760
When you don't yet know what its
value is going to be, you

166
00:10:09,760 --> 00:10:13,170
know it's going to eventually
have one, so maybe you start

167
00:10:13,170 --> 00:10:15,180
out calling it none.

168
00:10:15,180 --> 00:10:17,440
And then you can check,
and we'll see

169
00:10:17,440 --> 00:10:20,180
how we might do that.

170
00:10:20,180 --> 00:10:25,925
So those are the fundamental
scalar types,

171
00:10:25,925 --> 00:10:29,800
the indivisible ones.

172
00:10:29,800 --> 00:10:35,290
Interestingly enough, Python
does not have what is a common

173
00:10:35,290 --> 00:10:39,650
scalar type in every other
language called char, short

174
00:10:39,650 --> 00:10:41,740
for character.

175
00:10:41,740 --> 00:10:48,190
Instead, what it has is strings
that can be used to

176
00:10:48,190 --> 00:10:51,360
represent strings
of characters.

177
00:10:51,360 --> 00:10:58,500
So for example, I can write the
string "a", and if I ask

178
00:10:58,500 --> 00:11:03,200
for the type of it, it
tells me it's an

179
00:11:03,200 --> 00:11:05,485
str, short for string.

180
00:11:05,485 --> 00:11:09,450

181
00:11:09,450 --> 00:11:12,770
Happens to be a string of
length 1, which we might

182
00:11:12,770 --> 00:11:15,730
usually think of as
a character, but

183
00:11:15,730 --> 00:11:17,510
there is no type char.

184
00:11:17,510 --> 00:11:19,080
So it's not a problem.

185
00:11:19,080 --> 00:11:21,920
We just have to remember it.

186
00:11:21,920 --> 00:11:28,270
Literals of type string can be
written with single quotes or

187
00:11:28,270 --> 00:11:29,520
with double quotes.

188
00:11:29,520 --> 00:11:32,110

189
00:11:32,110 --> 00:11:34,720
There's no difference.

190
00:11:34,720 --> 00:11:39,250
Just convenient that you can do
it either way, and we can

191
00:11:39,250 --> 00:11:42,600
build strings of things.

192
00:11:42,600 --> 00:11:49,940
It's worth noting that the type
of, say, the string 123

193
00:11:49,940 --> 00:12:00,390
is str, whereas the type of 123
without the quotes is int.

194
00:12:00,390 --> 00:12:03,020
So we have to be a little bit
careful sometimes as to

195
00:12:03,020 --> 00:12:07,860
whether we're dealing with
strings or ints when we look

196
00:12:07,860 --> 00:12:09,110
at these literals.

197
00:12:09,110 --> 00:12:11,530

198
00:12:11,530 --> 00:12:17,060
You can only get so far with
literals, things you can type.

199
00:12:17,060 --> 00:12:20,310
So of course, Python has in
it something called an

200
00:12:20,310 --> 00:12:21,870
expression.

201
00:12:21,870 --> 00:12:23,620
Again, this shouldn't
surprise anybody.

202
00:12:23,620 --> 00:12:31,185

203
00:12:31,185 --> 00:12:40,830
And an expression
is a sequence of

204
00:12:40,830 --> 00:12:45,305
operands and operators.

205
00:12:45,305 --> 00:12:50,950

206
00:12:50,950 --> 00:12:52,340
The operands are objects.

207
00:12:52,340 --> 00:12:59,610

208
00:12:59,610 --> 00:13:05,900
So for example, we can write
the expression 3 plus 2.

209
00:13:05,900 --> 00:13:09,180
And when we type an expression
into IDLE, it automatically

210
00:13:09,180 --> 00:13:13,240
evaluates it and prints the
value of the expression.

211
00:13:13,240 --> 00:13:15,605
In this case, of
course it's 5.

212
00:13:15,605 --> 00:13:18,230

213
00:13:18,230 --> 00:13:22,500
One thing to be a little careful
about is if I type the

214
00:13:22,500 --> 00:13:29,005
expression 3/2, slash is the
divide operator, I get 1.

215
00:13:29,005 --> 00:13:32,150

216
00:13:32,150 --> 00:13:35,620
Whereas if I type the expression
3.0 divided

217
00:13:35,620 --> 00:13:43,310
by 2.0, I get 1.5.

218
00:13:43,310 --> 00:13:49,760
So dividing two integers
in Python 2.x gives you

219
00:13:49,760 --> 00:13:51,405
essentially a floor operator.

220
00:13:51,405 --> 00:13:53,940

221
00:13:53,940 --> 00:13:59,120
In 3.0, by the way, integer
division is not allowed.

222
00:13:59,120 --> 00:14:01,780
It always converts it to floats
and does a floating

223
00:14:01,780 --> 00:14:03,670
point division.

224
00:14:03,670 --> 00:14:06,370
But for many of you this will
be something that will trip

225
00:14:06,370 --> 00:14:08,520
you up as a bug.

226
00:14:08,520 --> 00:14:12,970
If you want to get real
division, write

227
00:14:12,970 --> 00:14:15,030
floating point numbers.

228
00:14:15,030 --> 00:14:20,640
Otherwise, unpleasant
things may happen.

229
00:14:20,640 --> 00:14:24,240
Some other interesting things
I can type, just as I could

230
00:14:24,240 --> 00:14:32,050
type 3 plus 2, I can
type a plus b.

231
00:14:32,050 --> 00:14:33,300
What do you think
I'll get there?

232
00:14:33,300 --> 00:14:37,160

233
00:14:37,160 --> 00:14:38,490
It does concatenation.

234
00:14:38,490 --> 00:14:41,680

235
00:14:41,680 --> 00:14:49,190
So what we see here is that
the operator plus is

236
00:14:49,190 --> 00:14:50,440
overloaded.

237
00:14:50,440 --> 00:14:59,060

238
00:14:59,060 --> 00:15:11,120
So overloaded operators have a
meaning that depends upon the

239
00:15:11,120 --> 00:15:12,370
type of the operands.

240
00:15:12,370 --> 00:15:25,710

241
00:15:25,710 --> 00:15:28,170
And of course, we've already
seen that with the slash

242
00:15:28,170 --> 00:15:31,430
operator, which means one thing
for ints and another

243
00:15:31,430 --> 00:15:33,310
things for floats.

244
00:15:33,310 --> 00:15:35,585
And of course, we see the
same thing with plus.

245
00:15:35,585 --> 00:15:39,700

246
00:15:39,700 --> 00:15:41,490
What do you think will
happen here?

247
00:15:41,490 --> 00:15:44,810
3 blank 3?

248
00:15:44,810 --> 00:15:46,060
Any guesses?

249
00:15:46,060 --> 00:15:48,390

250
00:15:48,390 --> 00:15:50,120
I get a syntax error.

251
00:15:50,120 --> 00:15:52,810
Remember, we talked about
that on Tuesday.

252
00:15:52,810 --> 00:15:57,490
It's not a valid Python
expression,

253
00:15:57,490 --> 00:16:00,670
so we get an error.

254
00:16:00,670 --> 00:16:01,920
How about this one?

255
00:16:01,920 --> 00:16:06,380

256
00:16:06,380 --> 00:16:09,400
That is syntactically valid.

257
00:16:09,400 --> 00:16:13,280
It's got operand, operator,
operand.

258
00:16:13,280 --> 00:16:17,830
What do you think it will do
when I hit Return here?

259
00:16:17,830 --> 00:16:20,040
Somebody?

260
00:16:20,040 --> 00:16:22,000
AUDIENCE: A static
semantics error?

261
00:16:22,000 --> 00:16:22,490
PROFESSOR: Pardon?

262
00:16:22,490 --> 00:16:24,450
AUDIENCE: A static
semantics error?

263
00:16:24,450 --> 00:16:26,410
PROFESSOR: A static
semantics error.

264
00:16:26,410 --> 00:16:26,900
And because of these--

265
00:16:26,900 --> 00:16:28,500
Wait, I can't see
who said that.

266
00:16:28,500 --> 00:16:29,995
Raise your hand?

267
00:16:29,995 --> 00:16:31,480
Oh, come on.

268
00:16:31,480 --> 00:16:33,955
All the way back there?

269
00:16:33,955 --> 00:16:34,945
All right.

270
00:16:34,945 --> 00:16:37,915
I have the most chance of
carrying with one of these.

271
00:16:37,915 --> 00:16:43,870

272
00:16:43,870 --> 00:16:45,260
I'm going to lie.

273
00:16:45,260 --> 00:16:47,460
Those of you who are watching
OpenCourseWare, it was a

274
00:16:47,460 --> 00:16:48,710
perfect throw.

275
00:16:48,710 --> 00:16:51,450

276
00:16:51,450 --> 00:16:52,210
OK.

277
00:16:52,210 --> 00:16:58,310
So indeed, we get a static
semantic error of a particular

278
00:16:58,310 --> 00:17:01,770
kind, called the type error,
saying you cannot concatenate

279
00:17:01,770 --> 00:17:04,440
an str and an int.

280
00:17:04,440 --> 00:17:08,140

281
00:17:08,140 --> 00:17:12,345
Type errors are actually
good things.

282
00:17:12,345 --> 00:17:15,190

283
00:17:15,190 --> 00:17:19,530
The language does type checking
in order to reduce

284
00:17:19,530 --> 00:17:22,450
the probability that a
programmer will write a

285
00:17:22,450 --> 00:17:28,980
program with a meaning that
will surprise its author.

286
00:17:28,980 --> 00:17:32,380
So it looks at it and says,
somebody might have a weird

287
00:17:32,380 --> 00:17:35,760
guess what this means, but just
to be safe, we're going

288
00:17:35,760 --> 00:17:38,560
to disallow it rather than--

289
00:17:38,560 --> 00:17:40,750
it could, of course, make
up some funny meaning

290
00:17:40,750 --> 00:17:42,600
if it wanted to.

291
00:17:42,600 --> 00:17:43,970
But it doesn't.

292
00:17:43,970 --> 00:17:48,740
And I think you'll find type
checking saves you from a lot

293
00:17:48,740 --> 00:17:55,020
of careless programming
errors as you go on.

294
00:17:55,020 --> 00:17:56,410
All right, let's continue.

295
00:17:56,410 --> 00:17:58,840
Let's look at some
other things.

296
00:17:58,840 --> 00:18:00,090
I can write this.

297
00:18:00,090 --> 00:18:04,920

298
00:18:04,920 --> 00:18:07,450
Because that's just two
strings, and it just

299
00:18:07,450 --> 00:18:12,370
concatenates them, the string
a and the string 3.

300
00:18:12,370 --> 00:18:14,310
Or interestingly,
I can do this.

301
00:18:14,310 --> 00:18:18,690

302
00:18:18,690 --> 00:18:22,530
So now what we're seeing is
that you can take any type

303
00:18:22,530 --> 00:18:29,260
name, use it as a conversion
function to attempt to convert

304
00:18:29,260 --> 00:18:31,950
one type to another.

305
00:18:31,950 --> 00:18:37,330
So this has now converted the
int 3 to the str "3".

306
00:18:37,330 --> 00:18:41,690

307
00:18:41,690 --> 00:18:44,815
Similarly, I can do something
like this.

308
00:18:44,815 --> 00:18:51,010

309
00:18:51,010 --> 00:18:56,430
And here, it's converted the
str "3" to the int 3.

310
00:18:56,430 --> 00:19:00,250

311
00:19:00,250 --> 00:19:01,865
On the other hand,
I could do this.

312
00:19:01,865 --> 00:19:12,280

313
00:19:12,280 --> 00:19:17,670
And it will tell me it's a
static semantic error.

314
00:19:17,670 --> 00:19:23,450
It can't convert 0.0
into an int.

315
00:19:23,450 --> 00:19:31,840
Similarly, it can't
convert 2.1.

316
00:19:31,840 --> 00:19:33,670
Or can it?

317
00:19:33,670 --> 00:19:37,460
So now I've given it the float
2.1, and I've tried to

318
00:19:37,460 --> 00:19:39,120
convert it to int.

319
00:19:39,120 --> 00:19:41,760
Not the string 2.1,
but the float.

320
00:19:41,760 --> 00:19:43,010
And it succeeds.

321
00:19:43,010 --> 00:19:45,580

322
00:19:45,580 --> 00:19:49,110
And it succeeded by essentially
truncating it.

323
00:19:49,110 --> 00:19:53,280

324
00:19:53,280 --> 00:19:55,280
Is this a good thing
or a bad thing?

325
00:19:55,280 --> 00:19:57,960

326
00:19:57,960 --> 00:20:00,690
To me, it's kind
of a bad thing.

327
00:20:00,690 --> 00:20:04,050
If I've typed something like
that or I've evaluated some

328
00:20:04,050 --> 00:20:08,610
expression that happened to
work that way, more likely

329
00:20:08,610 --> 00:20:10,010
than not, I'm confused.

330
00:20:10,010 --> 00:20:13,660
And I would probably have
preferred to get a type error,

331
00:20:13,660 --> 00:20:17,180
rather than it deciding
how to do it.

332
00:20:17,180 --> 00:20:20,740
It's one of the things I don't
like about Python.

333
00:20:20,740 --> 00:20:22,600
It's too generous.

334
00:20:22,600 --> 00:20:24,760
It lets me get away with
stuff it shouldn't

335
00:20:24,760 --> 00:20:26,560
let me get away with.

336
00:20:26,560 --> 00:20:31,020
Other languages, for example
Java, are much stricter.

337
00:20:31,020 --> 00:20:35,310
This is a design decision and
it is the way it is, and we

338
00:20:35,310 --> 00:20:36,896
have to live with it.

339
00:20:36,896 --> 00:20:37,830
AUDIENCE: Professor?

340
00:20:37,830 --> 00:20:38,290
Yes?

341
00:20:38,290 --> 00:20:40,720
AUDIENCE: Is that the same
reason that 3 divided by 2

342
00:20:40,720 --> 00:20:42,664
turned into 1 up top?

343
00:20:42,664 --> 00:20:43,150
PROFESSOR: Yeah.

344
00:20:43,150 --> 00:20:44,620
Exactly.

345
00:20:44,620 --> 00:20:48,965
If it's the same reason that
that happens, this will never

346
00:20:48,965 --> 00:20:52,304
go that far.

347
00:20:52,304 --> 00:20:53,735
[UNINTELLIGIBLE].

348
00:20:53,735 --> 00:20:55,440
Yeah, exactly.

349
00:20:55,440 --> 00:20:56,590
It's the same reason.

350
00:20:56,590 --> 00:20:59,380
The question was, is it the same
reason that 3 divided by

351
00:20:59,380 --> 00:21:02,940
2 doesn't give you the
answer you would get

352
00:21:02,940 --> 00:21:03,880
with floating point.

353
00:21:03,880 --> 00:21:08,130
And it's because Python
has tried to help you.

354
00:21:08,130 --> 00:21:13,210
Again, Python 3.0 is a little
stricter about these things.

355
00:21:13,210 --> 00:21:15,590
We'll talk much more about
this during the term.

356
00:21:15,590 --> 00:21:18,600

357
00:21:18,600 --> 00:21:22,370
This is close to the last time
you'll see me typing things

358
00:21:22,370 --> 00:21:24,940
directly into IDLE.

359
00:21:24,940 --> 00:21:28,220
For the most part, as you write
programs, you'll use the

360
00:21:28,220 --> 00:21:32,220
text editor to produce them
and then go to the

361
00:21:32,220 --> 00:21:34,080
shell to run them.

362
00:21:34,080 --> 00:21:36,180
But you want to--

363
00:21:36,180 --> 00:21:38,920
obviously, if I had a 100 line
program, I wouldn't want to

364
00:21:38,920 --> 00:21:42,690
sit here and retype it every
time I needed to change it.

365
00:21:42,690 --> 00:21:45,320
So instead, I use the editor
in IDLE to produce the

366
00:21:45,320 --> 00:21:49,320
programs, and then
I can run them.

367
00:21:49,320 --> 00:21:52,200
And that's what I wanted
to start doing.

368
00:21:52,200 --> 00:21:58,160
I should probably mention that
what most people call a

369
00:21:58,160 --> 00:22:03,650
program, some Python programmers
call a script.

370
00:22:03,650 --> 00:22:07,130

371
00:22:07,130 --> 00:22:10,790
Think of those two things
as synonyms.

372
00:22:10,790 --> 00:22:15,020
But you will see people
use both of them.

373
00:22:15,020 --> 00:22:19,180
I will typically call
them a program.

374
00:22:19,180 --> 00:22:19,530
All right.

375
00:22:19,530 --> 00:22:22,790
Let's look at an example.

376
00:22:22,790 --> 00:22:27,450
So the first thing to say is
that things look a little bit

377
00:22:27,450 --> 00:22:30,950
different when they're executed
from a script than

378
00:22:30,950 --> 00:22:35,040
when you execute them directly
in the interpreter.

379
00:22:35,040 --> 00:22:37,825
So I happen to have
a script here.

380
00:22:37,825 --> 00:22:40,900

381
00:22:40,900 --> 00:22:44,440
If a line in a script starts
with a sharp sign or a number

382
00:22:44,440 --> 00:22:47,360
sign, that makes it a comment.

383
00:22:47,360 --> 00:22:49,300
So it's not executed.

384
00:22:49,300 --> 00:22:53,365
So I've started here just by
commenting out everything.

385
00:22:53,365 --> 00:22:57,070

386
00:22:57,070 --> 00:22:58,660
But now--

387
00:22:58,660 --> 00:22:59,910
whoops--

388
00:22:59,910 --> 00:23:05,230

389
00:23:05,230 --> 00:23:08,250
what happens if I just put
the number 3 here?

390
00:23:08,250 --> 00:23:12,600
We saw when I typed it into
IDLE, it echoed it in some

391
00:23:12,600 --> 00:23:14,615
sense and gave me what it was.

392
00:23:14,615 --> 00:23:18,170
Or just to be clear, I'm
going to put in the

393
00:23:18,170 --> 00:23:21,630
expression type of 3.

394
00:23:21,630 --> 00:23:27,380
I'll save it, and then I'll
hit F5 to run it.

395
00:23:27,380 --> 00:23:28,840
And it does nothing.

396
00:23:28,840 --> 00:23:29,190
Right?

397
00:23:29,190 --> 00:23:30,470
You saw it move.

398
00:23:30,470 --> 00:23:32,360
It didn't print anything.

399
00:23:32,360 --> 00:23:34,770
So when you type an expression
into the shell,

400
00:23:34,770 --> 00:23:36,690
it prints the value.

401
00:23:36,690 --> 00:23:39,760
But when it executes a script
with an expression, it

402
00:23:39,760 --> 00:23:42,430
evaluates the expression
but does not

403
00:23:42,430 --> 00:23:45,590
display it on the screen.

404
00:23:45,590 --> 00:23:48,420
Well, so what do we
do about that?

405
00:23:48,420 --> 00:23:52,520
There is something called
a print command.

406
00:23:52,520 --> 00:24:01,260
So I can do this, Print type of
3, and now if I run it, it

407
00:24:01,260 --> 00:24:03,890
will actually appear.

408
00:24:03,890 --> 00:24:06,200
So whenever you want to get
something to appear, you have

409
00:24:06,200 --> 00:24:09,600
to use the Print command.

410
00:24:09,600 --> 00:24:11,315
Not a very complicated
concept.

411
00:24:11,315 --> 00:24:16,220

412
00:24:16,220 --> 00:24:25,240
A program, or a script, is
a sequence of commands.

413
00:24:25,240 --> 00:24:28,610

414
00:24:28,610 --> 00:24:33,100
Each one tells the interpreter
to do something.

415
00:24:33,100 --> 00:24:35,660
So a command is Print,
for example.

416
00:24:35,660 --> 00:24:42,470

417
00:24:42,470 --> 00:24:42,930
OK.

418
00:24:42,930 --> 00:24:43,980
So that's there.

419
00:24:43,980 --> 00:24:44,960
That's kind of boring.

420
00:24:44,960 --> 00:24:46,210
I'll get rid of that.

421
00:24:46,210 --> 00:24:49,480

422
00:24:49,480 --> 00:24:55,040
The next command is a really
interesting one.

423
00:24:55,040 --> 00:24:58,750
It's an assignment statement.

424
00:24:58,750 --> 00:25:04,850
A key concept in almost every
programming language is that

425
00:25:04,850 --> 00:25:06,100
of a variable.

426
00:25:06,100 --> 00:25:08,570

427
00:25:08,570 --> 00:25:12,010
Different languages have
different notions of what a

428
00:25:12,010 --> 00:25:14,940
variable means.

429
00:25:14,940 --> 00:25:21,540
In Python, a variable is simply
a name for an object.

430
00:25:21,540 --> 00:25:43,880

431
00:25:43,880 --> 00:25:47,520
And what an assignment statement
does in Python, is

432
00:25:47,520 --> 00:25:51,315
it binds the name
to an object.

433
00:25:51,315 --> 00:26:05,860

434
00:26:05,860 --> 00:26:11,390
So the assignment stetement you
see here binds the name x

435
00:26:11,390 --> 00:26:12,715
to the object 3.

436
00:26:12,715 --> 00:26:17,650

437
00:26:17,650 --> 00:26:22,750
The next statement rebinds the
name x to the value of the

438
00:26:22,750 --> 00:26:25,530
expression x times x.

439
00:26:25,530 --> 00:26:30,190
So it takes the old value of x,
evaluates the expression,

440
00:26:30,190 --> 00:26:33,200
and then binds the name
x to the new value.

441
00:26:33,200 --> 00:26:36,870
So at the end of the
second statement, x

442
00:26:36,870 --> 00:26:38,560
will be bound to 9.

443
00:26:38,560 --> 00:26:41,020
By the way, these are really
stupid comments

444
00:26:41,020 --> 00:26:43,320
I've written here.

445
00:26:43,320 --> 00:26:44,920
I put them in just to
show you what these

446
00:26:44,920 --> 00:26:46,390
statements are doing.

447
00:26:46,390 --> 00:26:49,210
For goodness sake, when you
write comments in your

448
00:26:49,210 --> 00:26:54,070
programs, assume that the reader
can read Python, and

449
00:26:54,070 --> 00:26:55,690
you don't have to explain
the programming

450
00:26:55,690 --> 00:26:58,310
language in your comments.

451
00:26:58,310 --> 00:27:01,360
That's not to say you shouldn't
write any comments.

452
00:27:01,360 --> 00:27:04,270
The purpose of a comment
is to make the

453
00:27:04,270 --> 00:27:08,030
program easier to read.

454
00:27:08,030 --> 00:27:11,390
And so typically, comments are
there to explain things.

455
00:27:11,390 --> 00:27:13,950

456
00:27:13,950 --> 00:27:18,430
Not to explain the language or
its semantics, but to explain

457
00:27:18,430 --> 00:27:22,530
your thinking when you
wrote the program.

458
00:27:22,530 --> 00:27:26,450
What is the algorithm
you've used?

459
00:27:26,450 --> 00:27:29,950
And we'll see some useful
examples of comments, probably

460
00:27:29,950 --> 00:27:32,610
not today, but later.

461
00:27:32,610 --> 00:27:32,950
All right.

462
00:27:32,950 --> 00:27:34,570
So let's execute this script.

463
00:27:34,570 --> 00:27:38,820

464
00:27:38,820 --> 00:27:41,890
Sure enough, it printed 9.

465
00:27:41,890 --> 00:27:43,365
Just what we would have hoped.

466
00:27:43,365 --> 00:27:49,410

467
00:27:49,410 --> 00:27:49,770
All right.

468
00:27:49,770 --> 00:27:51,970
Now let's try some
other things.

469
00:27:51,970 --> 00:27:57,220

470
00:27:57,220 --> 00:28:00,840
Print lets us output things.

471
00:28:00,840 --> 00:28:05,240
Raw input lets us
input things.

472
00:28:05,240 --> 00:28:10,070
Get things from the keyboard,
essentially.

473
00:28:10,070 --> 00:28:14,830
So this statement here is making
a request to whoever is

474
00:28:14,830 --> 00:28:17,280
using the program to
enter a number.

475
00:28:17,280 --> 00:28:19,910

476
00:28:19,910 --> 00:28:26,100
There are two kinds of input
statements in Python 2.x.

477
00:28:26,100 --> 00:28:29,270
There's raw input, which is the
only one you will see me

478
00:28:29,270 --> 00:28:32,860
use, and input.

479
00:28:32,860 --> 00:28:38,770
Raw input, by the way, is the
only one that exists in 3.0.

480
00:28:38,770 --> 00:28:44,080
So please, just use raw input.

481
00:28:44,080 --> 00:28:48,710
The difference is, raw input
always expects, interprets

482
00:28:48,710 --> 00:28:52,690
what the user types
as a string.

483
00:28:52,690 --> 00:29:02,160
So it will see here, it says,
y equals float of raw input.

484
00:29:02,160 --> 00:29:03,600
Enter a number.

485
00:29:03,600 --> 00:29:06,750
So let's run it.

486
00:29:06,750 --> 00:29:12,220
So it's taken the argument to
raw input, the string enter a

487
00:29:12,220 --> 00:29:14,740
number asked me to
enter a number.

488
00:29:14,740 --> 00:29:15,990
I'll enter a number.

489
00:29:15,990 --> 00:29:20,280

490
00:29:20,280 --> 00:29:28,390
And then it's converted
it to a float.

491
00:29:28,390 --> 00:29:29,845
Suppose I get rid of that.

492
00:29:29,845 --> 00:29:32,600

493
00:29:32,600 --> 00:29:33,850
Suppose I do this.

494
00:29:33,850 --> 00:29:50,560

495
00:29:50,560 --> 00:29:51,810
That should work.

496
00:29:51,810 --> 00:30:06,170

497
00:30:06,170 --> 00:30:07,620
So now something has happened.

498
00:30:07,620 --> 00:30:11,140
It's printed both
of them as 3.0.

499
00:30:11,140 --> 00:30:14,480
It looks like they're
the same, but in

500
00:30:14,480 --> 00:30:17,880
fact, they're not.

501
00:30:17,880 --> 00:30:20,280
And this is something
to beware of.

502
00:30:20,280 --> 00:30:28,000
What we've seen here is when
it prints a string, it does

503
00:30:28,000 --> 00:30:31,760
not print the quotation marks.

504
00:30:31,760 --> 00:30:38,930
So even though, if I were to put
this in here, I'll put in

505
00:30:38,930 --> 00:30:40,480
two print types of y.

506
00:30:40,480 --> 00:30:47,520

507
00:30:47,520 --> 00:30:50,590
And I'll comment this out
because I'm getting kind of

508
00:30:50,590 --> 00:30:51,950
tired of seeing 9.

509
00:30:51,950 --> 00:31:03,230

510
00:31:03,230 --> 00:31:04,980
You'll note that one
is a string and

511
00:31:04,980 --> 00:31:07,860
the other is a float.

512
00:31:07,860 --> 00:31:10,130
Again, I point this out because
this is something that

513
00:31:10,130 --> 00:31:14,040
can confuse people when they're
debugging programs.

514
00:31:14,040 --> 00:31:16,530
Because you think it's
a float, when

515
00:31:16,530 --> 00:31:17,780
in fact it's a string.

516
00:31:17,780 --> 00:31:20,750

517
00:31:20,750 --> 00:31:21,180
OK.

518
00:31:21,180 --> 00:31:24,830
Nothing deep, but these are the
things that sort of get

519
00:31:24,830 --> 00:31:27,650
people in trouble.

520
00:31:27,650 --> 00:31:32,590
Now the kinds of programs we've
been looking at so far

521
00:31:32,590 --> 00:31:34,730
are what are called straight
line programs.

522
00:31:34,730 --> 00:31:43,740

523
00:31:43,740 --> 00:31:48,750
What distinguishes a straight
line program is it's a

524
00:31:48,750 --> 00:31:52,860
sequence of commands you execute
one after another.

525
00:31:52,860 --> 00:31:57,000
You execute every command
without making any deviations,

526
00:31:57,000 --> 00:32:00,340
without going back with any
loops to execute a command

527
00:32:00,340 --> 00:32:01,930
more than once.

528
00:32:01,930 --> 00:32:05,940
So in a straight line program,
every command gets executed

529
00:32:05,940 --> 00:32:07,235
exactly once.

530
00:32:07,235 --> 00:32:10,430

531
00:32:10,430 --> 00:32:16,010
There is a very elegant, and
even useful theory that talks

532
00:32:16,010 --> 00:32:19,050
about different layers of,
levels of complexity of

533
00:32:19,050 --> 00:32:23,220
programs and says, for
example, what kind of

534
00:32:23,220 --> 00:32:27,380
functions can you compute with
straight line programs.

535
00:32:27,380 --> 00:32:30,290
We'll talk more about that
field, which is called

536
00:32:30,290 --> 00:32:34,240
complexity theory, later
in this semester.

537
00:32:34,240 --> 00:32:37,130
But for now, the thing to
realize is that straight line

538
00:32:37,130 --> 00:32:40,500
programs are just dead boring.

539
00:32:40,500 --> 00:32:45,010
You can't compute anything
interesting with one.

540
00:32:45,010 --> 00:32:47,240
Last time we talked about
a recipe as an

541
00:32:47,240 --> 00:32:50,700
analogy for a program.

542
00:32:50,700 --> 00:32:54,850
Imagine a recipe
with no tests.

543
00:32:54,850 --> 00:32:57,320
So every recipe, or almost
every recipe I

544
00:32:57,320 --> 00:33:00,700
know, has some decisions.

545
00:33:00,700 --> 00:33:03,240
Taste it and add salt
if you need it.

546
00:33:03,240 --> 00:33:06,640
Or poke at the meat and
see if it's done.

547
00:33:06,640 --> 00:33:08,770
Or cook it until the
thermometer says

548
00:33:08,770 --> 00:33:11,880
some degree on it.

549
00:33:11,880 --> 00:33:14,380
Those are the kinds of
tests we need to

550
00:33:14,380 --> 00:33:17,660
make interesting programs.

551
00:33:17,660 --> 00:33:22,630
The most primitive kind of test
we see is what's called a

552
00:33:22,630 --> 00:33:23,880
conditional statement.

553
00:33:23,880 --> 00:33:31,940

554
00:33:31,940 --> 00:33:36,400
And those are written using the
word if, and optionally as

555
00:33:36,400 --> 00:33:44,800
we'll see, the words else or
elif, standing for else, if.

556
00:33:44,800 --> 00:33:46,770
So let's look at an
example here.

557
00:33:46,770 --> 00:33:52,420

558
00:33:52,420 --> 00:33:54,030
Where'd my mouse,
oh there it is.

559
00:33:54,030 --> 00:34:05,540

560
00:34:05,540 --> 00:34:06,790
Yes?

561
00:34:06,790 --> 00:34:08,530

562
00:34:08,530 --> 00:34:09,850
Somebody has a question?

563
00:34:09,850 --> 00:34:11,600
Shout it out.

564
00:34:11,600 --> 00:34:11,989
AUDIENCE: Sorry.

565
00:34:11,989 --> 00:34:15,322
I was wondering, when the user's
prompted to put in the

566
00:34:15,322 --> 00:34:18,654
raw input, instead of putting
in a float, puts in string,

567
00:34:18,654 --> 00:34:21,462
could you define it as
a floating integer?

568
00:34:21,462 --> 00:34:23,040
How would you interpret
that input?

569
00:34:23,040 --> 00:34:25,270
PROFESSOR: I didn't
get the question.

570
00:34:25,270 --> 00:34:28,310
So this is an argument to
raw input, or their

571
00:34:28,310 --> 00:34:31,080
response to raw input.

572
00:34:31,080 --> 00:34:32,949
AUDIENCE: So yeah, for the
raw input where you

573
00:34:32,949 --> 00:34:34,280
define it as a quote--

574
00:34:34,280 --> 00:34:34,772
PROFESSOR: Yeah.

575
00:34:34,772 --> 00:34:36,248
AUDIENCE: It usually
puts in a string.

576
00:34:36,248 --> 00:34:38,710
How does Python interpret
that?

577
00:34:38,710 --> 00:34:40,600
PROFESSOR: It will interpret
it as a string containing

578
00:34:40,600 --> 00:34:42,606
quotation marks.

579
00:34:42,606 --> 00:34:43,020
AUDIENCE: OK.

580
00:34:43,020 --> 00:34:46,420
PROFESSOR: So typically you
don't type a string, because

581
00:34:46,420 --> 00:34:50,270
it interprets everything you
type as if it were a string.

582
00:34:50,270 --> 00:34:53,254
So don't bother typing
strings.

583
00:34:53,254 --> 00:34:54,179
Good question.

584
00:34:54,179 --> 00:34:57,045
Thank you.

585
00:34:57,045 --> 00:34:57,490
All right.

586
00:34:57,490 --> 00:34:58,740
So let's look at this.

587
00:34:58,740 --> 00:35:03,670

588
00:35:03,670 --> 00:35:08,120
So here I'm going to get an
int, or at least a string.

589
00:35:08,120 --> 00:35:10,610
I'll convert it to an int.

590
00:35:10,610 --> 00:35:14,690
Then I'll say, if x remainder
two, that's what the percent

591
00:35:14,690 --> 00:35:17,980
sign is, it's a remainder
or a mod operator,

592
00:35:17,980 --> 00:35:21,100
is equal equal zero.

593
00:35:21,100 --> 00:35:22,460
That's important.

594
00:35:22,460 --> 00:35:29,100
You'll notice that we used an
equal sign to do assignments.

595
00:35:29,100 --> 00:35:33,580
If we want to do a comparison,
whether two objects have the

596
00:35:33,580 --> 00:35:36,710
same value, we don't write
a single equal.

597
00:35:36,710 --> 00:35:39,290
We write a double equal.

598
00:35:39,290 --> 00:35:42,930
So whenever you're testing for
equality of objects, you use

599
00:35:42,930 --> 00:35:45,590
double equal.

600
00:35:45,590 --> 00:35:51,040
So it says, if the object x mod
2 has the same value as

601
00:35:51,040 --> 00:35:55,520
the object zero, print even.

602
00:35:55,520 --> 00:35:58,700
Else, print odd.

603
00:35:58,700 --> 00:36:02,080
And then, just for fun, I'm
going to see whether or not

604
00:36:02,080 --> 00:36:04,150
it's divisible by three.

605
00:36:04,150 --> 00:36:06,010
Why did I do that?

606
00:36:06,010 --> 00:36:09,100
Just to show you that I can
nest conditionals inside

607
00:36:09,100 --> 00:36:11,190
conditionals.

608
00:36:11,190 --> 00:36:13,660
So in one of the branches of
the conditionals, I'm now

609
00:36:13,660 --> 00:36:16,090
doing a test.

610
00:36:16,090 --> 00:36:20,960
So what this does, is if comes
down, it does the test.

611
00:36:20,960 --> 00:36:27,250
If the value of the test is
true, it executes the block of

612
00:36:27,250 --> 00:36:33,090
code following the if, in
this case, just print.

613
00:36:33,090 --> 00:36:34,860
And then it skips the else.

614
00:36:34,860 --> 00:36:36,930
It does not execute the else.

615
00:36:36,930 --> 00:36:40,250
So it executes one
or the other.

616
00:36:40,250 --> 00:36:44,490
If the test is false, it skips
the block of code following

617
00:36:44,490 --> 00:36:49,870
the if and executes the block
of code following the else.

618
00:36:49,870 --> 00:36:53,441
So it does a or b,
but not both.

619
00:36:53,441 --> 00:36:57,280
The indentation is important.

620
00:36:57,280 --> 00:37:03,270
Python is very unusual in that
the way you indent things

621
00:37:03,270 --> 00:37:05,630
actually affects the
meaning of them.

622
00:37:05,630 --> 00:37:09,460

623
00:37:09,460 --> 00:37:12,590
And you can tell that, if I
were to type this in the

624
00:37:12,590 --> 00:37:18,080
editor, you'll note here it's
on that line, but if I hit

625
00:37:18,080 --> 00:37:21,050
Return, it automatically
indents it.

626
00:37:21,050 --> 00:37:23,790
That's the auto indent feature
I mentioned earlier in the

627
00:37:23,790 --> 00:37:26,890
editor of IDLE.

628
00:37:26,890 --> 00:37:30,920
And this tells me how these
things line up.

629
00:37:30,920 --> 00:37:37,320
So the fact that this is here
tells me I execute it only as

630
00:37:37,320 --> 00:37:40,460
part of the else clause.

631
00:37:40,460 --> 00:37:43,580
The program would mean something
quite different if I

632
00:37:43,580 --> 00:37:44,830
wrote this.

633
00:37:44,830 --> 00:37:48,520

634
00:37:48,520 --> 00:37:55,310
Then it would mean, if x mod
2 is zero, print even.

635
00:37:55,310 --> 00:37:57,340
Otherwise, print odd.

636
00:37:57,340 --> 00:38:00,370
And whether or not it was
even or odd, do this

637
00:38:00,370 --> 00:38:01,620
test in the if statement.

638
00:38:01,620 --> 00:38:04,260

639
00:38:04,260 --> 00:38:08,440
So the indentation actually
affects the

640
00:38:08,440 --> 00:38:11,750
meaning of the program.

641
00:38:11,750 --> 00:38:15,120
Now a lot of other languages,
almost all other languages,

642
00:38:15,120 --> 00:38:16,500
don't do that.

643
00:38:16,500 --> 00:38:18,830
They have some punctuation.

644
00:38:18,830 --> 00:38:23,180
For example, c uses set braces
to designate what's called a

645
00:38:23,180 --> 00:38:24,430
block of code.

646
00:38:24,430 --> 00:38:29,850

647
00:38:29,850 --> 00:38:34,720
If you look, however, at a
well-written piece of C code,

648
00:38:34,720 --> 00:38:38,820
or Java code, or any other
language that I know,

649
00:38:38,820 --> 00:38:43,440
programmers are trained to use
indentation to show the

650
00:38:43,440 --> 00:38:45,770
structure of the program.

651
00:38:45,770 --> 00:38:48,300
Even though you don't need, it
you could line up everything

652
00:38:48,300 --> 00:38:53,330
right at the left edge and
just use the punctuation.

653
00:38:53,330 --> 00:38:54,570
People don't do that.

654
00:38:54,570 --> 00:38:59,880
And the reason they don't do
that is programs are intended

655
00:38:59,880 --> 00:39:11,470
to be read, not just executed.

656
00:39:11,470 --> 00:39:14,630
Why are they intended
to be read?

657
00:39:14,630 --> 00:39:17,890
Because the only reason, the
only way you can debug a

658
00:39:17,890 --> 00:39:19,920
program is reading
the code in it.

659
00:39:19,920 --> 00:39:23,920

660
00:39:23,920 --> 00:39:26,900
Typically, you want to write
your program so that if you

661
00:39:26,900 --> 00:39:31,220
look at it from a distance, the
visual structure of the

662
00:39:31,220 --> 00:39:35,710
program reflects the semantics
of the program.

663
00:39:35,710 --> 00:39:38,340
And that's why people use
indentation when they don't

664
00:39:38,340 --> 00:39:42,010
need to, so that you can see the
structure of the program

665
00:39:42,010 --> 00:39:46,850
by looking at it on your screen
and not having to parse

666
00:39:46,850 --> 00:39:49,790
each symbol.

667
00:39:49,790 --> 00:39:52,760
The authors of Python made what
I think is a very good

668
00:39:52,760 --> 00:39:54,260
design decision.

669
00:39:54,260 --> 00:39:56,680
They said, well, if that's the
way you ought to write your

670
00:39:56,680 --> 00:40:00,310
programs, let's force people to
write their programs that

671
00:40:00,310 --> 00:40:06,400
way and guarantee that the
visual structure of the

672
00:40:06,400 --> 00:40:10,970
program actually matches
the semantic structure.

673
00:40:10,970 --> 00:40:15,310
The problem with languages like
C and Java is that you

674
00:40:15,310 --> 00:40:19,970
can indent things and fool the
reader of the program by

675
00:40:19,970 --> 00:40:24,180
making it look like something is
under something else, when

676
00:40:24,180 --> 00:40:28,650
in fact it really isn't, because
of the punctuation.

677
00:40:28,650 --> 00:40:31,790
So here we have a guarantee
that the visual structure

678
00:40:31,790 --> 00:40:35,020
matches the semantic structure,
and I think that

679
00:40:35,020 --> 00:40:40,690
was one of the really good
design decisions in Python.

680
00:40:40,690 --> 00:40:43,630
OK, people see that?

681
00:40:43,630 --> 00:40:46,180
So we could execute
this program.

682
00:40:46,180 --> 00:40:50,780
Let me get back to what
it was before.

683
00:40:50,780 --> 00:40:53,080
Control z is the go back.

684
00:40:53,080 --> 00:40:56,660

685
00:40:56,660 --> 00:41:00,900
And now we can enter an integer,
say 14, and it will

686
00:41:00,900 --> 00:41:04,150
tell us it's even.

687
00:41:04,150 --> 00:41:10,810
I can run it again, and now I'll
put 15 in, and it will

688
00:41:10,810 --> 00:41:14,140
tell me it's odd.

689
00:41:14,140 --> 00:41:17,770
We'll try it once more.

690
00:41:17,770 --> 00:41:20,290
We'll put in 17.

691
00:41:20,290 --> 00:41:25,160
It was odd and it's not
divisible by three.

692
00:41:25,160 --> 00:41:29,445
These kinds of programs are
called branching programs.

693
00:41:29,445 --> 00:41:41,220

694
00:41:41,220 --> 00:41:43,380
And that's because the structure
of them, as you go

695
00:41:43,380 --> 00:41:46,690
down you execute some
statements, and then there's a

696
00:41:46,690 --> 00:41:51,200
branch which says execute these
statements or execute

697
00:41:51,200 --> 00:41:53,530
those statements.

698
00:41:53,530 --> 00:42:00,530
And then typically it comes back
together and continues.

699
00:42:00,530 --> 00:42:03,620
Of course, branches can
have sub-branches.

700
00:42:03,620 --> 00:42:09,460
We could do this and then
join further down,

701
00:42:09,460 --> 00:42:10,710
as we've seen here.

702
00:42:10,710 --> 00:42:13,040

703
00:42:13,040 --> 00:42:16,820
Now branching programs are much
more interesting than

704
00:42:16,820 --> 00:42:19,090
straight line programs.

705
00:42:19,090 --> 00:42:24,450
We can do a lot of things with
them, but fundamentally

706
00:42:24,450 --> 00:42:28,130
nothing really interesting.

707
00:42:28,130 --> 00:42:33,190
And we can think about that by
thinking about how long it

708
00:42:33,190 --> 00:42:36,820
takes a branching
program to run.

709
00:42:36,820 --> 00:42:39,650
So let's first ask the question,
how long does it

710
00:42:39,650 --> 00:42:43,310
take a straight line
program to run?

711
00:42:43,310 --> 00:42:44,780
14 seconds?

712
00:42:44,780 --> 00:42:47,580
No, that's not the way
to think about it.

713
00:42:47,580 --> 00:42:50,260
How would we think about how
long it takes it to run?

714
00:42:50,260 --> 00:42:53,250
What governs the length
of time a straight

715
00:42:53,250 --> 00:42:56,135
line program can take?

716
00:42:56,135 --> 00:42:57,530
AUDIENCE: [INAUDIBLE].

717
00:42:57,530 --> 00:42:58,630
PROFESSOR: Exactly.

718
00:42:58,630 --> 00:43:02,610
The number of statements or
commands in the program.

719
00:43:02,610 --> 00:43:07,110
Since it executes every command
exactly once, if you

720
00:43:07,110 --> 00:43:11,350
have 100 command, it will
have 100 steps in it.

721
00:43:11,350 --> 00:43:14,190
Now there's some variation on
how long each step will be.

722
00:43:14,190 --> 00:43:18,400
Some commands might take longer
than others, but the

723
00:43:18,400 --> 00:43:21,320
length of time it can take
to run has nothing

724
00:43:21,320 --> 00:43:23,340
to do with its input.

725
00:43:23,340 --> 00:43:28,930
It has to do only with the
number of lines of code.

726
00:43:28,930 --> 00:43:34,230
And that tells us it's not very
useful because, well, we

727
00:43:34,230 --> 00:43:37,640
can only type so many lines
in our lifetime.

728
00:43:37,640 --> 00:43:40,180
Well branching programs
have the same problem.

729
00:43:40,180 --> 00:43:42,890

730
00:43:42,890 --> 00:43:45,200
In a branching program,
each command is

731
00:43:45,200 --> 00:43:49,290
executed at most once.

732
00:43:49,290 --> 00:43:53,170
So again, the length of time
it takes to execute the

733
00:43:53,170 --> 00:43:59,820
program is governed strictly
by the size of the program.

734
00:43:59,820 --> 00:44:02,050
Why isn't that good enough?

735
00:44:02,050 --> 00:44:07,330
Well, think about a program,
say, to compute the GPA of all

736
00:44:07,330 --> 00:44:08,580
the students at MIT.

737
00:44:08,580 --> 00:44:11,460

738
00:44:11,460 --> 00:44:13,590
Well how long is that
going to take?

739
00:44:13,590 --> 00:44:16,720

740
00:44:16,720 --> 00:44:21,630
Think instead about a program to
compute the GPA of all the

741
00:44:21,630 --> 00:44:26,620
students at the University of
Michigan, which is probably 10

742
00:44:26,620 --> 00:44:28,730
times bigger than MIT.

743
00:44:28,730 --> 00:44:31,420
Well you would expect that
to take longer, right?

744
00:44:31,420 --> 00:44:35,270
Because you have to look
at more students.

745
00:44:35,270 --> 00:44:37,160
And in fact, it's true.

746
00:44:37,160 --> 00:44:40,390
Most programs that are
interesting, the amount of

747
00:44:40,390 --> 00:44:43,800
time they take to run should
depend not on the length of

748
00:44:43,800 --> 00:44:48,130
the program, but on the size of
the data that you want to

749
00:44:48,130 --> 00:44:51,190
evaluate using the program.

750
00:44:51,190 --> 00:44:54,500
So you would argue that the
amount of time taken to

751
00:44:54,500 --> 00:44:58,330
compute the GPA of the students
at MIT should be

752
00:44:58,330 --> 00:45:02,260
proportional to the number of
students, not proportional to

753
00:45:02,260 --> 00:45:05,890
the length of the program
used to do it.

754
00:45:05,890 --> 00:45:08,780
We'll talk a lot more about that
later in the term in a

755
00:45:08,780 --> 00:45:12,180
much more thorough way.

756
00:45:12,180 --> 00:45:18,110
But it's important to get that
as something you think about.

757
00:45:18,110 --> 00:45:21,820
So the fact that branching
programs are not proportional

758
00:45:21,820 --> 00:45:25,390
in time to the input means that
they're limited in what

759
00:45:25,390 --> 00:45:28,000
they can do.

760
00:45:28,000 --> 00:45:33,150
So that gets us to the final
concept we need to write every

761
00:45:33,150 --> 00:45:36,350
program that could ever be
written, or at least to

762
00:45:36,350 --> 00:45:41,650
compute every function that
could ever be computed.

763
00:45:41,650 --> 00:45:44,210
And that's some sort of
a looping construct.

764
00:45:44,210 --> 00:45:56,600

765
00:45:56,600 --> 00:46:02,150
Once we add loops, we get to a
class of programming languages

766
00:46:02,150 --> 00:46:07,390
or programming constructs that's
called Turing Complete.

767
00:46:07,390 --> 00:46:10,650
And I mentioned this
last time.

768
00:46:10,650 --> 00:46:13,150
Any program that can be written,
or any function that

769
00:46:13,150 --> 00:46:17,140
can be computed, rather, can
be computed in a Turing

770
00:46:17,140 --> 00:46:20,100
Complete language.

771
00:46:20,100 --> 00:46:21,835
So let's look at an
example here.

772
00:46:21,835 --> 00:46:24,410

773
00:46:24,410 --> 00:46:27,513
This concept, by the way,
is called iteration.

774
00:46:27,513 --> 00:46:33,620

775
00:46:33,620 --> 00:46:40,850
And if we look at languages with
iteration, what we'll see

776
00:46:40,850 --> 00:46:44,130
is a more complicated
flow of control.

777
00:46:44,130 --> 00:46:47,280
You execute some statements,
maybe you do some

778
00:46:47,280 --> 00:46:48,530
branching if you want.

779
00:46:48,530 --> 00:46:53,520

780
00:46:53,520 --> 00:46:59,480
But then you're allowed to go
back and execute statements

781
00:46:59,480 --> 00:47:02,060
you've already executed.

782
00:47:02,060 --> 00:47:04,045
Typically what you have
is another branch.

783
00:47:04,045 --> 00:47:09,450

784
00:47:09,450 --> 00:47:11,480
One branch goes back
and one continues.

785
00:47:11,480 --> 00:47:15,200

786
00:47:15,200 --> 00:47:20,570
So now we see we can execute
a statement more than once.

787
00:47:20,570 --> 00:47:25,820
Suddenly we have enormous
power at our disposal.

788
00:47:25,820 --> 00:47:27,660
So let's look at an
example of that.

789
00:47:27,660 --> 00:47:43,640

790
00:47:43,640 --> 00:47:46,500
By the way, I'm skipping some
of the code in your handout,

791
00:47:46,500 --> 00:47:53,530
but that's probably fine because
it's there for you to

792
00:47:53,530 --> 00:47:54,370
be able to read.

793
00:47:54,370 --> 00:47:58,290
And what I would recommend by
the way, is that we will post

794
00:47:58,290 --> 00:48:02,880
the handouts on the web, but
at the end of every lecture

795
00:48:02,880 --> 00:48:06,560
within a few hours or a few days
at least, go through the

796
00:48:06,560 --> 00:48:11,150
handouts and make sure you
understand everything in.

797
00:48:11,150 --> 00:48:14,380
Because if you don't, you're
probably missing something

798
00:48:14,380 --> 00:48:16,350
you'll need to understand
to do the problem sets.

799
00:48:16,350 --> 00:48:19,250

800
00:48:19,250 --> 00:48:22,860
So here's a little program that
finds the cube root of a

801
00:48:22,860 --> 00:48:25,200
perfect cube.

802
00:48:25,200 --> 00:48:28,280
This, by the way, is a useful
comment here, right?

803
00:48:28,280 --> 00:48:31,770
Tells you what the program
is intended to do.

804
00:48:31,770 --> 00:48:33,770
So we get an integer.

805
00:48:33,770 --> 00:48:36,830
We set the variable
ans to zero.

806
00:48:36,830 --> 00:48:41,820
And then while ans times ans
times ans is less than the

807
00:48:41,820 --> 00:48:45,810
absolute value of x,
we're going to set

808
00:48:45,810 --> 00:48:48,230
ans to ans plus 1.

809
00:48:48,230 --> 00:48:50,360
We could print where we are.

810
00:48:50,360 --> 00:48:54,180
I put those sort of things in
as debugging statements.

811
00:48:54,180 --> 00:48:59,570
If ans times ans times ans is
not equal to the absolute

812
00:48:59,570 --> 00:49:06,800
value of x when I finish the
loop, then I'll print x is not

813
00:49:06,800 --> 00:49:09,850
a perfect cube.

814
00:49:09,850 --> 00:49:12,050
Otherwise I have to do something
to deal with

815
00:49:12,050 --> 00:49:14,780
positive and negative values.

816
00:49:14,780 --> 00:49:20,620
Now I know that this was fast
and that most of you probably

817
00:49:20,620 --> 00:49:23,490
don't fully assimilate
this program.

818
00:49:23,490 --> 00:49:25,290
Do not worry.

819
00:49:25,290 --> 00:49:30,040
It will be discussed in
recitations tomorrow.

820
00:49:30,040 --> 00:49:34,010
So tomorrow, the recitations
will review the Python

821
00:49:34,010 --> 00:49:38,870
concepts we've discussed today,
but we'll start by

822
00:49:38,870 --> 00:49:41,570
emphasizing how these
loops work.

823
00:49:41,570 --> 00:49:42,320
OK.

824
00:49:42,320 --> 00:49:44,020
Thanks for coming.

825
00:49:44,020 --> 00:49:45,360
Enjoy recitation tomorrow.

826
00:49:45,360 --> 00:49:48,757
1
00:00:00,000 --> 00:00:00,040

2
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

3
00:00:02,460 --> 00:00:03,870
Commons license.

4
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

5
00:00:06,910 --> 00:00:10,560
offer high-quality educational
resources for free.

6
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

7
00:00:13,460 --> 00:00:19,290
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:19,290 --> 00:00:20,540
ocw.mit.edu.

9
00:00:20,540 --> 00:00:22,080

10
00:00:22,080 --> 00:00:27,070
PROFESSOR: I want to finish up
our little excursion into

11
00:00:27,070 --> 00:00:31,450
searching and sorting, a very
important topic in computing.

12
00:00:31,450 --> 00:00:35,060
How do you sort lists
or databases?

13
00:00:35,060 --> 00:00:37,910
How do you search them?

14
00:00:37,910 --> 00:00:41,140
And I want to finish
it up with hashing.

15
00:00:41,140 --> 00:00:46,670
Hashing is how dictionaries
are implemented in Python.

16
00:00:46,670 --> 00:00:49,520
And this leads to a
very efficient--

17
00:00:49,520 --> 00:00:53,250
at least most of the
time-- search.

18
00:00:53,250 --> 00:00:56,280
But it comes at the
cost of space.

19
00:00:56,280 --> 00:01:01,970
So this is an example where one
can trade space for time.

20
00:01:01,970 --> 00:01:03,480
So I want to start
with a simple

21
00:01:03,480 --> 00:01:06,260
example to explain hashing.

22
00:01:06,260 --> 00:01:09,800
And I'm going to begin by
assuming that what we're

23
00:01:09,800 --> 00:01:15,480
hashing is a set of integers.

24
00:01:15,480 --> 00:01:19,650
So we want to build a set of
integers and detect whether or

25
00:01:19,650 --> 00:01:23,290
not a particular integer
is in that set.

26
00:01:23,290 --> 00:01:28,360
And we want to do
that quickly.

27
00:01:28,360 --> 00:01:37,610
So the basic idea is we're going
to take an integer--

28
00:01:37,610 --> 00:01:39,880
call it i--

29
00:01:39,880 --> 00:01:41,560
and we're going to hash it.

30
00:01:41,560 --> 00:01:44,870
I'll tell you what that
means in a minute.

31
00:01:44,870 --> 00:01:51,420
And what a hash function does
is it converts i to a

32
00:01:51,420 --> 00:01:57,090
different integer, perhaps,
in some range.

33
00:01:57,090 --> 00:02:09,729
So it, say, converts i to some
integer in the range 0 to k,

34
00:02:09,729 --> 00:02:13,540
for some constant k.

35
00:02:13,540 --> 00:02:21,660
We're going to then use
this integer to index

36
00:02:21,660 --> 00:02:31,320
into a list of lists.

37
00:02:31,320 --> 00:02:36,580
So each of these is
called a bucket.

38
00:02:36,580 --> 00:02:38,550
And a bucket will itself
be a list.

39
00:02:38,550 --> 00:02:41,740

40
00:02:41,740 --> 00:02:43,560
So this together is
called a bucket.

41
00:02:43,560 --> 00:02:49,880

42
00:02:49,880 --> 00:02:54,640
We've already seen that we can
find the i-th element of a

43
00:02:54,640 --> 00:02:57,470
list in constant time.

44
00:02:57,470 --> 00:03:02,300

45
00:03:02,300 --> 00:03:07,910
So when we ask whether some
integers in this set will hash

46
00:03:07,910 --> 00:03:14,870
it, we'll go immediately to the
correct bucket, the bucket

47
00:03:14,870 --> 00:03:17,610
associated with that integer.

48
00:03:17,610 --> 00:03:21,430
And then we'll search the list
at that bucket to see if the

49
00:03:21,430 --> 00:03:24,200
integer is there.

50
00:03:24,200 --> 00:03:28,130
If this list is short enough,
it will be very efficient.

51
00:03:28,130 --> 00:03:30,960
All, right I realize that's
very abstract.

52
00:03:30,960 --> 00:03:32,970
But let's look at the code,
which will make

53
00:03:32,970 --> 00:03:34,660
it much less abstract.

54
00:03:34,660 --> 00:03:47,330

55
00:03:47,330 --> 00:03:50,320
So the code starts with
something very ugly that I'll

56
00:03:50,320 --> 00:03:52,090
apologize for.

57
00:03:52,090 --> 00:03:55,030
But very soon, we'll see
how to get rid of that.

58
00:03:55,030 --> 00:03:59,530
I'm using a global variable here
to say how many buckets

59
00:03:59,530 --> 00:04:01,220
there are going to be.

60
00:04:01,220 --> 00:04:03,690
And I've very arbitrarily
chosen 47.

61
00:04:03,690 --> 00:04:07,200

62
00:04:07,200 --> 00:04:11,220
I then have a function called
create, which uses this global

63
00:04:11,220 --> 00:04:17,620
variable and creates a
list of lists, each

64
00:04:17,620 --> 00:04:21,130
element of which is empty.

65
00:04:21,130 --> 00:04:24,595
Because initially, we have
no elements in the set.

66
00:04:24,595 --> 00:04:28,280

67
00:04:28,280 --> 00:04:33,680
When I want to insert an element
in the set, I'll call

68
00:04:33,680 --> 00:04:41,215
the function insert, which
will hash the element.

69
00:04:41,215 --> 00:04:44,340
It doesn't actually even need
to use the global numBuckets

70
00:04:44,340 --> 00:04:47,640
in this case, in fact.

71
00:04:47,640 --> 00:04:52,190
And then append it to
the correct list.

72
00:04:52,190 --> 00:04:56,950
So it calls this function
hashElem, which could hardly

73
00:04:56,950 --> 00:04:58,770
be simpler.

74
00:04:58,770 --> 00:05:03,780
It just takes the remainder, the
modulus of the element and

75
00:05:03,780 --> 00:05:05,410
the number of buckets.

76
00:05:05,410 --> 00:05:09,490
So that will give me a
value between 0 and

77
00:05:09,490 --> 00:05:11,220
numBuckets minus 1.

78
00:05:11,220 --> 00:05:13,806

79
00:05:13,806 --> 00:05:15,940
It gives me one of the
list, and I'll just

80
00:05:15,940 --> 00:05:17,190
insert it at the end.

81
00:05:17,190 --> 00:05:20,610

82
00:05:20,610 --> 00:05:25,300
When I want to check for
membership, you'll see it's

83
00:05:25,300 --> 00:05:27,130
quite simple.

84
00:05:27,130 --> 00:05:35,760
All I do is ask the question,
is i in the list associated

85
00:05:35,760 --> 00:05:37,010
with the correct bucket?

86
00:05:37,010 --> 00:05:41,250

87
00:05:41,250 --> 00:05:44,930
Remove is a little bit more
complicated, but in fact, we

88
00:05:44,930 --> 00:05:47,890
don't need to spend much
time looking at it now.

89
00:05:47,890 --> 00:05:49,410
It's just some code.

90
00:05:49,410 --> 00:05:53,290
And the only reason it's
complicated is Insert doesn't

91
00:05:53,290 --> 00:05:55,470
look whether or not the element
is already there.

92
00:05:55,470 --> 00:05:58,530
So it may occur multiple
times in the list.

93
00:05:58,530 --> 00:06:00,740
So I would have to remove
each one of them.

94
00:06:00,740 --> 00:06:05,580

95
00:06:05,580 --> 00:06:08,230
People see the basic
structure of this?

96
00:06:08,230 --> 00:06:14,240

97
00:06:14,240 --> 00:06:17,000
Why a list of lists?

98
00:06:17,000 --> 00:06:23,780
Why don't I just, say, have a
list of Booleans, where I hash

99
00:06:23,780 --> 00:06:27,700
the integer, and it's true or
false, whether or not I've

100
00:06:27,700 --> 00:06:30,660
seen it, depending upon the
value of that bucket?

101
00:06:30,660 --> 00:06:31,910
Why can't I do that?

102
00:06:31,910 --> 00:06:37,690

103
00:06:37,690 --> 00:06:38,940
Somebody?

104
00:06:38,940 --> 00:06:40,940

105
00:06:40,940 --> 00:06:44,430
Well, what's the property
of this hash function?

106
00:06:44,430 --> 00:06:46,505
The key issue here is
the hash function --

107
00:06:46,505 --> 00:06:53,950

108
00:06:53,950 --> 00:06:55,940
is many-to-one.

109
00:06:55,940 --> 00:07:00,850

110
00:07:00,850 --> 00:07:05,490
That is to say, an infinite
number of different integers

111
00:07:05,490 --> 00:07:08,690
will hash to the same value.

112
00:07:08,690 --> 00:07:10,470
Because after all, I have
a set in which I

113
00:07:10,470 --> 00:07:14,170
can store any integer--

114
00:07:14,170 --> 00:07:16,920
or any positive integer,
at least--

115
00:07:16,920 --> 00:07:21,660
and there are only 47 buckets.

116
00:07:21,660 --> 00:07:25,790
So it's pretty obvious that many
integers will hash to the

117
00:07:25,790 --> 00:07:27,040
same bucket.

118
00:07:27,040 --> 00:07:29,490

119
00:07:29,490 --> 00:07:35,930
When two different elements hash
to the same bucket, we

120
00:07:35,930 --> 00:07:37,330
have what is called
a collision.

121
00:07:37,330 --> 00:07:44,890

122
00:07:44,890 --> 00:07:49,350
There are lots of different
ways to handle collisions.

123
00:07:49,350 --> 00:07:53,170
What I've shown you here is
probably the simplest way,

124
00:07:53,170 --> 00:07:55,375
which is called linear
rehashing.

125
00:07:55,375 --> 00:07:58,550

126
00:07:58,550 --> 00:07:59,815
I'm not actually rehashing.

127
00:07:59,815 --> 00:08:02,680

128
00:08:02,680 --> 00:08:03,930
I'm just keeping a list.

129
00:08:03,930 --> 00:08:08,026

130
00:08:08,026 --> 00:08:11,570
Does that makes sense?

131
00:08:11,570 --> 00:08:12,780
Yes, thank you for--

132
00:08:12,780 --> 00:08:14,390
I'm glad somebody
has a question.

133
00:08:14,390 --> 00:08:18,800

134
00:08:18,800 --> 00:08:21,700
You have to ask loudly.

135
00:08:21,700 --> 00:08:23,300
AUDIENCE: When you take
the modulus 47,

136
00:08:23,300 --> 00:08:25,120
what does that return?

137
00:08:25,120 --> 00:08:27,940

138
00:08:27,940 --> 00:08:28,926
PROFESSOR: 0.

139
00:08:28,926 --> 00:08:33,210
AUDIENCE: So hashElem
always returns 0?

140
00:08:33,210 --> 00:08:34,190
PROFESSOR: Well, no, sorry.

141
00:08:34,190 --> 00:08:37,150
It depends what I'm hashing.

142
00:08:37,150 --> 00:08:38,865
Sorry, I thought if you
were saying that if I

143
00:08:38,865 --> 00:08:41,730
asked 47 mod 47.

144
00:08:41,730 --> 00:08:47,395
If I take 48 mod 47, I get 1.

145
00:08:47,395 --> 00:08:49,790
If I take 49 mod 47--

146
00:08:49,790 --> 00:08:52,000
it's the remainder.

147
00:08:52,000 --> 00:08:53,675
Maybe I should have called
it just the remainder.

148
00:08:53,675 --> 00:08:56,540

149
00:08:56,540 --> 00:08:57,000
Look up.

150
00:08:57,000 --> 00:08:59,910
I'm about to throw
something at you.

151
00:08:59,910 --> 00:09:01,730
Ooh, I threw a curve ball.

152
00:09:01,730 --> 00:09:09,830

153
00:09:09,830 --> 00:09:10,035
OK.

154
00:09:10,035 --> 00:09:12,905
What's the complexity here
of the membership test?

155
00:09:12,905 --> 00:09:20,970

156
00:09:20,970 --> 00:09:23,380
Kind of hard to analyze.

157
00:09:23,380 --> 00:09:31,380
Roughly speaking, or exactly,
it will be the length of the

158
00:09:31,380 --> 00:09:35,640
bucket, the size
of the bucket.

159
00:09:35,640 --> 00:09:37,710
Now, I don't know how
many elements

160
00:09:37,710 --> 00:09:39,170
will be in the bucket.

161
00:09:39,170 --> 00:09:40,650
But what will this depend on?

162
00:09:40,650 --> 00:09:44,250

163
00:09:44,250 --> 00:09:47,910
It will depend upon the
number of buckets.

164
00:09:47,910 --> 00:09:52,250
If I have a million buckets,
I'll get a lot fewer

165
00:09:52,250 --> 00:09:57,280
collisions than if I
have two buckets.

166
00:09:57,280 --> 00:10:00,500
So let's look at an
example here.

167
00:10:00,500 --> 00:10:02,490
There's a small program
called test.

168
00:10:02,490 --> 00:10:11,700

169
00:10:11,700 --> 00:10:15,660
I said numBuckets to
47 in this case.

170
00:10:15,660 --> 00:10:19,820
And then I'm going to create
it, create a set.

171
00:10:19,820 --> 00:10:25,220
And then I'm going to put a
bunch of integers in it, then

172
00:10:25,220 --> 00:10:28,260
a few more, just for fun,
including one very big

173
00:10:28,260 --> 00:10:31,180
integer, just to show
that it works.

174
00:10:31,180 --> 00:10:34,800
Then I'm going to show you
what the set looks like.

175
00:10:34,800 --> 00:10:38,430
And in fact, what we'll do is
we'll stop it here and see

176
00:10:38,430 --> 00:10:39,680
what we get.

177
00:10:39,680 --> 00:10:52,960

178
00:10:52,960 --> 00:10:56,950
So what we'll see here is, as
you would expect with that

179
00:10:56,950 --> 00:11:00,650
number of buckets, each of the
small numbers hashes to a

180
00:11:00,650 --> 00:11:02,510
separate thing.

181
00:11:02,510 --> 00:11:04,170
That's just the way
remainder works.

182
00:11:04,170 --> 00:11:06,920

183
00:11:06,920 --> 00:11:08,470
Not surprisingly--

184
00:11:08,470 --> 00:11:11,200
in fact, it would be
disappointing if 325 didn't

185
00:11:11,200 --> 00:11:15,200
have the same value both
times I inserted it.

186
00:11:15,200 --> 00:11:17,980
So we say we happen to have
one bucket that's got two

187
00:11:17,980 --> 00:11:19,140
elements in it.

188
00:11:19,140 --> 00:11:20,950
Happen to be the same.

189
00:11:20,950 --> 00:11:24,730
But this very big number
happened to hash to the same

190
00:11:24,730 --> 00:11:27,500
value of 30 as 34.

191
00:11:27,500 --> 00:11:30,260
So here we have two
elements in it.

192
00:11:30,260 --> 00:11:33,190

193
00:11:33,190 --> 00:11:39,910
A good hash function has the
property that it will widely

194
00:11:39,910 --> 00:11:43,700
disperse the values you hash.

195
00:11:43,700 --> 00:11:49,740
So they end up in different
buckets, rather than some

196
00:11:49,740 --> 00:11:52,770
stupid hash function that tends
to put everything in the

197
00:11:52,770 --> 00:11:55,830
same bucket.

198
00:11:55,830 --> 00:12:03,970
Now, let's see what happens if I
change the number of buckets

199
00:12:03,970 --> 00:12:05,460
to, say, 3.

200
00:12:05,460 --> 00:12:17,240

201
00:12:17,240 --> 00:12:26,770
Well, not surprisingly, we get
some very big buckets, because

202
00:12:26,770 --> 00:12:30,760
there are relatively
few choices.

203
00:12:30,760 --> 00:12:34,260
So what we see here is we have
a genuine trade off between

204
00:12:34,260 --> 00:12:35,510
time and space.

205
00:12:35,510 --> 00:12:38,000

206
00:12:38,000 --> 00:12:43,550
If the number of buckets is
large relative to the number

207
00:12:43,550 --> 00:12:50,980
of elements that we insert in
the table, then looking at

208
00:12:50,980 --> 00:12:55,540
whether or not an element in
it is roughly order one.

209
00:12:55,540 --> 00:12:59,950
Because these lists will
be very short.

210
00:12:59,950 --> 00:13:04,290
So we can actually look up
something in constant time if

211
00:13:04,290 --> 00:13:06,760
we dedicate enough space
to the hash table.

212
00:13:06,760 --> 00:13:09,600

213
00:13:09,600 --> 00:13:13,310
If the hash table
is very small--

214
00:13:13,310 --> 00:13:17,190
the reduction ad absurdium
case of one bucket--

215
00:13:17,190 --> 00:13:20,610
then it's order n.

216
00:13:20,610 --> 00:13:21,770
It's not constant time.

217
00:13:21,770 --> 00:13:23,040
It's linear in the number
of elements.

218
00:13:23,040 --> 00:13:26,040

219
00:13:26,040 --> 00:13:30,090
Typically, when people use hash
tables, they make the

220
00:13:30,090 --> 00:13:35,240
hash tables big enough that for
all intents and purposes,

221
00:13:35,240 --> 00:13:38,330
you can assume that looking
something up is

222
00:13:38,330 --> 00:13:42,370
constant time, order 1.

223
00:13:42,370 --> 00:13:48,060
And that, in fact, is what
Python does with dictionaries.

224
00:13:48,060 --> 00:13:55,640
It hashes the keys and chooses
a big enough table so that

225
00:13:55,640 --> 00:13:58,890
looking up whether or not
something is in a dictionary

226
00:13:58,890 --> 00:14:02,600
can be done in constant time.

227
00:14:02,600 --> 00:14:07,280
If it then notices that the
table is too small, because

228
00:14:07,280 --> 00:14:11,390
you've ended up putting a lot
of elements in it, it just

229
00:14:11,390 --> 00:14:12,990
re-does it and gets
a bigger table.

230
00:14:12,990 --> 00:14:17,660

231
00:14:17,660 --> 00:14:21,430
So hashing is an extremely
powerful technique.

232
00:14:21,430 --> 00:14:27,420
And it's used all the time for
quite complicated things.

233
00:14:27,420 --> 00:14:31,430
Now is it useful here only when
we want to store ints?

234
00:14:31,430 --> 00:14:32,270
No.

235
00:14:32,270 --> 00:14:34,810
It would be kind of bad
if that were the case.

236
00:14:34,810 --> 00:14:40,225
In fact, any kind of immutable
object can be hashed.

237
00:14:40,225 --> 00:14:43,910

238
00:14:43,910 --> 00:14:48,570
Now, you may have wondered
why the keys in

239
00:14:48,570 --> 00:14:50,990
dicts have to be immutable.

240
00:14:50,990 --> 00:14:55,070
And that's so that they
can be hashed.

241
00:14:55,070 --> 00:14:57,120
Why does it have to
be immutable?

242
00:14:57,120 --> 00:15:00,970
Well, imagine that you
used a list as a key.

243
00:15:00,970 --> 00:15:04,040
You'd hash it when you put the
list in the hash table.

244
00:15:04,040 --> 00:15:06,460
But then you might mutate it,
and the next time you hashed

245
00:15:06,460 --> 00:15:09,490
it, you'd get a different value,
and so you wouldn't be

246
00:15:09,490 --> 00:15:12,110
able to find it again.

247
00:15:12,110 --> 00:15:15,410
So you need it to be a kind of
object, where every time you

248
00:15:15,410 --> 00:15:18,385
apply the hash function,
you get the same value.

249
00:15:18,385 --> 00:15:28,370

250
00:15:28,370 --> 00:15:30,260
I don't need to show you
that this works.

251
00:15:30,260 --> 00:15:33,210
You'll just believe
me, I'm sure.

252
00:15:33,210 --> 00:15:36,600
Let's look at a slightly more
complicated hash function.

253
00:15:36,600 --> 00:15:39,960

254
00:15:39,960 --> 00:15:43,220
Here, I want to hash something
that could be

255
00:15:43,220 --> 00:15:46,220
either an int or a string.

256
00:15:46,220 --> 00:15:48,480
So I first check and
see if it's an int.

257
00:15:48,480 --> 00:15:53,300
If so, I'll set the
value to be e.

258
00:15:53,300 --> 00:15:59,040
Then down at the bottom, I'll do
the modulus operator again.

259
00:15:59,040 --> 00:16:02,340
But if it's a string,
I'm going to first

260
00:16:02,340 --> 00:16:06,150
convert e to an int.

261
00:16:06,150 --> 00:16:09,020
And this is basically the trick
that people typically

262
00:16:09,020 --> 00:16:11,940
use when they're doing hashing,
is they convert

263
00:16:11,940 --> 00:16:13,915
whatever thing they have,
to some integer.

264
00:16:13,915 --> 00:16:16,610

265
00:16:16,610 --> 00:16:19,520
People do this with all
sorts of things.

266
00:16:19,520 --> 00:16:24,510
For example, this is the way
airport security systems today

267
00:16:24,510 --> 00:16:27,250
do face recognition.

268
00:16:27,250 --> 00:16:31,160
They hash every picture of a
face to an integer, and then

269
00:16:31,160 --> 00:16:34,010
look it up.

270
00:16:34,010 --> 00:16:36,420
So we can see it here.

271
00:16:36,420 --> 00:16:38,160
The way I'm doing it--
and the details

272
00:16:38,160 --> 00:16:40,000
don't very much matter--

273
00:16:40,000 --> 00:16:45,350
is I'm going to do it a
character at a time, do a

274
00:16:45,350 --> 00:16:50,540
shift ord of C, takes the
ASCII, the internal

275
00:16:50,540 --> 00:16:55,950
representation bits
of each character.

276
00:16:55,950 --> 00:16:58,070
And again, I don't care
if you understand how

277
00:16:58,070 --> 00:16:59,860
the code works here.

278
00:16:59,860 --> 00:17:03,580
What I just want you to see is
that it's not very long.

279
00:17:03,580 --> 00:17:07,630
And in, fact it's typically
fairly simple to hash almost

280
00:17:07,630 --> 00:17:09,880
any kind of an object.

281
00:17:09,880 --> 00:17:12,920
Because deep down, we know
that every object is

282
00:17:12,920 --> 00:17:17,380
represented by some string of
bits in the computer's memory.

283
00:17:17,380 --> 00:17:21,450
And we can always convert a
string of bits to an integer.

284
00:17:21,450 --> 00:17:25,750

285
00:17:25,750 --> 00:17:30,440
All right, so that's hashing, a
very powerful and extremely

286
00:17:30,440 --> 00:17:31,690
useful technique.

287
00:17:31,690 --> 00:17:35,370

288
00:17:35,370 --> 00:17:38,250
Yeah?

289
00:17:38,250 --> 00:17:39,210
AUDIENCE: [INAUDIBLE]

290
00:17:39,210 --> 00:17:43,221
you're returning something,
will you always find the

291
00:17:43,221 --> 00:17:45,656
remainder, or can you
use [INAUDIBLE]?

292
00:17:45,656 --> 00:17:47,510
PROFESSOR: There are many
different ways of doing hash.

293
00:17:47,510 --> 00:17:54,770
All the hash function has to
do is convert its argument

294
00:17:54,770 --> 00:17:58,240
into an integer in some way or
another within a fixed range.

295
00:17:58,240 --> 00:18:01,420

296
00:18:01,420 --> 00:18:04,180
It happens to be that remainder
is a very simple way

297
00:18:04,180 --> 00:18:07,960
to do that and is often used.

298
00:18:07,960 --> 00:18:11,650
There's a whole theory
about hash functions.

299
00:18:11,650 --> 00:18:15,730
You can read about them in
gory detail on Wikipedia.

300
00:18:15,730 --> 00:18:18,720
The math can actually be quite
complicated, and there's no

301
00:18:18,720 --> 00:18:20,730
real need to understand it.

302
00:18:20,730 --> 00:18:23,780
I typically do something like
dividing by a prime number,

303
00:18:23,780 --> 00:18:26,980
which is known to have
good properties.

304
00:18:26,980 --> 00:18:30,000
But, again, you can get carried
away with this.

305
00:18:30,000 --> 00:18:34,310
And it's usually not worth the
trouble, unless you're very

306
00:18:34,310 --> 00:18:37,550
deeply involved in something.

307
00:18:37,550 --> 00:18:39,360
OK?

308
00:18:39,360 --> 00:18:41,830
And then I've got another
program that does this, but

309
00:18:41,830 --> 00:18:43,750
again, I don't think much
would be served by

310
00:18:43,750 --> 00:18:45,380
running it for you.

311
00:18:45,380 --> 00:18:47,100
Any questions about hashing?

312
00:18:47,100 --> 00:18:50,970

313
00:18:50,970 --> 00:18:51,380
Yes?

314
00:18:51,380 --> 00:18:54,132
AUDIENCE: So does this only
work because you said

315
00:18:54,132 --> 00:18:54,615
[INAUDIBLE]

316
00:18:54,615 --> 00:18:57,513
Python treats lists
in a certain way?

317
00:18:57,513 --> 00:19:01,860
You said other languages, you
can't have this constant time

318
00:19:01,860 --> 00:19:02,826
list search.

319
00:19:02,826 --> 00:19:04,290
So how would hashing work?

320
00:19:04,290 --> 00:19:08,410
PROFESSOR: So the question is
that, because Python gives us

321
00:19:08,410 --> 00:19:11,781
constant-time looking up for
lists is the key to making

322
00:19:11,781 --> 00:19:13,710
this work --

323
00:19:13,710 --> 00:19:17,180
every programming language
I know has some

324
00:19:17,180 --> 00:19:19,680
concept that's similar.

325
00:19:19,680 --> 00:19:23,720
In, say, C, it's not a list,
but it's an array.

326
00:19:23,720 --> 00:19:26,620
And so in C, you would use
array for this purpose?

327
00:19:26,620 --> 00:19:30,570
In Java, you would use the
arrays for this purpose?

328
00:19:30,570 --> 00:19:34,730
But yes, you can do this in
any programming language,

329
00:19:34,730 --> 00:19:38,320
because every reasonable
programming language has some

330
00:19:38,320 --> 00:19:44,380
way to create the equivalent
of a list, in which you can

331
00:19:44,380 --> 00:19:48,180
get a particular index
in constant time.

332
00:19:48,180 --> 00:19:50,440
So it's a universally
useful technique.

333
00:19:50,440 --> 00:19:53,000

334
00:19:53,000 --> 00:19:53,830
Good question.

335
00:19:53,830 --> 00:19:56,010
Anything else?

336
00:19:56,010 --> 00:20:01,160
If not, we're about to abandon
searching and sorting, and in

337
00:20:01,160 --> 00:20:04,395
fact, abandon algorithms
in general for a while.

338
00:20:04,395 --> 00:20:07,650

339
00:20:07,650 --> 00:20:11,230
Bounced right off his hands.

340
00:20:11,230 --> 00:20:13,110
I will not sign you to
a baseball contract.

341
00:20:13,110 --> 00:20:16,930

342
00:20:16,930 --> 00:20:19,460
Pardon?

343
00:20:19,460 --> 00:20:21,430
Yes, I threw him
a Butterfinger?

344
00:20:21,430 --> 00:20:23,790
Oh, it's terrible.

345
00:20:23,790 --> 00:20:25,330
Boy, your jokes are
worse than mine.

346
00:20:25,330 --> 00:20:31,490

347
00:20:31,490 --> 00:20:36,300
I now want to move
on to the last--

348
00:20:36,300 --> 00:20:39,540
go back to Python, away from
algorithms, away from computer

349
00:20:39,540 --> 00:20:43,210
science in general, and talk
about the last three major

350
00:20:43,210 --> 00:20:48,240
linguistic concepts in Python,
exceptions, classes, and then

351
00:20:48,240 --> 00:20:49,490
later iterators.

352
00:20:49,490 --> 00:20:51,600

353
00:20:51,600 --> 00:20:54,310
Let's start with exceptions,
because we've already seen

354
00:20:54,310 --> 00:20:58,340
them, and they're
pretty simple.

355
00:20:58,340 --> 00:21:02,250
Exceptions are everywhere
in Python.

356
00:21:02,250 --> 00:21:04,070
And we've certainly seen
plenty of them

357
00:21:04,070 --> 00:21:05,320
all semester already.

358
00:21:05,320 --> 00:21:11,960

359
00:21:11,960 --> 00:21:22,970
We get them if we set some
list to, say [1,2]

360
00:21:22,970 --> 00:21:30,540
and then I asked for a test of
12, I get an index error.

361
00:21:30,540 --> 00:21:31,790
This is an exception.

362
00:21:31,790 --> 00:21:34,180

363
00:21:34,180 --> 00:21:37,150
We've got exceptions when we've
tried to convert things

364
00:21:37,150 --> 00:21:39,360
to incorrect types.

365
00:21:39,360 --> 00:21:44,820
So if I go into test, I'll
get a type error.

366
00:21:44,820 --> 00:21:49,360
Anything that ends in the word
"error" is a built-in kind of

367
00:21:49,360 --> 00:21:51,630
exception in Python.

368
00:21:51,630 --> 00:21:54,440
We've got them when we
accessed, nonexistent

369
00:21:54,440 --> 00:21:57,430
variables, a name error.

370
00:21:57,430 --> 00:22:00,610
So there are a whole bunch
of these things.

371
00:22:00,610 --> 00:22:02,490
In each of these cases--

372
00:22:02,490 --> 00:22:06,370
here, I'm just kind of playing
around in Python.

373
00:22:06,370 --> 00:22:10,930
And it printed an error message,
and it stopped.

374
00:22:10,930 --> 00:22:18,500
These kind of exceptions are
called unhandled exceptions,

375
00:22:18,500 --> 00:22:21,480
where they cause the program
to effectively crash.

376
00:22:21,480 --> 00:22:44,310

377
00:22:44,310 --> 00:22:45,950
The program just
stops running.

378
00:22:45,950 --> 00:22:48,740

379
00:22:48,740 --> 00:22:53,650
And I suspect that some of you
have written programs in which

380
00:22:53,650 --> 00:22:55,680
this has happened.

381
00:22:55,680 --> 00:22:59,250
In fact, is there anybody here
who has not written a program

382
00:22:59,250 --> 00:23:01,475
that crashed because of an
unhandled exception?

383
00:23:01,475 --> 00:23:04,600

384
00:23:04,600 --> 00:23:06,510
Good.

385
00:23:06,510 --> 00:23:09,730
For those of you watching
on TV, no hands went up.

386
00:23:09,730 --> 00:23:12,310

387
00:23:12,310 --> 00:23:14,900
Almost every day, I write a
program that crashes because

388
00:23:14,900 --> 00:23:17,330
of an unhandled exception.

389
00:23:17,330 --> 00:23:22,140
On the other hand, once my
program is debugged--

390
00:23:22,140 --> 00:23:23,750
once your program is
debugged-- this

391
00:23:23,750 --> 00:23:26,660
should never happen.

392
00:23:26,660 --> 00:23:30,090
Because there are mechanisms
in Python for handling

393
00:23:30,090 --> 00:23:32,610
exceptions.

394
00:23:32,610 --> 00:23:37,700
And in fact, as we'll see, it's
a perfectly valid flow of

395
00:23:37,700 --> 00:23:39,740
control concept.

396
00:23:39,740 --> 00:23:42,640
You will sometimes write
programs that are intended to

397
00:23:42,640 --> 00:23:44,760
raise exceptions.

398
00:23:44,760 --> 00:23:48,040
And then you'll catch the
exception and do something

399
00:23:48,040 --> 00:23:49,290
useful with it.

400
00:23:49,290 --> 00:23:51,680

401
00:23:51,680 --> 00:23:55,340
The way we use exceptions
is in something called a

402
00:23:55,340 --> 00:23:59,080
try-except block.

403
00:23:59,080 --> 00:24:07,080
So you write the word "try," and
then you have some code,

404
00:24:07,080 --> 00:24:12,325
and then "except," and
then some more code.

405
00:24:12,325 --> 00:24:17,740

406
00:24:17,740 --> 00:24:24,060
What the interpreter does is it
starts executing this code.

407
00:24:24,060 --> 00:24:27,470
If it gets through this code
without raising any kind of an

408
00:24:27,470 --> 00:24:30,290
exception, it jumps to the code

409
00:24:30,290 --> 00:24:32,220
following the except block.

410
00:24:32,220 --> 00:24:35,330

411
00:24:35,330 --> 00:24:40,660
On the other hand, if an
exception gets raised here, it

412
00:24:40,660 --> 00:24:45,020
immediately stops executing
this code and jumps to the

413
00:24:45,020 --> 00:24:49,940
start of this code, the code
associated with the except,

414
00:24:49,940 --> 00:24:52,460
and executes that.

415
00:24:52,460 --> 00:24:55,600
And, then when it finishes this,
it again goes to the

416
00:24:55,600 --> 00:24:56,870
code following the except.

417
00:24:56,870 --> 00:24:59,430

418
00:24:59,430 --> 00:25:04,760
Just like an if, you can
nest these things.

419
00:25:04,760 --> 00:25:08,860
It's just a control concept.

420
00:25:08,860 --> 00:25:11,350
It's nothing more.

421
00:25:11,350 --> 00:25:12,600
Let's look at an example.

422
00:25:12,600 --> 00:25:31,940

423
00:25:31,940 --> 00:25:33,190
So here's readVal.

424
00:25:33,190 --> 00:25:36,320

425
00:25:36,320 --> 00:25:38,080
This is a function.

426
00:25:38,080 --> 00:25:41,020
It's a polymorphic function.

427
00:25:41,020 --> 00:25:45,550
Its first argument is
of type 'type'.

428
00:25:45,550 --> 00:25:46,230
Remember--

429
00:25:46,230 --> 00:25:50,760
and you'll hear me say this a
1,000 more times at least--

430
00:25:50,760 --> 00:25:54,950
in Python, everything is an
object and can be manipulated

431
00:25:54,950 --> 00:25:57,200
by the program.

432
00:25:57,200 --> 00:25:59,590
It's one of the beauties
of Python.

433
00:25:59,590 --> 00:26:03,860
It's something that's not true
in many programming languages.

434
00:26:03,860 --> 00:26:10,220
So types are objects, just
like ints or floats.

435
00:26:10,220 --> 00:26:14,740
So the first argument to
readVal is a type.

436
00:26:14,740 --> 00:26:17,740
And then there are two strings,
the request message

437
00:26:17,740 --> 00:26:20,890
and the error message.

438
00:26:20,890 --> 00:26:26,730
It then sets a local variable,
numTries, to 0.

439
00:26:26,730 --> 00:26:32,170
And while numTries is less than
4, it sets val equal to

440
00:26:32,170 --> 00:26:35,510
raw input, printing the
request message.

441
00:26:35,510 --> 00:26:38,830

442
00:26:38,830 --> 00:26:45,410
And then it tries to convert val
to valType, whatever that

443
00:26:45,410 --> 00:26:47,480
happens to be.

444
00:26:47,480 --> 00:26:51,950
And if it succeeds,
it returns it.

445
00:26:51,950 --> 00:26:56,680
On the other hand, if during
this attempt to convert it an

446
00:26:56,680 --> 00:26:58,470
exception is raised--

447
00:26:58,470 --> 00:27:03,720
for example, the user is asked
to input an integer, and they

448
00:27:03,720 --> 00:27:07,760
type in the letter b, which
can't be converted to an int--

449
00:27:07,760 --> 00:27:14,130
then a type error exception
will be raised, or a value

450
00:27:14,130 --> 00:27:15,590
error exception.

451
00:27:15,590 --> 00:27:19,810
And if a value error exception
is raised, it prints the error

452
00:27:19,810 --> 00:27:26,740
message, increases numTries by
1, and goes back to the top of

453
00:27:26,740 --> 00:27:27,990
the y loop.

454
00:27:27,990 --> 00:27:31,020

455
00:27:31,020 --> 00:27:35,740
If it goes through this y loop
too many times, it leaves,

456
00:27:35,740 --> 00:27:40,140
raising the type error with the
message that the argument

457
00:27:40,140 --> 00:27:40,880
"numTries

458
00:27:40,880 --> 00:27:46,970
exceeded." All right.

459
00:27:46,970 --> 00:27:48,875
Let's run this and
see what happens.

460
00:27:48,875 --> 00:28:10,990

461
00:28:10,990 --> 00:28:14,180
Every once in a while,
funny things happen.

462
00:28:14,180 --> 00:28:18,430
When that happens, somehow,
clicking in this window, and

463
00:28:18,430 --> 00:28:20,410
then clicking back in
that window tends to

464
00:28:20,410 --> 00:28:23,040
make it work again.

465
00:28:23,040 --> 00:28:24,290
This is a bug in Python.

466
00:28:24,290 --> 00:28:30,420

467
00:28:30,420 --> 00:28:33,940
So it's now asked me
to enter an int.

468
00:28:33,940 --> 00:28:40,870
If I enter an int, everything
is good.

469
00:28:40,870 --> 00:28:42,550
It just prints it.

470
00:28:42,550 --> 00:28:51,630
On the other hand, if I run it,
and I enter the letter A,

471
00:28:51,630 --> 00:28:54,960
it will give me another
chance.

472
00:28:54,960 --> 00:28:59,190
And now I can enter an
int, and it's happy.

473
00:28:59,190 --> 00:29:10,270

474
00:29:10,270 --> 00:29:10,530
All right.

475
00:29:10,530 --> 00:29:17,290
Now, suppose I am unhappy with
the fact that if four times in

476
00:29:17,290 --> 00:29:21,510
a row I've failed to enter an
int, something bad happens.

477
00:29:21,510 --> 00:29:25,110
It comes back, and it
raises an exception.

478
00:29:25,110 --> 00:29:39,050
Well, I can catch that in the
code that calls readVal.

479
00:29:39,050 --> 00:29:41,970
So here at the top level, I'm
going to try readVal.

480
00:29:41,970 --> 00:29:44,480

481
00:29:44,480 --> 00:29:47,080
And then I'm going to say,
except if a type error is

482
00:29:47,080 --> 00:29:52,340
raised, print the argument
returned by that exception.

483
00:29:52,340 --> 00:29:55,940

484
00:29:55,940 --> 00:29:58,320
So this is what's called the
handler for the exception.

485
00:29:58,320 --> 00:30:01,470

486
00:30:01,470 --> 00:30:05,030
And so I don't have to crash
when the exception is raised.

487
00:30:05,030 --> 00:30:11,030
But I can actually deal with it
and do something sensible.

488
00:30:11,030 --> 00:30:14,730
If following the word "except,"
as you see over

489
00:30:14,730 --> 00:30:22,370
there, I have not listed any
exception names, then I'll go

490
00:30:22,370 --> 00:30:25,080
to the except clause
for all exceptions.

491
00:30:25,080 --> 00:30:26,820
Doesn't matter what
the exception is.

492
00:30:26,820 --> 00:30:29,650
I will go there.

493
00:30:29,650 --> 00:30:32,635
So I can write code that
captures any exception.

494
00:30:32,635 --> 00:30:38,610

495
00:30:38,610 --> 00:30:38,837
OK.

496
00:30:38,837 --> 00:30:42,790
Usually, that's not as good a
thing, because it shows that I

497
00:30:42,790 --> 00:30:45,510
did not anticipate what the
exception might be.

498
00:30:45,510 --> 00:30:48,270

499
00:30:48,270 --> 00:30:50,680
But you can see that
this is a pretty

500
00:30:50,680 --> 00:30:53,830
powerful programming paradigm.

501
00:30:53,830 --> 00:30:58,080
I can write this fairly compact
readVal function

502
00:30:58,080 --> 00:31:00,340
that's pretty robust.

503
00:31:00,340 --> 00:31:04,130
It's polymorphic, it can take
in what the error messages

504
00:31:04,130 --> 00:31:07,030
are, and it can try as
many times as I want.

505
00:31:07,030 --> 00:31:10,900

506
00:31:10,900 --> 00:31:12,898
Yeah?

507
00:31:12,898 --> 00:31:16,650
AUDIENCE: [INAUDIBLE] after
type error [INAUDIBLE]?

508
00:31:16,650 --> 00:31:19,200
AUDIENCE: PROFESSOR: You'll note
that when I raised the

509
00:31:19,200 --> 00:31:23,330
exception type error after it, I
had an open [UNINTELLIGIBLE]

510
00:31:23,330 --> 00:31:25,480
a string.

511
00:31:25,480 --> 00:31:30,030
So what this basically says is
that an exception can have

512
00:31:30,030 --> 00:31:33,220
associated with it a
set of arguments,

513
00:31:33,220 --> 00:31:35,300
a sequence of arguments.

514
00:31:35,300 --> 00:31:40,360
And I've just chosen to call the
first of the arguments s,

515
00:31:40,360 --> 00:31:43,060
so that I could then print it.

516
00:31:43,060 --> 00:31:46,810
So this is a fairly common
paradigm, that you associate a

517
00:31:46,810 --> 00:31:51,710
message with an exception,
explaining the exception.

518
00:31:51,710 --> 00:31:55,750
Since after all, type error is
not all that meaningful.

519
00:31:55,750 --> 00:31:57,860
And this tells me why it
was raised, that I

520
00:31:57,860 --> 00:32:01,030
tried too many times.

521
00:32:01,030 --> 00:32:04,630
OK, does it make sense?

522
00:32:04,630 --> 00:32:05,880
Anything else?

523
00:32:05,880 --> 00:32:07,980

524
00:32:07,980 --> 00:32:09,302
Yeah?

525
00:32:09,302 --> 00:32:10,552
AUDIENCE: [INAUDIBLE]

526
00:32:10,552 --> 00:32:13,586

527
00:32:13,586 --> 00:32:16,920
before you said [INAUDIBLE]?

528
00:32:16,920 --> 00:32:22,340
PROFESSOR: Well, what we'll see
when I execute something

529
00:32:22,340 --> 00:32:34,010
like assert false, it's actually
raising an exception.

530
00:32:34,010 --> 00:32:37,400
It's raising an assertion
error exception.

531
00:32:37,400 --> 00:32:41,560
And so I can actually catch that
and do something with it.

532
00:32:41,560 --> 00:32:43,360
I've been using these
asserts just

533
00:32:43,360 --> 00:32:46,310
basically to stop the program.

534
00:32:46,310 --> 00:32:49,290
But we've also seen that
sometimes in functions, we use

535
00:32:49,290 --> 00:32:52,940
assertions to check the types
of the arguments.

536
00:32:52,940 --> 00:32:56,560
But if you don't catch that
exception, then the program

537
00:32:56,560 --> 00:32:58,830
crashes with the wrong
arguments, without doing

538
00:32:58,830 --> 00:33:00,560
anything useful.

539
00:33:00,560 --> 00:33:05,040
Because that's just an
exception, I can catch it, and

540
00:33:05,040 --> 00:33:07,350
then do something useful.

541
00:33:07,350 --> 00:33:11,250
So it's, again, just
an example of that.

542
00:33:11,250 --> 00:33:13,730
We're going to try your
hands once more.

543
00:33:13,730 --> 00:33:16,860
I'll throw you a different
kind of candy.

544
00:33:16,860 --> 00:33:19,820
And this time he caught it.

545
00:33:19,820 --> 00:33:21,070
Two for two.

546
00:33:21,070 --> 00:33:25,360

547
00:33:25,360 --> 00:33:28,460
Very powerful.

548
00:33:28,460 --> 00:33:32,140
A very useful mechanism.

549
00:33:32,140 --> 00:33:35,400
You can use them for sort
of catching errors,

550
00:33:35,400 --> 00:33:36,650
as we've done here.

551
00:33:36,650 --> 00:33:39,100

552
00:33:39,100 --> 00:33:43,050
They are frequently used in
situations where you are

553
00:33:43,050 --> 00:33:46,350
getting input from a user.

554
00:33:46,350 --> 00:33:50,490
So for example, if you were
writing a text editor, and you

555
00:33:50,490 --> 00:33:54,710
wanted to open up a file, and
you typed in the file name,

556
00:33:54,710 --> 00:33:59,130
and it didn't exist, you would
in Python get an error message

557
00:33:59,130 --> 00:34:01,130
when you try to open
that file.

558
00:34:01,130 --> 00:34:05,510
It would raise an exception,
"File Not Found," basically,

559
00:34:05,510 --> 00:34:09,870
which you could then catch, and
then print to the user a

560
00:34:09,870 --> 00:34:13,760
useful error message saying,
"File Not Found."

561
00:34:13,760 --> 00:34:17,510
Similarly, if you try and write
to a file that already

562
00:34:17,510 --> 00:34:22,370
exists, you can get an exception
saying, do you

563
00:34:22,370 --> 00:34:24,650
really want to overwrite
this file?

564
00:34:24,650 --> 00:34:26,310
And ask the user.

565
00:34:26,310 --> 00:34:29,429
So it's very commonly
used in a lot of

566
00:34:29,429 --> 00:34:31,800
programs as a mechanism.

567
00:34:31,800 --> 00:34:35,620
And now, as we go on and see
more and more code, you'll see

568
00:34:35,620 --> 00:34:39,850
that I'm going to start using
exceptions fairly frequently

569
00:34:39,850 --> 00:34:43,060
as a flow of control
mechanism.

570
00:34:43,060 --> 00:34:45,830
It makes certain kinds of
code easier to write.

571
00:34:45,830 --> 00:34:48,350

572
00:34:48,350 --> 00:34:49,440
All right.

573
00:34:49,440 --> 00:34:53,230
That's all I have to say
about exceptions.

574
00:34:53,230 --> 00:34:57,250
Simple but useful mechanism.

575
00:34:57,250 --> 00:34:59,900
Now, on to something
that's even more

576
00:34:59,900 --> 00:35:02,113
useful, but not so simple.

577
00:35:02,113 --> 00:35:04,830

578
00:35:04,830 --> 00:35:08,770
It is probably the
distinguishing thing, not only

579
00:35:08,770 --> 00:35:13,100
in Python, but in
a whole class of

580
00:35:13,100 --> 00:35:15,620
modern programming languages.

581
00:35:15,620 --> 00:35:17,780
And that's the notion
of a class.

582
00:35:17,780 --> 00:35:26,230

583
00:35:26,230 --> 00:35:27,800
I'm not going to finish
it today.

584
00:35:27,800 --> 00:35:32,220
I'm barely going to scratch
the surface of it today.

585
00:35:32,220 --> 00:35:35,430
But we're going to start leading
up and I will pretty

586
00:35:35,430 --> 00:35:37,215
much finish it on Thursday.

587
00:35:37,215 --> 00:35:39,880

588
00:35:39,880 --> 00:35:52,100
We've already seen the notion of
a module, which has been a

589
00:35:52,100 --> 00:35:53,750
collection of related
functions.

590
00:35:53,750 --> 00:36:01,480

591
00:36:01,480 --> 00:36:06,660
So, for example, we've seen code
that includes something

592
00:36:06,660 --> 00:36:08,390
like import math.

593
00:36:08,390 --> 00:36:13,160

594
00:36:13,160 --> 00:36:17,220
And that provided me
with access to

595
00:36:17,220 --> 00:36:18,620
functions like math.log.

596
00:36:18,620 --> 00:36:23,710

597
00:36:23,710 --> 00:36:28,480
What the module mechanism does
in the import mechanism, it

598
00:36:28,480 --> 00:36:32,690
makes it convenient
to import a lot of

599
00:36:32,690 --> 00:36:36,550
related things at once.

600
00:36:36,550 --> 00:36:47,920
And then we use this dot
notation to disambiguate, to

601
00:36:47,920 --> 00:36:50,740
tell us, well, which log.

602
00:36:50,740 --> 00:36:54,760
Typically, there's probably
only one log function.

603
00:36:54,760 --> 00:37:03,540
But certainly, you might imagine
that set.member and

604
00:37:03,540 --> 00:37:09,940
table.member would
be different, and

605
00:37:09,940 --> 00:37:11,190
that both might exist.

606
00:37:11,190 --> 00:37:15,250

607
00:37:15,250 --> 00:37:20,030
And as we've said before, the
dot notation avoids conflicts

608
00:37:20,030 --> 00:37:21,280
by disambiguating.

609
00:37:21,280 --> 00:37:31,460

610
00:37:31,460 --> 00:37:31,695
OK.

611
00:37:31,695 --> 00:37:32,870
That's a module.

612
00:37:32,870 --> 00:37:41,100
What a class is, it is like a
module, but it's not just a

613
00:37:41,100 --> 00:37:44,750
collection of functions.

614
00:37:44,750 --> 00:38:04,010
A class is a collection of data
and functions, functions

615
00:38:04,010 --> 00:38:05,730
that operate on that data.

616
00:38:05,730 --> 00:38:08,420

617
00:38:08,420 --> 00:38:13,520
They are bound together, so that
you can pass an object

618
00:38:13,520 --> 00:38:17,490
from one part of a program
to another.

619
00:38:17,490 --> 00:38:21,950
And the part of the program
to which you pass it

620
00:38:21,950 --> 00:38:27,680
automatically gets access to the
functions associated with

621
00:38:27,680 --> 00:38:29,245
that type of object.

622
00:38:29,245 --> 00:38:33,670

623
00:38:33,670 --> 00:38:37,550
And this is really the key
to what people call

624
00:38:37,550 --> 00:38:42,430
object-oriented programming,
a very popular buzzword.

625
00:38:42,430 --> 00:38:53,150

626
00:38:53,150 --> 00:38:56,580
So we've already seen that kind
of thing, where if we

627
00:38:56,580 --> 00:39:01,690
pass a list from one function
to another, we can write

628
00:39:01,690 --> 00:39:07,775
something like L.append,
some value.

629
00:39:07,775 --> 00:39:16,690

630
00:39:16,690 --> 00:39:21,760
The data and functions
associated with an object are

631
00:39:21,760 --> 00:39:24,800
called that object's
attributes.

632
00:39:24,800 --> 00:39:32,510

633
00:39:32,510 --> 00:39:41,670
So you can think of this as a
way to associate attributes

634
00:39:41,670 --> 00:39:42,920
with objects.

635
00:39:42,920 --> 00:39:51,400

636
00:39:51,400 --> 00:39:54,480
Now, I've been talking about
data and functions as if

637
00:39:54,480 --> 00:39:57,720
they're different
kinds of things.

638
00:39:57,720 --> 00:40:02,210
In fact, they're not really,
because they're just objects.

639
00:40:02,210 --> 00:40:05,360
In Python, everything is an
object, including, as we'll

640
00:40:05,360 --> 00:40:10,570
see on Thursday, the class
itself is an object.

641
00:40:10,570 --> 00:40:13,710
When people talk about objects
and object-oriented

642
00:40:13,710 --> 00:40:21,570
programming, they often use a
message passing metaphor.

643
00:40:21,570 --> 00:40:24,385
And I want to emphasize it's
nothing more than a metaphor.

644
00:40:24,385 --> 00:40:28,980

645
00:40:28,980 --> 00:40:32,960
And I almost hesitate to bring
it up, because it makes it all

646
00:40:32,960 --> 00:40:35,460
sound more complicated
than it is.

647
00:40:35,460 --> 00:40:37,980
But you will see this phrase
in the literature.

648
00:40:37,980 --> 00:40:39,480
People will use it.

649
00:40:39,480 --> 00:40:42,050
So you need to know
what it is.

650
00:40:42,050 --> 00:40:48,970
The basic metaphor is that when
I write something like

651
00:40:48,970 --> 00:40:57,690
L.append, I am passing the
message append e to the object

652
00:40:57,690 --> 00:41:03,970
L. And then there's a mechanism
for looking up what

653
00:41:03,970 --> 00:41:08,760
that object means, what
that message means.

654
00:41:08,760 --> 00:41:13,270
And then the object, L, executes
that message, and

655
00:41:13,270 --> 00:41:14,520
does something.

656
00:41:14,520 --> 00:41:17,970

657
00:41:17,970 --> 00:41:29,150
So, for example, if I had a
class called Circle, I might

658
00:41:29,150 --> 00:41:32,020
pass the object C --

659
00:41:32,020 --> 00:41:36,850
the message area, which would
cause this object to return

660
00:41:36,850 --> 00:41:41,120
the area of its own area, the
area of the circle that is

661
00:41:41,120 --> 00:41:42,370
that object.

662
00:41:42,370 --> 00:41:45,140

663
00:41:45,140 --> 00:41:48,510
Again, nothing dramatic
going on here.

664
00:41:48,510 --> 00:41:52,800
If you just think of this as
a fancy way of writing

665
00:41:52,800 --> 00:41:57,000
functions, you'll be
absolutely correct.

666
00:41:57,000 --> 00:42:01,520
But I did think you should
hear about this metaphor.

667
00:42:01,520 --> 00:42:05,160
I add by the way --
should have--

668
00:42:05,160 --> 00:42:08,270
I've been using the word...

669
00:42:08,270 --> 00:42:18,290
Method is a function associated
with an object.

670
00:42:18,290 --> 00:42:29,110

671
00:42:29,110 --> 00:42:34,280
So in this case, the method area
is associated with the

672
00:42:34,280 --> 00:42:40,610
object C. And purists would say,
always refer to append as

673
00:42:40,610 --> 00:42:44,910
a method, rather than a
function, because we use the

674
00:42:44,910 --> 00:42:48,890
dot notation to get to it, and
it's always associated with

675
00:42:48,890 --> 00:42:50,885
some object of type list.

676
00:42:50,885 --> 00:42:58,800

677
00:42:58,800 --> 00:43:06,310
Now, just as data can have
types, objects, as we know,

678
00:43:06,310 --> 00:43:08,450
have types.

679
00:43:08,450 --> 00:43:16,290
What a class is is it's a
collection of objects with

680
00:43:16,290 --> 00:43:23,870
identical characteristics
that form a type.

681
00:43:23,870 --> 00:43:28,190
So we can use classes to
introduce new types into the

682
00:43:28,190 --> 00:43:30,490
programming environment.

683
00:43:30,490 --> 00:43:34,890
So as you think about
existing things--

684
00:43:34,890 --> 00:43:37,570
now, I won't put that up,
because it will disappear

685
00:43:37,570 --> 00:43:39,990
behind the screen.

686
00:43:39,990 --> 00:43:46,365
We've looked at things
like lists and dict.

687
00:43:46,365 --> 00:43:51,980

688
00:43:51,980 --> 00:43:54,180
What these are are
built-in classes.

689
00:43:54,180 --> 00:44:00,240

690
00:44:00,240 --> 00:44:06,960
They happen to be classes that
are so useful that somebody

691
00:44:06,960 --> 00:44:09,750
decided they should be part of
the language, they should have

692
00:44:09,750 --> 00:44:13,160
efficient implementations,
they should be built-in,

693
00:44:13,160 --> 00:44:16,770
people shouldn't have to
reimplement them themselves.

694
00:44:16,770 --> 00:44:19,180
And in fact, there are a whole
bunch of interesting built-in

695
00:44:19,180 --> 00:44:21,300
classes in Python.

696
00:44:21,300 --> 00:44:24,580
And there are a whole bunch of
libraries of classes you can

697
00:44:24,580 --> 00:44:27,140
bring in-- and we'll look
at many of those--

698
00:44:27,140 --> 00:44:30,390
that extend it.

699
00:44:30,390 --> 00:44:33,000
And that's the beauty of
the class mechanism.

700
00:44:33,000 --> 00:44:39,180
It lets you add new types to
the language that are every

701
00:44:39,180 --> 00:44:42,530
bit as easy to use as
the built-in types.

702
00:44:42,530 --> 00:44:47,220
So in effect, the language can
be extended to add new and

703
00:44:47,220 --> 00:44:49,440
useful types.

704
00:44:49,440 --> 00:44:51,260
And we'll look at several
examples of

705
00:44:51,260 --> 00:44:52,510
that starting on Thursday.

706
00:44:52,510 --> 00:44:56,107